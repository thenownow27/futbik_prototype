<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Telegram Web App</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- –°—Ç–∞—Ä—Ç–æ–≤–æ–µ –º–µ–Ω—é -->
    <div id="start-screen">
        <img src="assets/futbik_logo.png" alt="FUTBIK" class="game-logo">
        <div class="menu-buttons">
            <button class="menu-button" id="btn-start">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
            <button class="menu-button" id="btn-collection">–ú–æ—è –∫–æ–ª–ª–µ–∫—Ü–∏—è</button>
            <button class="menu-button" id="btn-packs">–û—Ç–∫—Ä—ã—Ç—å –Ω–∞–±–æ—Ä—ã</button>
            <button class="menu-button" id="btn-points">–ü–æ–ª—É—á–∏—Ç—å –æ—á–∫–∏</button>
        </div>
    </div>
    
    <!-- –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã -->
    <div id="faction-screen">
        <!-- –°–µ–∫—Ü–∏—è 1: –í—ã–±–æ—Ä —Å–≤–æ–µ–π –∫–æ–º–∞–Ω–¥—ã -->
        <div class="faction-section">
            <h2 class="faction-section-title">–í–´–ë–ï–†–ò–¢–ï –ö–û–ú–ê–ù–î–£</h2>
            <div class="faction-grid" id="player-faction-grid">
                <div class="faction-square" data-team="spartak">
                    <img src="assets/logos/spartak_logo.png" alt="–°–ø–∞—Ä—Ç–∞–∫">
                </div>
                <div class="faction-square" data-team="footballstars">
                    <img src="assets/logos/footballstars_white.png" alt="–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞">
                </div>
                <div class="faction-square" data-team="rpl">
                    <img src="assets/logos/rpl.png" alt="–†–ü–õ">
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
            </div>
        </div>
        
        <!-- –†–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å -->
        <div class="faction-vs-divider">VS</div>
        
        <!-- –°–µ–∫—Ü–∏—è 2: –í—ã–±–æ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ -->
        <div class="faction-section">
            <h2 class="faction-section-title">–í–´–ë–ï–†–ò–¢–ï –°–û–ü–ï–†–ù–ò–ö–ê</h2>
            <div class="faction-grid" id="enemy-faction-grid">
                <div class="faction-square" data-team="spartak">
                    <img src="assets/logos/spartak_logo.png" alt="–°–ø–∞—Ä—Ç–∞–∫">
                </div>
                <div class="faction-square" data-team="footballstars">
                    <img src="assets/logos/footballstars_white.png" alt="–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞">
                </div>
                <div class="faction-square" data-team="rpl">
                    <img src="assets/logos/rpl.png" alt="–†–ü–õ">
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
            </div>
        </div>
        
        <!-- –§—É—Ç–µ—Ä —Å –∫–Ω–æ–ø–∫–æ–π -->
        <div class="faction-footer">
            <button class="menu-button" id="btn-faction-next" disabled>–î–ê–õ–ï–ï</button>
            <button class="menu-button back-button" id="btn-back-to-menu">–ù–∞–∑–∞–¥</button>
        </div>
    </div>
    
    <!-- –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ -->
    <div id="collection-faction-screen" style="display: none;">
        <div class="faction-section">
            <h2 class="faction-section-title">–í–´–ë–ï–†–ò–¢–ï –ö–û–ú–ê–ù–î–£</h2>
            <div class="faction-grid" id="collection-team-grid">
                <div class="faction-square" data-view-team="spartak">
                    <img src="assets/logos/spartak_logo.png" alt="–°–ø–∞—Ä—Ç–∞–∫">
                </div>
                <div class="faction-square" data-view-team="footballstars">
                    <img src="assets/logos/footballstars_white.png" alt="–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞">
                </div>
                <div class="faction-square" data-view-team="rpl">
                    <img src="assets/logos/rpl.png" alt="–†–ü–õ">
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
                <div class="faction-square locked">
                    <span class="lock-icon">üîí</span>
                </div>
            </div>
        </div>
        
        <div class="faction-footer">
            <button class="menu-button back-button" id="btn-back-from-collection-select">–ù–∞–∑–∞–¥</button>
        </div>
    </div>
    
    <!-- –≠–∫—Ä–∞–Ω —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–∞–≤–æ–º -->
    <div id="squad-screen">
        <h1>–í–ê–® –°–û–°–¢–ê–í</h1>
        <div class="squad-stats">
            <button id="btn-back-from-squad" class="squad-back-btn">‚Üê</button>
            <div class="squad-timer-wrapper">
                <span class="squad-timer-label">–¢–∞–π–º–µ—Ä:</span>
                <div id="squad-timer">30</div>
            </div>
            <div class="squad-counters">
                <span id="subs-counter">–ó–∞–º–µ–Ω: 0/3</span>
            </div>
        </div>
        <div id="squad-grid"></div>
        <div class="squad-buttons">
            <button id="btn-subs-action" class="squad-action-btn">–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—ã</button>
            <button id="btn-start-action" class="squad-action-btn start-btn">–ù–∞—á–∞—Ç—å –º–∞—Ç—á</button>
        </div>
    </div>
    
    <!-- –≠–∫—Ä–∞–Ω –∫–æ–ª–ª–µ–∫—Ü–∏–∏ (–ø—Ä–æ—Å–º–æ—Ç—Ä –∫–∞—Ä—Ç) -->
    <div id="collection-cards-screen">
        <h1 id="collection-cards-title">–í–ê–®–ê –ö–û–õ–õ–ï–ö–¶–ò–Ø (–°–ø–∞—Ä—Ç–∞–∫)</h1>
        <div id="collection-cards-grid"></div>
        <button class="menu-button back-button" id="btn-back-from-cards">–ù–∞–∑–∞–¥</button>
    </div>
    
    <!-- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ -->
    <div id="game-screen">
        <!-- –ò–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ (Board) -->
        <div class="game-board">
            <!-- –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–æ–∫–∞: –ö–æ–ª–æ–¥–∞, –†—É–∫–∞, –û—Ç–±–æ–π —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ -->
            <div class="opponent-top-row">
                <!-- –†—É–∫–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ (–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è) -->
                <div id="opponent-hand" class="opponent-hand"></div>
            </div>
            
            <!-- –ë–ª–æ–∫ —Ä—è–¥–æ–≤ –°–æ–ø–µ—Ä–Ω–∏–∫–∞ -->
            <div class="game-zone enemy-zone opponent-rows opponent-side">
                <div class="enemy-cards-container" id="enemyCardsContainer"></div>
                
                <!-- –†—è–¥—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–ó–∞—â–∏—Ç–∞ -> –ü–æ–ª—É–∑–∞—â–∏—Ç–∞ -> –ê—Ç–∞–∫–∞) -->
                <div class="rows-container">
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="enemyDefenseTacticsSlot" data-row-id="defense">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="enemyDefenseRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/defense.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="enemyDefenseRightSlot" style="opacity: 0.5;">
                            <span class="tactics-slot-label">Coach</span>
                        </div>
                    </div>
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="enemyMidfieldTacticsSlot" data-row-id="midfield">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="enemyMidfieldRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/midfield.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="enemyMidfieldRightSlot">
                            <div class="deck-inner-slot" id="enemyDeck" style="width: 100%; height: 100%; background: url('assets/spartak_stack.jpg') center/cover; border-radius: 6px; position: relative;">
                                <div class="deck-counter" id="enemyDeckCounter" style="position: absolute; top: 70%; left: 0; width: 100%; text-align: center; transform: translateY(-50%); font-family: 'CustomHeader', sans-serif !important; font-size: 14px !important; font-weight: bold !important; background: transparent !important; box-shadow: none !important; border: none !important; padding: 0 !important;">0</div>
                            </div>
                        </div>
                    </div>
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="enemyAttackTacticsSlot" data-row-id="attack">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="enemyAttackRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/attack.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="enemyAttackRightSlot">
                            <div class="graveyard-inner-slot" id="enemyGraveyard" style="width: 100%; height: 100%; background: url('assets/spartak_graveyard.jpg') center/cover; border-radius: 6px; display: flex; align-items: center; justify-content: center;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–µ –¢–∞–±–ª–æ (—Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—å) -->
            <div id="main-scoreboard" class="scoreboard-center">
                <button id="ingame-settings-btn" class="settings-btn-visual">‚öôÔ∏è</button>
                <img id="player-team-logo" class="team-logo" src="assets/logos/spartak_logo.png" alt="Spartak">
                <div id="current-score-player">0</div>
                <div id="match-score">0:0</div>
                <div id="current-score-enemy">0</div>
                <img id="enemy-team-logo" class="team-logo" src="assets/logos/spartak_logo.png" alt="Spartak">
                <button id="ingame-pass-btn" class="pass-btn-visual">–ü–ê–°</button>
                <div id="scoreboard-notification"></div>
            </div>
            
            <!-- –ë–ª–æ–∫ —Ä—è–¥–æ–≤ –ò–≥—Ä–æ–∫–∞ -->
            <div class="game-zone player-zone player-rows player-side">
                <!-- –†—è–¥—ã –∏–≥—Ä–æ–∫–∞ (–ê—Ç–∞–∫–∞ -> –ü–æ–ª—É–∑–∞—â–∏—Ç–∞ -> –ó–∞—â–∏—Ç–∞) -->
                <div class="rows-container">
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="attackTacticsSlot" data-row-id="attack">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="attackRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/attack.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="playerAttackRightSlot">
                            <div class="graveyard-inner-slot" id="playerGraveyard" style="width: 100%; height: 100%; background: url('assets/spartak_graveyard.jpg') center/cover; border-radius: 6px; display: flex; align-items: center; justify-content: center;">
                            </div>
                        </div>
                    </div>
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="midfieldTacticsSlot" data-row-id="midfield">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="midfieldRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/midfield.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="playerMidfieldRightSlot">
                            <div class="deck-inner-slot" id="playerDeck" style="width: 100%; height: 100%; background: url('assets/spartak_stack.jpg') center/cover; border-radius: 6px; position: relative;">
                                <div class="deck-counter" id="playerDeckCounter" style="position: absolute; top: 70%; left: 0; width: 100%; text-align: center; transform: translateY(-50%); font-family: 'CustomHeader', sans-serif !important; font-size: 14px !important; font-weight: bold !important; background: transparent !important; box-shadow: none !important; border: none !important; padding: 0 !important; min-width: auto !important;">0</div>
                            </div>
                        </div>
                    </div>
                    <div class="row-with-tactics">
                        <div class="tactics-slot" id="defenseTacticsSlot" data-row-id="defense">
                            <span class="tactics-slot-label">–¢–∞–∫—Ç–∏–∫–∞</span>
                        </div>
                        <div class="field-row" id="defenseRow">
                            <span class="field-row-label">
                                <img src="assets/positions_row/defense.png" class="row-icon">
                            </span>
                        </div>
                        <div class="tactics-slot" id="playerDefenseRightSlot">
                            <span class="tactics-slot-label" style="opacity: 0.5;">Coach</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- –†—É–∫–∞ –∏–≥—Ä–æ–∫–∞ (Player Hand) - –≤–Ω–∏–∑—É —Å –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω—ã–º —Å–∫—Ä–æ–ª–ª–æ–º -->
        <div class="cards-container" id="cardsContainer"></div>
        
    </div>
    
    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏–≥—Ä—ã -->
    <div class="game-overlay" id="gameOverlay">
        <div class="game-result-modal">
            <div class="game-result-title" id="resultTitle">–ü–û–ë–ï–î–ê –°–ü–ê–†–¢–ê–ö–ê!</div>
            <div class="game-result-score" id="resultScore">–°—á–µ—Ç: 0 - 0</div>
            <button class="restart-button" id="restartButton">–°—ã–≥—Ä–∞—Ç—å –µ—â–µ</button>
        </div>
    </div>
    
    <!-- –û–≤–µ—Ä–ª–µ–π –¥–ª—è –¥–µ—Ç–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∫–∞—Ä—Ç -->
    <div id="card-inspection-overlay">
        <img id="inspected-card-image" src="" alt="Zoom">
    </div>
    
    <!-- –ü–æ–¥–∫–ª—é—á–∞–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç -->
    <script src="database.js"></script>
    
    <script>
        // --- HISTORY LOCK: Prevent back navigation gesture ---
        // This ensures that even if the browser interprets a swipe as "Back", 
        // it immediately goes "Forward" again, keeping the user in the game.
        history.pushState(null, null, location.href);
        window.onpopstate = function () {
            history.go(1);
        };
        
        // --- ULTIMATE SCROLL CONTROL & BUTTON FIX ---
        // --- ULTIMATE SCROLL CONTROL ---
        document.addEventListener('touchmove', function(e) {
            const target = e.target;

            // 1. ALLOW HORIZONTAL SCROLL IN HAND (Critical for Swipe)
            if (target.closest('#cardsContainer')) {
                // STOP here. Let the browser handle the scroll naturally.
                // Do NOT call preventDefault().
                return; 
            }

            // 2. Global Allowlist (Buttons, Inputs, AND COACH)
            if (target.tagName === 'BUTTON' || 
                target.closest('button') || 
                target.classList.contains('menu-button') ||
                target.closest('.menu-button') || 
                target.closest('.squad-buttons') || 
                target.classList.contains('squad-action-btn') ||
                // NEW: Allow Coach and Tactics Slot interactions
                target.closest('.coach-card') ||
                target.closest('.tactics-slot')) {
                return;
            }

            // 3. Define areas where scrolling is ALLOWED
            const scrollableIds = ['squad-grid', 'collection-cards-screen', 'collection-cards-grid', 'graveyard-grid', 'faction-screen'];
            
            // Check if the touch is inside one of these scrollable containers
            const scrollContainer = scrollableIds.reduce((found, id) => {
                return found || target.closest('#' + id);
            }, null);

            // 4. Logic: If inside a scrollable area, check if it ACTUALLY needs scrolling
            if (scrollContainer) {
                // Check BOTH Vertical AND Horizontal overflow
                const canScrollVertically = scrollContainer.scrollHeight > scrollContainer.clientHeight;
                const canScrollHorizontally = scrollContainer.scrollWidth > scrollContainer.clientWidth;

                if (canScrollVertically || canScrollHorizontally) {
                    // Prevent bubbling to body, but allow internal scroll
                    e.stopPropagation(); 
                    return; 
                }
            }

            // 5. BLOCK EVERYTHING ELSE (Prevents body bounce and background scroll)
            e.preventDefault();
        }, { passive: false });

        // 2. Prevent pinch-to-zoom
        document.addEventListener('gesturestart', function(e) {
            e.preventDefault();
        });

        // 3. Force scroll position to (0,0) if browser tries to shift
        window.addEventListener('scroll', function() {
            if (window.scrollX !== 0 || window.scrollY !== 0) {
                window.scrollTo(0, 0);
            }
        });
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Telegram WebApp
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            
            try {
                // –†–∞—Å—à–∏—Ä—è–µ–º –Ω–∞ –≤—Å—é –≤—ã—Å–æ—Ç—É
                tg.expand();
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–µ—Ä—Å–∏—é –ø–µ—Ä–µ–¥ –∑–∞–ø—Ä–æ—Å–æ–º –ø–æ–ª–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞ (–Ω—É–∂–Ω–∞ –≤–µ—Ä—Å–∏—è >= 8.0)
                // –û–±–æ—Ä–∞—á–∏–≤–∞–µ–º –≤ try-catch, —á—Ç–æ–±—ã –æ—à–∏–±–∫–∞ –Ω–µ –ª–æ–º–∞–ª–∞ –∏–≥—Ä—É
                if (parseFloat(tg.version) >= 8.0 && tg.requestFullscreen) {
                    tg.requestFullscreen();
                }
                
                // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—ã–π —Å–≤–∞–π–ø
                if (tg.disableVerticalSwipes) {
                   tg.disableVerticalSwipes();
                }
            } catch (e) {
                console.log("Telegram API Error (ignoring):", e);
            }
        }
        
        // Disable context menu (right click / long press menu) globally
        document.addEventListener('contextmenu', function(event) {
            event.preventDefault();
            return false;
        });

        // Double protection against drag start
        document.addEventListener('dragstart', function(event) {
            event.preventDefault();
            return false;
        });
        
        // --- GLOBAL HANDLERS (Hardcoded) ---
        
        window.forceSubsClick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            console.log("!!! FORCE SUBS CLICKED !!!");
            
            // Visual feedback
            const btn = document.getElementById('btn-subs-action');
            if (btn) {
                btn.style.transform = "scale(0.95)";
                setTimeout(() => btn.style.transform = "scale(1)", 150);
            }
            
            // Logic
            if (typeof window.performSubstitutions === 'function') {
                window.performSubstitutions();
            } else {
                console.error("performSubstitutions not found!");
                alert("–û—à–∏–±–∫–∞: —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–º–µ–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");
            }
        };

        window.forceStartClick = function(e) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            console.log("!!! FORCE START CLICKED !!!");
            
            // Visual feedback
            const btn = document.getElementById('btn-start-action');
            if (btn) {
                btn.style.transform = "scale(0.95)";
                setTimeout(() => btn.style.transform = "scale(1)", 150);
            }
            
            // Logic
            if (typeof startMatch === 'function') {
                startMatch();
            } else {
                console.error("startMatch not found!");
                alert("–û—à–∏–±–∫–∞: —Ñ—É–Ω–∫—Ü–∏—è –Ω–∞—á–∞–ª–∞ –º–∞—Ç—á–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞");
            }
        };
        
        // Helper function to clean up visual artifacts
        function cleanUpVisualArtifacts() {
            // Remove all temporary animation elements
            const artifacts = document.querySelectorAll('.card-flying, .ghost-card, .flying-resurrection-card, .card-fly-in');
            artifacts.forEach(el => el.remove());
            console.log("Visual artifacts cleaned up.");
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π
        function preloadAllImages() {
            console.log("–ù–∞—á–∏–Ω–∞—é –ø—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫—É –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π...");
            const allImages = [];
            
            // Helper to add image
            const addImg = (src) => {
                if (!src) return;
                const img = new Image();
                img.src = src;
                allImages.push(img);
            };

            // Iterate over all teams in database
            Object.values(allGameData).forEach(teamCards => {
                if (Array.isArray(teamCards)) {
                    teamCards.forEach(card => {
                        if (card.img) addImg(card.img);
                        if (card.miniImg) addImg(card.miniImg);
                    });
                }
            });
            
            // Also preload UI assets
            addImg('assets/spartak_card_back.jpg');
            addImg('assets/spartak_card_back_enemy.jpg');
            addImg('assets/footballstars_back.jpg');
            addImg('assets/spartak_stack.jpg');
            addImg('assets/footballstars_stack.jpg');
            addImg('assets/spartak_graveyard.jpg');
            addImg('assets/footballstars_graveyard.jpg');
            
            console.log(`–ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–∞–≥—Ä—É–∂–µ–Ω–æ ${allImages.length} –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.`);
        }

        // Call on startup
        window.addEventListener('load', preloadAllImages);
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
        let playerTeamKey = 'allSpartakCards'; // –ö–æ–º–∞–Ω–¥–∞ –∏–≥—Ä–æ–∫–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        let enemyTeamKey = 'allFootballStarsCards'; // –ö–æ–º–∞–Ω–¥–∞ –±–æ—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        
        // –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ª–æ–≥–æ—Ç–∏–ø–æ–≤ –∫–æ–º–∞–Ω–¥
        const teamLogos = {
            'allSpartakCards': {
                light: 'assets/logos/spartak_logo.png',
                dark: 'assets/logos/spartak_logo.png'
            },
            'allFootballStarsCards': {
                light: 'assets/logos/footballstars_black.png',
                dark: 'assets/logos/footballstars_white.png'
            },
            'allRPLCards': {
                light: 'assets/logos/rpl.png',
                dark: 'assets/logos/rpl.png'
            }
        };
        
        const teamAssets = {
            'allSpartakCards': {
                cardBack: 'assets/spartak_card_back.jpg',       // –†—É–±–∞—à–∫–∞ –∫–∞—Ä—Ç—ã (–¥–ª—è —Ä—É–∫–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
                deck: 'assets/spartak_stack.jpg',               // –ö–∞—Ä—Ç–∏–Ω–∫–∞ –∫–æ–ª–æ–¥—ã
                graveyard: 'assets/spartak_graveyard.jpg'       // –ö–∞—Ä—Ç–∏–Ω–∫–∞ –æ—Ç–±–æ—è
            },
            'allFootballStarsCards': {
                cardBack: 'assets/footballstars_back.jpg', 
                deck: 'assets/footballstars_stack.jpg',
                graveyard: 'assets/footballstars_graveyard.jpg'
            },
            'allRPLCards': {
                cardBack: 'assets/rpl_back.jpg',
                deck: 'assets/rpl_stack.jpg',
                graveyard: 'assets/rpl_graveyard.jpg'
            }
        };
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç—Ä–µ–Ω–µ—Ä–æ–≤ (–æ–¥–∏–Ω –æ–±—ä–µ–∫—Ç –Ω–∞ –≤–µ—Å—å –º–∞—Ç—á)
        let currentPlayerCoach = null; // –¢–µ–∫—É—â–∏–π –æ–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –∏–≥—Ä–æ–∫–∞
        let currentEnemyCoach = null;  // –¢–µ–∫—É—â–∏–π –æ–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –±–æ—Ç–∞
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∫–æ–ª–æ–¥ (–±—É–¥—É—Ç –∑–∞–ø–æ–ª–Ω–µ–Ω—ã —Ñ—É–Ω–∫—Ü–∏–µ–π startGame)
        let myCards = [];
        let enemyCards = [];
        let myDeck = []; // –ö–æ–ª–æ–¥–∞ –∏–≥—Ä–æ–∫–∞ - –∫–∞—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –æ—Å—Ç–∞–ª–∏—Å—å –¥–ª—è –¥–æ–±–æ—Ä–∞
        let enemyDrawPile = []; // NEW: –ö–æ–ª–æ–¥–∞ –±–æ—Ç–∞ (Data Array)
        let isSpyDrawing = false; // –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∞–≤—Ç–æ-–¥–æ–±–æ—Ä–∞ –≤–æ –≤—Ä–µ–º—è –¥–µ–π—Å—Ç–≤–∏—è —à–ø–∏–æ–Ω–∞
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –æ–±—â–µ–≥–æ —Å—á–µ—Ç–∞
        let totalScore = 0;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —Å—á–µ—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        let enemyScore = 0;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã "Best of 3"
        let currentRound = 1; // –¢–µ–∫—É—â–∏–π —Ä–∞—É–Ω–¥ (1, 2 –∏–ª–∏ 3)
        let playerMatchWins = 0; // –ü–æ–±–µ–¥—ã –∏–≥—Ä–æ–∫–∞ –≤ –º–∞—Ç—á–µ
        let enemyMatchWins = 0; // –ü–æ–±–µ–¥—ã –±–æ—Ç–∞ –≤ –º–∞—Ç—á–µ
        let matchStarter = null; // 'player' –∏–ª–∏ 'enemy' - –∫—Ç–æ –Ω–∞—á–∞–ª –º–∞—Ç—á (–†–∞—É–Ω–¥ 1)
        let isProcessingRoundEnd = false; // –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥–≤–æ–π–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è endRound()
        let isAbilityAnimating = false; // –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞ –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–Ω–µ—Ä–∞
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ Dummy (Decoy)
        let isDummyTargeting = false;
        let isMedicResurrecting = false;
        let medicSelectionData = null;
        let selectedDummyCard = null; // { cardElement, cardData }
        
        // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –æ –∫–∞—Ä—Ç–∞—Ö –Ω–∞ –ø–æ–ª–µ
        let playerCardsOnField = []; // [{cardData, rowId}]
        let enemyCardsOnField = []; // [{cardData, rowId}]
        
        // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–∞—Ä—Ç –≤ —Å–ª–æ—Ç–∞—Ö "–¢–∞–∫—Ç–∏–∫–∞" (support –∫–∞—Ä—Ç—ã)
        let playerTacticsCards = []; // [{cardData, rowId}] - –∫–∞—Ä—Ç—ã —Å ability: 'support'
        let enemyTacticsCards = []; // [{cardData, rowId}]
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ —Ö–æ–¥–æ–≤
        let isPlayerTurn = true;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–∞—Å–∞
        let playerPassed = false;
        let enemyPassed = false;
        
        // –°—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
        let movesCount = 0;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è –∫–∞—Ä—Ç—ã, –æ–∂–∏–¥–∞—é—â–µ–π –≤—ã–±–æ—Ä–∞ —Ä—è–¥–∞ (–¥–ª—è –∫–∞—Ä—Ç —Å position === 'any' –∏–ª–∏ ability === 'support')
        let selectedCardForRow = null; // {cardElement, cardData}
        
        // –û–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        // –û–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –ö–∞—Ä—Å–µ–¥–æ
        const carcedoCoach = {
            id: 'coach_carcedo',
            name: '–•—É–∞–Ω –ö–∞—Ä–ª–æ—Å –ö–∞—Ä—Å–µ–¥–æ',
            img: 'images/spartak/full/carcedo.jpg',
            miniImg: 'images/spartak/mini/carcedo.jpg',
            power: 0,
            isUsed: false,
            ability: 'carcedo'
        };
        
        // –û–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –ö–ª–æ–ø–ø–∞
        const kloppCoach = {
            id: 'coach_klopp',
            name: '–Æ—Ä–≥–µ–Ω –ö–ª–æ–ø–ø',
            img: 'images/footballstars/full/klopp.jpg',
            miniImg: 'images/footballstars/mini/klopp.jpg',
            power: 0,
            isUsed: false,
            ability: 'klopp'
        };
        
        // –û–±—ä–µ–∫—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ –ß–µ–ª–µ—Å—Ç–∏–Ω–∏
        const celestiniCoach = {
            id: 'coach_rpl',
            name: '–§–∞–±–∏–æ –ß–µ–ª–µ—Å—Ç–∏–Ω–∏',
            img: 'images/rpl/full/celestini.jpg',
            miniImg: 'images/rpl/mini/celestini.jpg',
            power: 0,
            isUsed: false,
            ability: 'celestini'
        };
        
        // –§–ª–∞–≥–∏ –¥–ª—è –º–µ—Ö–∞–Ω–∏–∫–∏ —Ç—Ä–µ–Ω–µ—Ä–æ–≤
        let enemyCoachActive = false; // –§–ª–∞–≥, —á—Ç–æ —Ç—Ä–µ–Ω–µ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª —É–º–µ–Ω–∏–µ
        let enemyCoachUsed = false; // –§–ª–∞–≥, —á—Ç–æ —Ç—Ä–µ–Ω–µ—Ä —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –≤ –º–∞—Ç—á–µ
        let enemyCoachBonusScore = 0; // –¢–µ–∫—É—â–∏–π –±–æ–Ω—É—Å –∫ –æ—á–∫–∞–º –æ—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
        let lastKloppVictims = []; // –ú–∞—Å—Å–∏–≤ –∂–µ—Ä—Ç–≤ –ö–ª–æ–ø–ø–∞: [{ cardData, rowId, owner: 'player'|'enemy' }]
        let lastCelestiniBuffs = []; // [{ cardData, amount }] - Tracks buffs to be reverted
        let playerJustUsedCoach = false; // –§–ª–∞–≥, —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞ –±—ã–ª —Ö–æ–¥–æ–º —Ç—Ä–µ–Ω–µ—Ä–∞
        let kloppOpportunityMissed = false; // –§–ª–∞–≥, —á—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ö–∞—Ä—Å–µ–¥–æ –±—ã–ª–∞ —É–ø—É—â–µ–Ω–∞
        
        // –¢–∞–π–º–µ—Ä –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        let notificationTimer = null;
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –º–µ—Ö–∞–Ω–∏–∫–∏ –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –∫–∞—Ä—Ç
        let inspectionTimer = null;
        let isInspecting = false; // –§–ª–∞–≥, —á—Ç–æ —Å–µ–π—á–∞—Å –∏–¥–µ—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä
        let ignoreNextClick = false; // –§–ª–∞–≥, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å —Ä–∞–∑—ã–≥—Ä—ã–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –ø–æ—Å–ª–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
        let currentInspectedSrc = null; // –¢–µ–∫—É—â–∏–π src –ø—Ä–æ—Å–º–∞—Ç—Ä–∏–≤–∞–µ–º–æ–π –∫–∞—Ä—Ç—ã
        
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞
        const gameOverlay = document.getElementById('gameOverlay');
        const resultTitle = document.getElementById('resultTitle');
        const resultScore = document.getElementById('resultScore');
        const restartButton = document.getElementById('restartButton');
        
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–≥–æ —Ç–∞–±–ª–æ
        const mainScoreboard = document.getElementById('main-scoreboard');
        const currentScorePlayer = document.getElementById('current-score-player');
        const currentScoreEnemy = document.getElementById('current-score-enemy');
        const matchScore = document.getElementById('match-score');
        
        // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –∫–æ–ª–æ–¥ –∏ –æ—Ç–±–æ–µ–≤
        const playerDeck = document.getElementById('playerDeck');
        const playerDeckCounter = document.getElementById('playerDeckCounter');
        const playerGraveyard = document.getElementById('playerGraveyard');
        const enemyDeck = document.getElementById('enemyDeck');
        const enemyDeckCounter = document.getElementById('enemyDeckCounter');
        const enemyGraveyard = document.getElementById('enemyGraveyard');
        
        // –ú–∞—Å—Å–∏–≤—ã –¥–ª—è –æ—Ç–±–æ–µ–≤
        let playerGraveyardCards = [];
        let enemyGraveyardCards = [];
        
        // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –∫–∞—Ä—Ç –∏ —Ä—è–¥—ã –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        const cardsContainer = document.getElementById('cardsContainer');
        const attackRow = document.getElementById('attackRow');
        const midfieldRow = document.getElementById('midfieldRow');
        const defenseRow = document.getElementById('defenseRow');
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ—Ç—ã "–¢–∞–∫—Ç–∏–∫–∞" –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä—è–¥–∞
        const attackTacticsSlot = document.getElementById('attackTacticsSlot');
        const midfieldTacticsSlot = document.getElementById('midfieldTacticsSlot');
        const defenseTacticsSlot = document.getElementById('defenseTacticsSlot');
        
        // –ü–æ–ª—É—á–∞–µ–º —Ä—è–¥—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        const enemyAttackRow = document.getElementById('enemyAttackRow');
        const enemyMidfieldRow = document.getElementById('enemyMidfieldRow');
        const enemyDefenseRow = document.getElementById('enemyDefenseRow');
        const enemyCardsContainer = document.getElementById('enemyCardsContainer');
        const opponentHand = document.getElementById('opponent-hand');
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ—Ç—ã "–¢–∞–∫—Ç–∏–∫–∞" –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Ä—è–¥–∞
        const enemyAttackTacticsSlot = document.getElementById('enemyAttackTacticsSlot');
        const enemyMidfieldTacticsSlot = document.getElementById('enemyMidfieldTacticsSlot');
        const enemyDefenseTacticsSlot = document.getElementById('enemyDefenseTacticsSlot');
        
        // –ü–æ–ª—É—á–∞–µ–º —Å–ª–æ—Ç—ã —Ç—Ä–µ–Ω–µ—Ä–æ–≤
        const playerDefenseRightSlot = document.getElementById('playerDefenseRightSlot');
        const enemyDefenseRightSlot = document.getElementById('enemyDefenseRightSlot');
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ä—Ç—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π
        function createEnemyCardBack(cardData) {
            const cardBack = document.createElement('div');
            cardBack.className = 'enemy-card-back';
            cardBack.setAttribute('data-enemy-card-id', cardData.id);
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
            const enemyAssets = teamAssets[enemyTeamKey];
            if (enemyAssets && enemyAssets.cardBack) {
                cardBack.style.backgroundImage = `url('${enemyAssets.cardBack}')`;
                cardBack.style.backgroundSize = 'cover';
                cardBack.style.backgroundRepeat = 'no-repeat';
                cardBack.style.backgroundPosition = 'center';
            }
            
            return cardBack;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –º–∞—Å—Å–∏–≤–∞ (–∞–ª–≥–æ—Ä–∏—Ç–º –§–∏—à–µ—Ä–∞-–ô–µ—Ç—Å–∞)
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ –∏–≥—Ä–æ–∫–∞
        function getPlayerDeckCount() {
            try {
                // –í–ê–ñ–ù–û: –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ myDeck, –∞ –Ω–µ –ø–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∏–∑ allCards
                return myDeck.length;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–¥—Å—á–µ—Ç–µ –∫–æ–ª–æ–¥—ã –∏–≥—Ä–æ–∫–∞:', error);
                return 0;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å—á–µ—Ç–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        function getEnemyDeckCount() {
            // Return actual length of the AI's draw pile
            return enemyDrawPile ? enemyDrawPile.length : 0;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–∞ –∫–æ–ª–æ–¥—ã –∏–≥—Ä–æ–∫–∞
        function updatePlayerDeckCounter() {
            if (playerDeckCounter) {
                const count = getPlayerDeckCount();
                playerDeckCounter.textContent = count;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–∞ –∫–æ–ª–æ–¥—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        function updateEnemyDeckCounter() {
            if (enemyDeckCounter) {
                const count = getEnemyDeckCount();
                enemyDeckCounter.textContent = count;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã –∏–≥—Ä–æ–∫–∞ (–¥–ª—è —à–ø–∏–æ–Ω–æ–≤)
        // –í–ê–ñ–ù–û: –ë–µ—Ä–µ—Ç –∫–∞—Ä—Ç—ã —Ç–æ–ª—å–∫–æ –∏–∑ –º–∞—Å—Å–∏–≤–∞ myDeck, –∏—Å–ø–æ–ª—å–∑—É—è .pop()
        // –í–ê–ñ–ù–û: –ù–ï –∏—Å–ø–æ–ª—å–∑—É–µ—Ç allCards - —Ç–æ–ª—å–∫–æ myDeck!
        function drawCardsFromPlayerDeck(count) {
            try {
                console.log('DEBUG drawCardsFromPlayerDeck: –ö–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ –ø–µ—Ä–µ–¥ –¥–æ–±–æ—Ä–æ–º:', myDeck.length);
                console.log('DEBUG drawCardsFromPlayerDeck: –ó–∞–ø—Ä–æ—à–µ–Ω–æ –∫–∞—Ä—Ç:', count);
                
                // –í–ê–ñ–ù–û: –ë–µ—Ä–µ–º –∫–∞—Ä—Ç—ã –¢–û–õ–¨–ö–û –∏–∑ myDeck, –∏—Å–ø–æ–ª—å–∑—É—è .pop()
                // –ï—Å–ª–∏ myDeck –ø—É—Å—Ç, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤
                if (myDeck.length === 0) {
                    console.log('DEBUG drawCardsFromPlayerDeck: –ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π –º–∞—Å—Å–∏–≤');
                    return [];
                }
                
                // –ë–µ—Ä–µ–º –∫–∞—Ä—Ç—ã –∏–∑ –∫–æ–ª–æ–¥—ã –∏—Å–ø–æ–ª—å–∑—É—è .pop() (—Å –∫–æ–Ω—Ü–∞ –º–∞—Å—Å–∏–≤–∞)
                const cardsToDraw = Math.min(count, myDeck.length);
                const drawnCards = [];
                
                for (let i = 0; i < cardsToDraw; i++) {
                    const card = myDeck.pop();
                    if (card) {
                        drawnCards.push({ ...card, used: false });
                    }
                }
                
                console.log('DEBUG drawCardsFromPlayerDeck: –ü–æ–ª—É—á–µ–Ω–æ –∫–∞—Ä—Ç:', drawnCards.length, '–û—Å—Ç–∞–ª–æ—Å—å –≤ –∫–æ–ª–æ–¥–µ:', myDeck.length);
                
                return drawnCards;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã –∏–≥—Ä–æ–∫–∞:', error);
                return [];
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ä—Ç –∏–∑ –æ—Å—Ç–∞–≤—à–µ–π—Å—è –∫–æ–ª–æ–¥—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (–¥–ª—è —à–ø–∏–æ–Ω–æ–≤ –±–æ—Ç–∞)
        function drawCardsFromEnemyDeck(count) {
            try {
                console.log('DEBUG drawCardsFromEnemyDeck: AI Deck size:', enemyDrawPile.length);
                
                if (enemyDrawPile.length === 0) {
                    return [];
                }
                
                const drawnCards = [];
                // Draw from the end (pop) like a real stack
                for (let i = 0; i < count; i++) {
                    if (enemyDrawPile.length > 0) {
                        const card = enemyDrawPile.pop();
                        drawnCards.push(card);
                    }
                }
                
                console.log('AI drew cards:', drawnCards.length);
                return drawnCards;
            } catch (error) {
                console.error('Error drawing enemy cards:', error);
                return [];
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã –≤ —Ä—É–∫—É
        function animateCardsFromDeck(cards, deckElement, callback) {
            if (!cards || cards.length === 0 || !deckElement) {
                if (callback) callback();
                return;
            }
            
            try {
                const deckRect = deckElement.getBoundingClientRect();
                const cardsContainerRect = cardsContainer.getBoundingClientRect();
                
                // –ê–Ω–∏–º–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –∫–∞—Ä—Ç—É —Å –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
                cards.forEach((cardData, index) => {
                    setTimeout(() => {
                        // –°–æ–∑–¥–∞–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É
                        const flyingCard = document.createElement('div');
                        flyingCard.className = 'card-flying';
                        flyingCard.style.position = 'fixed';
                        flyingCard.style.left = (deckRect.left + deckRect.width / 2) + 'px';
                        flyingCard.style.top = (deckRect.top + deckRect.height / 2) + 'px';
                        flyingCard.style.width = '90px';
                        flyingCard.style.height = '126px';
                        flyingCard.style.zIndex = '10000';
                        flyingCard.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                        flyingCard.style.borderRadius = '8px';
                        flyingCard.style.overflow = 'hidden';
                        flyingCard.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.6)';
                        
                        const cardImage = document.createElement('img');
                        cardImage.src = cardData.img;
                        cardImage.alt = cardData.name || `–ö–∞—Ä—Ç–∞ ${cardData.id}`;
                        cardImage.style.width = '100%';
                        cardImage.style.height = '100%';
                        cardImage.style.objectFit = 'cover';
                        cardImage.style.display = 'block';
                        
                        flyingCard.appendChild(cardImage);
                        document.body.appendChild(flyingCard);
                        
                        // Find the target card element in the hand using data-card-id
                        const targetCardElement = document.querySelector('.cards-container [data-card-id="' + cardData.id + '"]');
                        
                        // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–ª–µ—Ç–∞ –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É –∫–∞—Ä—Ç
                        setTimeout(() => {
                            let targetX, targetY, targetWidth, targetHeight;
                            
                            // Safety Check: If target card element exists, use its exact position
                            if (targetCardElement) {
                                // Hide the real card temporarily
                                targetCardElement.style.opacity = '0';
                                
                                // Get exact coordinates from the target element
                                const targetRect = targetCardElement.getBoundingClientRect();
                                targetX = targetRect.left + targetRect.width / 2;
                                targetY = targetRect.top + targetRect.height / 2;
                                targetWidth = targetRect.width;
                                targetHeight = targetRect.height;
                            } else {
                                // Fallback: Use old hardcoded logic if element not found
                                targetX = cardsContainerRect.left + (index * 100) + 50;
                                targetY = cardsContainerRect.bottom - 70;
                                targetWidth = 90;
                                targetHeight = 126;
                            }
                            
                            // Center the flying card on the target position
                            flyingCard.style.left = (targetX - targetWidth / 2) + 'px';
                            flyingCard.style.top = (targetY - targetHeight / 2) + 'px';
                            flyingCard.style.width = targetWidth + 'px';
                            flyingCard.style.height = targetHeight + 'px';
                            
                            // –£–¥–∞–ª—è–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                            setTimeout(() => {
                                flyingCard.remove();
                                
                                // Show the real card if it was hidden
                                if (targetCardElement) {
                                    targetCardElement.style.opacity = '1';
                                }
                                
                                // –í—ã–∑—ã–≤–∞–µ–º callback –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–∞—Ä—Ç—ã
                                if (index === cards.length - 1 && callback) {
                                    callback();
                                }
                            }, 600);
                        }, 10);
                    }, index * 150); // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∫–∞—Ä—Ç–∞–º–∏
                });
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã:', error);
                if (callback) callback();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã –±–æ—Ç–∞ –≤ —Ä—É–∫—É –±–æ—Ç–∞ (–ª–µ—Ç—è—Ç –≤–≤–µ—Ä—Ö)
        function animateCardsFromEnemyDeck(cards, deckElement, callback) {
            if (!cards || cards.length === 0 || !deckElement) {
                if (callback) callback();
                return;
            }
            
            try {
                const deckRect = deckElement.getBoundingClientRect();
                const enemyCardsContainerRect = enemyCardsContainer.getBoundingClientRect();
                
                // Get the correct card back for the enemy team
                const enemyAssets = teamAssets[enemyTeamKey];
                const cardBackUrl = (enemyAssets && enemyAssets.cardBack) ? enemyAssets.cardBack : 'assets/spartak_card_back.jpg';

                // –ê–Ω–∏–º–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –∫–∞—Ä—Ç—É —Å –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–æ–π
                cards.forEach((cardData, index) => {
                    setTimeout(() => {
                        // –°–æ–∑–¥–∞–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É (–†–£–ë–ê–®–ö–û–ô)
                        const flyingCard = document.createElement('div');
                        flyingCard.className = 'card-flying';
                        flyingCard.style.position = 'fixed';
                        flyingCard.style.left = (deckRect.left + deckRect.width / 2) + 'px';
                        flyingCard.style.top = (deckRect.top + deckRect.height / 2) + 'px';
                        flyingCard.style.width = '90px';
                        flyingCard.style.height = '126px';
                        flyingCard.style.zIndex = '10000';
                        flyingCard.style.transition = 'all 0.6s cubic-bezier(0.4, 0, 0.2, 1)';
                        flyingCard.style.borderRadius = '8px';
                        flyingCard.style.overflow = 'hidden';
                        flyingCard.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.6)';
                        
                        // Apply Card Back Texture
                        flyingCard.style.backgroundImage = `url('${cardBackUrl}')`;
                        flyingCard.style.backgroundSize = 'cover';
                        flyingCard.style.backgroundRepeat = 'no-repeat';
                        flyingCard.style.backgroundPosition = 'center';
                        flyingCard.style.border = '1px solid rgba(255, 255, 255, 0.3)';
                        
                        document.body.appendChild(flyingCard);
                        
                        // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–ª–µ—Ç–∞ –∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—É –∫–∞—Ä—Ç –±–æ—Ç–∞ (–≤–≤–µ—Ä—Ö)
                        setTimeout(() => {
                            // –õ–µ—Ç–∏–º –≤ —Å—Ç–æ—Ä–æ–Ω—É –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –±–æ—Ç–∞
                            const targetX = enemyCardsContainerRect.left + (index * 40) + 20; // Slight overlap offset
                            const targetY = enemyCardsContainerRect.top; // Fly to the top container
                            
                            flyingCard.style.left = targetX + 'px';
                            flyingCard.style.top = targetY + 'px';
                            flyingCard.style.width = '40px'; // Shrink to match hand size
                            flyingCard.style.height = '56px';
                            
                            // –£–¥–∞–ª—è–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                            setTimeout(() => {
                                flyingCard.remove();
                                
                                // –í—ã–∑—ã–≤–∞–µ–º callback –ø–æ—Å–ª–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π –∫–∞—Ä—Ç—ã
                                if (index === cards.length - 1 && callback) {
                                    callback();
                                }
                            }, 600);
                        }, 10);
                    }, index * 150); // –ó–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∫–∞—Ä—Ç–∞–º–∏
                });
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã –±–æ—Ç–∞:', error);
                if (callback) callback();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∫–∞—Ä—Ç—ã –≤ —Ä—É–∫–µ
        function createCardInHand(cardData) {
            const cardElement = document.createElement('div');
            cardElement.className = 'card';
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å hero, –µ—Å–ª–∏ –∫–∞—Ä—Ç–∞ —è–≤–ª—è–µ—Ç—Å—è –≥–µ—Ä–æ–µ–º
            if (cardData.isHero || cardData.cardtype === 'hero') {
                cardElement.classList.add('hero');
            }
            
            cardElement.setAttribute('data-card-id', cardData.id);
            cardElement.setAttribute('data-position', cardData.position);
            
            const cardImage = document.createElement('img');
            cardImage.src = cardData.img;
            cardImage.alt = cardData.name || `–ö–∞—Ä—Ç–∞ ${cardData.id}`;
            
            cardElement.appendChild(cardImage);
            
            // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã
            cardElement.addEventListener('dragstart', (e) => e.preventDefault());
            cardImage.addEventListener('dragstart', (e) => e.preventDefault());
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –∫–∞—Ä—Ç—ã (–¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ)
            addInspectionEvents(cardElement, cardData.img);
            
            // –ù–ï –¥–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–¥–µ—Å—å - —ç—Ç–æ –¥–µ–ª–∞–µ—Ç renderPlayerHand
            // cardsContainer.appendChild(cardElement);
            
            return cardElement;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–∞—Ä—Ç –∏–≥—Ä–æ–∫–∞ –≤ —Ä—É–∫–µ
        function renderPlayerHand() {
            // –û—á–∏—â–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
            cardsContainer.innerHTML = '';
            
            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—ã –≤ —Ä—É–∫–µ
            myCards.forEach(cardData => {
                const cardElement = createCardInHand(cardData);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
                cardsContainer.appendChild(cardElement);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞
                cardElement.addEventListener('click', function() {
                    handleCardClick(this, cardData);
                });
            });
            
            console.log('–†—É–∫–∞ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω–∞. –ö–∞—Ä—Ç –≤ —Ä—É–∫–µ:', myCards.length);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º layout –ø–æ—Å–ª–µ –æ—Ç—Ä–∏—Å–æ–≤–∫–∏
            updateHandLayout();
            
            // –ê–í–¢–û-–§–ò–ù–ê–õ: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã, –µ—Å–ª–∏ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–µ—Ç –∫–∞—Ä—Ç
            if (myCards.length === 0 && enemyCards.length === 0) {
                console.log('–ê–í–¢–û-–§–ò–ù–ê–õ: –ö–∞—Ä—Ç –Ω–µ—Ç —É –æ–±–æ–∏—Ö');
                endRound();
            }
        }
        
        function updateHandLayout() {
            const container = document.getElementById('cardsContainer');
            if (!container) return;
            
            const cards = Array.from(container.querySelectorAll('.card'));
            const cardCount = cards.length;
            if (cardCount === 0) return;

            // Constants
            const isMobile = window.innerWidth <= 480;
            const overlapAmount = isMobile ? 20 : 32;

            // Apply Margins & Z-Index
            cards.forEach((card, index) => {
                card.style.zIndex = index.toString();
                card.style.transform = ''; 
                
                // Normal negative margin for overlap
                if (index < cardCount - 1) {
                    card.style.marginRight = `-${overlapAmount}px`;
                } else {
                    // Last card needs no margin
                    card.style.marginRight = '0px';
                }
            });
            
            // Recalculate total width for padding logic
            const cardWidth = isMobile ? 87 : 125;
            const totalContentWidth = cardWidth + ((cardCount - 1) * (cardWidth - overlapAmount));
            const screenWidth = container.clientWidth;
            
            if (totalContentWidth < screenWidth) {
                const emptySpace = screenWidth - totalContentWidth;
                const dynamicPadding = Math.max(20, emptySpace / 2);
                
                // USE SETPROPERTY WITH 'IMPORTANT' TO OVERRIDE CSS
                container.style.setProperty('padding-left', `${dynamicPadding}px`, 'important');
                container.style.setProperty('padding-right', `${dynamicPadding}px`, 'important');
            } else {
                // Reset to default scrolling padding
                container.style.setProperty('padding-left', '20px', 'important');
                container.style.setProperty('padding-right', '60px', 'important'); // Extra space at end
            }
            
            // Apply fish-eye effect after layout update
            updateFishEyeEffect();
        }

        // –í–∞–∂–Ω–æ: –∑–∞–ø—É—Å–∫–∞–µ–º –ø–µ—Ä–µ—Å—á–µ—Ç –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ä–∞–∑–º–µ—Ä–∞ –æ–∫–Ω–∞
        window.addEventListener('resize', updateHandLayout);
        
        // --- FISH-EYE EFFECT ---
        // Scales cards based on their distance from the center of the screen.
        function updateFishEyeEffect() {
            const container = document.getElementById('cardsContainer');
            if (!container) return;
            const cards = Array.from(container.querySelectorAll('.card'));
            if (cards.length === 0) return;

            // 1. Find Center of Screen/Container
            const containerRect = container.getBoundingClientRect();
            const centerX = containerRect.left + containerRect.width / 2;

            // Settings for the effect
            const maxScale = 1.12;  // Scale at dead center (112%)
            const minScale = 0.95;  // Scale at edges (95%)
            const effectRadius = window.innerWidth * 0.6; // Area of effect (60% of screen width)

            cards.forEach(card => {
                // 2. Find Center of current Card
                const cardRect = card.getBoundingClientRect();
                const cardCenterX = cardRect.left + cardRect.width / 2;

                // 3. Calculate absolute distance from center
                const distance = Math.abs(centerX - cardCenterX);

                let scale = minScale;
                // Apply effect if within radius
                if (distance < effectRadius) {
                    // Calculate ratio (0 = center, 1 = edge of radius)
                    const ratio = distance / effectRadius;
                    
                    // Smoother cosine interpolation for a "hump" shape effect
                    // cos(0) = 1 (center), cos(pi/2) = 0 (edge)
                    const interpolation = Math.cos(ratio * Math.PI / 2);
                    
                    // Apply interpolated scale
                    scale = minScale + (maxScale - minScale) * interpolation;
                }

                // 4. Apply transform (ensure we don't overwrite existing layout transforms if any)
                // We use 'center bottom' origin so they grow upwards
                card.style.transformOrigin = 'center bottom';
                card.style.transform = `scale(${scale.toFixed(3)})`;
            });
        }

        // --- ULTIMATE MANUAL SCROLL ENGINE (Updated) ---
        function initUltimateScroll() {
            const slider = document.getElementById('cardsContainer');
            if (!slider) return;

            let isDown = false;
            let startX;
            let scrollLeft;
            let velX = 0; // Velocity for momentum
            let momentumID;

            // Stop momentum on interaction
            const stopMomentum = () => cancelAnimationFrame(momentumID);

            // --- TOUCH & MOUSE HANDLERS ---
            
            const start = (e) => {
                stopMomentum();
                isDown = true;
                slider.classList.add('active');
                // Get X for mouse or first touch
                const pageX = e.touches ? e.touches[0].pageX : e.pageX;
                startX = pageX - slider.offsetLeft;
                scrollLeft = slider.scrollLeft;
            };

            const end = () => {
                isDown = false;
                slider.classList.remove('active');
                // Start Momentum Loop
                requestAnimationFrame(momentumLoop);
            };

            const move = (e) => {
                if (!isDown) return;
                if (e.cancelable) e.preventDefault(); 
                
                const pageX = e.touches ? e.touches[0].pageX : e.pageX;
                const x = pageX - slider.offsetLeft;
                
                // CHANGED: Reduced multiplier from 1.5 to 0.85 for slower scroll
                const walk = (x - startX) * 0.85; 
                
                const prevScroll = slider.scrollLeft;
                slider.scrollLeft = scrollLeft - walk;
                velX = slider.scrollLeft - prevScroll;

                // NEW: Update Fish-Eye immediately while dragging
                updateFishEyeEffect();
            };

            // Momentum Loop
            const momentumLoop = () => {
                if (!isDown && Math.abs(velX) > 0.5) {
                    slider.scrollLeft += velX;
                    velX *= 0.95; // Friction
                    
                    // NEW: Update Fish-Eye during momentum
                    updateFishEyeEffect();
                    
                    momentumID = requestAnimationFrame(momentumLoop);
                } else if (!isDown) {
                    // Ensure one final update when momentum stops
                    updateFishEyeEffect();
                }
            };

            // --- LISTENERS ---
            // Mouse
            slider.addEventListener('mousedown', start);
            slider.addEventListener('mouseleave', end);
            slider.addEventListener('mouseup', end);
            slider.addEventListener('mousemove', move);

            // Touch (Passive: false IS REQUIRED for preventDefault to work)
            slider.addEventListener('touchstart', start, { passive: false });
            slider.addEventListener('touchend', end);
            slider.addEventListener('touchcancel', end);
            slider.addEventListener('touchmove', move, { passive: false });
            
            slider.addEventListener('wheel', (e) => {
                if (e.deltaY !== 0) {
                    slider.scrollLeft += e.deltaY;
                    e.preventDefault();
                    // NEW: Update Fish-Eye on wheel scroll
                    updateFishEyeEffect();
                }
            }, { passive: false });

            // Initial Call to set initial state
            updateFishEyeEffect();
        }

        // Init on load
        window.addEventListener('load', initUltimateScroll);
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–∞—Ä—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π (—Å—Ç–∞—Ä–∞—è, –¥–ª—è enemyCardsContainer)
        function renderEnemyHand() {
            // –û—á–∏—â–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
            enemyCardsContainer.innerHTML = '';
            
            // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π
            enemyCards.forEach(cardData => {
                const cardBack = createEnemyCardBack(cardData);
                enemyCardsContainer.appendChild(cardBack);
            });
            
            // –ê–í–¢–û-–§–ò–ù–ê–õ: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã, –µ—Å–ª–∏ —É –æ–±–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤ –Ω–µ—Ç –∫–∞—Ä—Ç
            if (myCards.length === 0 && enemyCards.length === 0) {
                console.log('–ê–í–¢–û-–§–ò–ù–ê–õ: –ö–∞—Ä—Ç –Ω–µ—Ç —É –æ–±–æ–∏—Ö');
                endRound();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–∞—Ä—Ç—ã —Ç—Ä–µ–Ω–µ—Ä–∞
        function renderCoach(slotElement, coachData, isPlayer) {
            // –ï—Å–ª–∏ —Ç—Ä–µ–Ω–µ—Ä–∞ –Ω–µ—Ç - –æ—á–∏—â–∞–µ–º —Å–ª–æ—Ç –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É
            if (!coachData) {
                // –û—á–∏—â–∞–µ–º —Å–ª–æ—Ç
                slotElement.innerHTML = '';
                slotElement.classList.remove('has-coach');
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∑–∞–≥–ª—É—à–∫—É "Coach"
                const label = document.createElement('span');
                label.className = 'tactics-slot-label';
                label.style.opacity = '0.5';
                label.textContent = 'Coach';
                slotElement.appendChild(label);
                return;
            }
            
            // –û—á–∏—â–∞–µ–º —Å–ª–æ—Ç –æ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –∫–∞—Ä—Ç —Ç—Ä–µ–Ω–µ—Ä–∞
            const existingCoachCard = slotElement.querySelector('.coach-card');
            if (existingCoachCard) {
                existingCoachCard.remove();
            }
            
            // –û—á–∏—â–∞–µ–º —Å–ª–æ—Ç –æ—Ç —Ç–µ–∫—Å—Ç–æ–≤–æ–π –∑–∞–≥–ª—É—à–∫–∏
            const label = slotElement.querySelector('.tactics-slot-label');
            if (label) {
                label.style.display = 'none';
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å, —á—Ç–æ–±—ã —Å–∫—Ä—ã—Ç—å –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏–µ —Å–ª–æ—Ç–∞
            slotElement.classList.add('has-coach');
            
            // –°–æ–∑–¥–∞–µ–º DOM-—ç–ª–µ–º–µ–Ω—Ç –∫–∞—Ä—Ç—ã —Ç—Ä–µ–Ω–µ—Ä–∞
            const coachCard = document.createElement('div');
            coachCard.className = 'card-on-field coach-card';
            
            // FIX: If used, force the class and strip urgent animations immediately
            if (coachData.isUsed) {
                coachCard.classList.add('used');
                coachCard.classList.remove('coach-urgent'); // Safety removal
            }
            
            // –°–æ–∑–¥–∞–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç—Ä–µ–Ω–µ—Ä–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –º–∏–Ω–∏-–≤–µ—Ä—Å–∏—é, –µ—Å–ª–∏ –µ—Å—Ç—å)
            const coachImage = document.createElement('img');
            coachImage.src = coachData.miniImg || coachData.img;
            coachImage.alt = coachData.name || '–¢—Ä–µ–Ω–µ—Ä';

            coachCard.appendChild(coachImage);
            
            // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã —Ç—Ä–µ–Ω–µ—Ä–∞
            coachCard.addEventListener('dragstart', (e) => e.preventDefault());
            coachImage.addEventListener('dragstart', (e) => e.preventDefault());
            
            // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –∫–∞—Ä—Ç—ã —Ç—Ä–µ–Ω–µ—Ä–∞ (–¥–æ–ª–≥–æ–µ –Ω–∞–∂–∞—Ç–∏–µ)
            addInspectionEvents(coachCard, coachData.img);
            
            // –ï—Å–ª–∏ —ç—Ç–æ —Ç—Ä–µ–Ω–µ—Ä –∏–≥—Ä–æ–∫–∞, –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞
            if (isPlayer) {
                coachCard.addEventListener('click', function() {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –±—ã–ª –ª–∏ —ç—Ç–æ –ø—Ä–æ—Å–º–æ—Ç—Ä –∫–∞—Ä—Ç—ã
                    if (ignoreNextClick) {
                        console.log("–ö–ª–∏–∫ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –ø–æ—Å–ª–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞");
                        return;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞
                    if (!isPlayerTurn) {
                        return;
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –µ—â–µ –Ω–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞
                    if (coachData.isUsed) {
                        return;
                    }
                    
                    // –ê–∫—Ç–∏–≤–∏—Ä—É–µ–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å —Ç—Ä–µ–Ω–µ—Ä–∞
                    activateCoachAbility(coachData);
                    
                    // –ü–æ–º–µ—á–∞–µ–º –∫–∞—Ä—Ç—É –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—É—é –∏ —É–¥–∞–ª—è–µ–º urgent –∞–Ω–∏–º–∞—Ü–∏—é
                    coachCard.classList.add('used');
                    coachCard.classList.remove('coach-urgent'); // Remove pulse animation
                    coachData.isUsed = true;
                });
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ —Å–ª–æ—Ç
            slotElement.appendChild(coachCard);
        }
        
        // –§—É–Ω–∫—Ü–∏–∏ –¥–ª—è –º–µ—Ö–∞–Ω–∏–∫–∏ –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –∫–∞—Ä—Ç
        function handleInspectMove(e) {
            if (!isInspecting) {
                return;
            }
            
            // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º —Å–∫—Ä–æ–ª–ª –¥–ª—è touch —Å–æ–±—ã—Ç–∏–π
            if (e.touches && e.touches.length > 0) {
                e.preventDefault();
            }
            
            // –ü–æ–ª—É—á–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã (–º—ã—à—å –∏–ª–∏ –ø–µ—Ä–≤—ã–π –ø–∞–ª–µ—Ü)
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            
            // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
            // –í–∞–∂–Ω–æ: Overlay –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å pointer-events: none, —á—Ç–æ–±—ã –ª—É—á –ø—Ä–æ—à–µ–ª —Å–∫–≤–æ–∑—å –Ω–µ–≥–æ
            const elementUnderCursor = document.elementFromPoint(clientX, clientY);
            if (!elementUnderCursor) {
                return;
            }
            
            // –ò—â–µ–º –±–ª–∏–∂–∞–π—à—É—é –∫–∞—Ä—Ç—É
            // ADDED: .squad-card to the selector
            const card = elementUnderCursor.closest('.card, .coach-card, .card-on-field, .squad-card');
            if (!card) {
                return;
            }
            
            // –ü–æ–ª—É—á–∞–µ–º src –∫–∞—Ä—Ç–∏–Ω–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∫–∞—Ä—Ç—ã
            let imgSrc = '';
            if (card.classList.contains('card-on-field')) {
                // –î–ª—è –∫–∞—Ä—Ç –Ω–∞ –ø–æ–ª–µ –±–µ—Ä–µ–º –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞
                imgSrc = card.getAttribute('data-full-img');
            } else {
                // –î–ª—è –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ –∏ —Ç—Ä–µ–Ω–µ—Ä–æ–≤ –±–µ—Ä–µ–º –∏–∑ img —ç–ª–µ–º–µ–Ω—Ç–∞
                const img = card.querySelector('img');
                imgSrc = img ? img.src : '';
            }
            
            if (!imgSrc) {
                return;
            }
            
            // –ü–æ–ª—É—á–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –æ–≤–µ—Ä–ª–µ–µ
            const inspectedImg = document.getElementById('inspected-card-image');
            if (!inspectedImg) {
                return;
            }
            
            // –ï—Å–ª–∏ —ç—Ç–æ –Ω–æ–≤–∞—è –∫–∞—Ä—Ç–∞ (src –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–µ–∫—É—â–µ–π)
            if (imgSrc !== inspectedImg.src) {
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—É—â–∏–π src
                currentInspectedSrc = imgSrc;
                
                // –î–æ–±–∞–≤–ª—è–µ–º —ç—Ñ—Ñ–µ–∫—Ç "–∏–º–ø—É–ª—å—Å–∞" –ø—Ä–∏ —Å–º–µ–Ω–µ –∫–∞—Ä—Ç—ã
                inspectedImg.classList.add('pulse');
                inspectedImg.src = imgSrc;
                
                // –£–±–∏—Ä–∞–µ–º –∫–ª–∞—Å—Å pulse —á–µ—Ä–µ–∑ 100-150–º—Å –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –≤–æ–∑–≤—Ä–∞—Ç–∞
                setTimeout(() => {
                    inspectedImg.classList.remove('pulse');
                }, 120);
            }
        }
        
        function startInspection(imgSrc) {
            const overlay = document.getElementById('card-inspection-overlay');
            const img = document.getElementById('inspected-card-image');
            
            if (!overlay || !img) {
                console.warn('–≠–ª–µ–º–µ–Ω—Ç—ã –∏–Ω—Å–ø–µ–∫—Ü–∏–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
                return;
            }
            
            img.src = imgSrc;
            currentInspectedSrc = imgSrc;
            overlay.classList.add('show');
            isInspecting = true;
            ignoreNextClick = true;
            
            // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ä–µ–∞–∫—Ü–∏—é –∫–∞—Ä—Ç –Ω–∞ —Ñ–æ–Ω–µ
            document.body.classList.add('is-inspecting');
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å–ª—É—à–∞—Ç–µ–ª–∏ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –¥–≤–∏–∂–µ–Ω–∏—è –∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞
            document.addEventListener('mousemove', handleInspectMove);
            document.addEventListener('touchmove', handleInspectMove, { passive: false });
            document.addEventListener('mouseup', stopInspection);
            document.addEventListener('touchend', stopInspection);
        }
        
        function stopInspection() {
            const overlay = document.getElementById('card-inspection-overlay');
            
            if (!overlay) {
                return;
            }
            
            overlay.classList.remove('show');
            isInspecting = false;
            currentInspectedSrc = null;
            
            // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º —Ä–µ–∞–∫—Ü–∏—é –∫–∞—Ä—Ç –Ω–∞ —Ñ–æ–Ω–µ
            document.body.classList.remove('is-inspecting');
            
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ —Å–ª—É—à–∞—Ç–µ–ª–∏ (cleanup)
            document.removeEventListener('mousemove', handleInspectMove);
            document.removeEventListener('touchmove', handleInspectMove);
            document.removeEventListener('mouseup', stopInspection);
            document.removeEventListener('touchend', stopInspection);
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º ignoreNextClick —á–µ—Ä–µ–∑ –Ω–µ–±–æ–ª—å—à–æ–π —Ç–∞–π–º–∞—É—Ç, —á—Ç–æ–±—ã —É—Å–ø–µ—Ç—å –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏–µ click
            setTimeout(() => {
                ignoreNextClick = false;
            }, 100);
        }
        
        function addInspectionEvents(element, imageSource) {
            if (!element || !imageSource) return;

            let startX = 0;
            let startY = 0;
            let isScrolling = false;

            const handleStart = (e) => {
                // Register start coordinates
                if (e.touches && e.touches[0]) {
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                }
                isScrolling = false;

                // Start Inspection Timer (Long Press)
                if (inspectionTimer) clearTimeout(inspectionTimer);
                inspectionTimer = setTimeout(() => {
                    if (!isScrolling) {
                        startInspection(imageSource);
                    }
                    inspectionTimer = null;
                }, 500);
            };

            const handleMove = (e) => {
                if (!startX || !e.touches) return;

                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                
                // Calculate distance moved
                const diffX = Math.abs(currentX - startX);
                const diffY = Math.abs(currentY - startY);

                // THRESHOLD: If moved more than 10px, assume SCROLLING
                if (diffX > 10 || diffY > 10) {
                    isScrolling = true;
                    // Kill Inspection Timer immediately
                    if (inspectionTimer) {
                        clearTimeout(inspectionTimer);
                        inspectionTimer = null;
                    }
                }
            };

            const handleEnd = (e) => {
                // Clean up timer
                if (inspectionTimer) {
                    clearTimeout(inspectionTimer);
                    inspectionTimer = null;
                }
                
                // REMOVED: Manual click trigger. 
                // Since we use passive listeners, the browser fires a native 'click' event automatically.
                // Triggering it manually caused double-clicks (Select -> Deselect).
            };

            // Touch Events (Passive to allow scrolling)
            element.addEventListener('touchstart', handleStart, { passive: true });
            element.addEventListener('touchmove', handleMove, { passive: true });
            element.addEventListener('touchend', handleEnd);
            element.addEventListener('touchcancel', handleEnd);

            // Mouse Events (Desktop)
            element.addEventListener('mousedown', () => {
                inspectionTimer = setTimeout(() => startInspection(imageSource), 500);
            });
            element.addEventListener('mouseup', () => clearTimeout(inspectionTimer));
            element.addEventListener('mouseleave', () => clearTimeout(inspectionTimer));
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∫–ª–∏–∫–∞ –Ω–∞ –æ–≤–µ—Ä–ª–µ–π –¥–ª—è –∑–∞–∫—Ä—ã—Ç–∏—è (–¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑)
        (function initInspectionOverlay() {
            const overlay = document.getElementById('card-inspection-overlay');
            if (overlay) {
                overlay.addEventListener('click', stopInspection);
            }
        })();
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–∫–∞–∑–∞ –∏–≥—Ä–æ–≤—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
        function showGameNotification(text, type = 'info') {
            const notification = document.getElementById('scoreboard-notification');
            if (!notification) {
                console.warn('–≠–ª–µ–º–µ–Ω—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å
            if (notificationTimer) {
                clearTimeout(notificationTimer);
                notificationTimer = null;
            }
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç
            notification.textContent = text;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ä—ã–µ –∫–ª–∞—Å—Å—ã (–æ—Å—Ç–∞–≤–ª—è–µ–º –±–∞–∑–æ–≤—ã–π id)
            notification.className = '';
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å visible
            notification.classList.add('visible');
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å —Ü–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç type
            if (type === 'error') {
                notification.classList.add('msg-error');
            } else if (type === 'success') {
                notification.classList.add('msg-success');
            } else {
                notification.classList.add('msg-warning');
            }
            
            // –£–±–∏—Ä–∞–µ–º –∫–ª–∞—Å—Å visible —á–µ—Ä–µ–∑ 2.5 —Å–µ–∫—É–Ω–¥—ã
            notificationTimer = setTimeout(() => {
                notification.classList.remove('visible');
                notificationTimer = null;
            }, 2500);
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–Ω–µ—Ä–∞ (–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        function activateCoachAbility(coachData) {
            console.log('Activating coach ability:', coachData.ability);
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞ –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏
            isAbilityAnimating = true;

            // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è (–µ—Å–ª–∏ —Ñ–ª–∞–≥ —É–∂–µ —Å—Ç–æ–∏—Ç, –Ω–æ –≤—ã–∑–æ–≤ –ø—Ä–æ—à–µ–ª)
            // –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –¥–ª—è –ö–ª–æ–ø–ø–∞ —Ñ–ª–∞–≥ —Å—Ç–∞–≤–∏—Ç—Å—è –°–ù–ê–†–£–ñ–ò –≤ AI, –ø–æ—ç—Ç–æ–º—É —Ç—É—Ç –º—ã –µ–≥–æ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–æ–≥–æ, 
            // –µ—Å–ª–∏ —ç—Ç–æ –≤—ã–∑–æ–≤ –æ—Ç –±–æ—Ç–∞.
            
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç (–ò–≥—Ä–æ–∫ –∏–ª–∏ –ë–æ—Ç) –¥–ª—è –ö–ª–æ–ø–ø–∞/–ö–∞—Ä—Å–µ–¥–æ
            // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ –Ω–∞–¥–µ–∂–Ω–µ–µ —Ç–µ–ø–µ—Ä—å, –∫–æ–≥–¥–∞ –æ–Ω–∏ –≥–ª–æ–±–∞–ª—å–Ω—ã–µ
            const isPlayerCoach = (coachData === currentPlayerCoach);
            
            // –í–∏–∑—É–∞–ª—å–Ω–æ –ø–æ–º–µ—á–∞–µ–º –∫–∞—Ä—Ç—É –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—É—é (–Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π –¥—É–±–ª–∏—Ä—É–µ–º)
            const slot = isPlayerCoach ? playerDefenseRightSlot : enemyDefenseRightSlot;
            const cardEl = slot?.querySelector('.coach-card');
            if (cardEl) {
                // Remove pulse immediately when coach is activated
                cardEl.classList.remove('coach-urgent'); // Remove pulse immediately
                cardEl.classList.add('used');
            }
            coachData.isUsed = true;

            // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –∏ –ø–µ—Ä–µ–¥–∞—á–∏ —Ö–æ–¥–∞
            const finalizeAbility = (delayMs = 0) => {
                setTimeout(() => {
                    console.log('Finalizing ability. Checking round end...');
                    
                    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –ø–µ—Ä–µ–¥ –ø—Ä–æ–≤–µ—Ä–∫–æ–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
                    isAbilityAnimating = false;
                    
                    // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Ä–∞—É–Ω–¥ –¥–æ –ø—Ä–æ–≤–µ—Ä–∫–∏
                    const roundBeforeCheck = currentRound;
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –ª–∏ —Ä–∞—É–Ω–¥ –ø—Ä—è–º–æ —Å–µ–π—á–∞—Å (–∞–≤—Ç–æ-–ø–∞—Å –∏ —Ç.–¥.)
                    checkRoundEndCondition(); 

                    // –ï—Å–ª–∏ —Ä–∞—É–Ω–¥ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –∏–ª–∏ –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è - –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
                    if (currentRound !== roundBeforeCheck || isProcessingRoundEnd) {
                        console.log('Aborting finalizeAbility: Round ended during check.');
                        return;
                    }

                    console.log('Returning turn control.');
                    if (isPlayerCoach) {
                        playerJustUsedCoach = true;
                        
                        // FIX: If Enemy passed, turn stays with Player (Solitaire Mode)
                        if (enemyPassed) {
                            console.log('Enemy passed. Turn stays with Player.');
                            isPlayerTurn = true;
                            updatePassButtonState();
                            showGameNotification("–í–∞—à —Ö–æ–¥! (–°–æ–ø–µ—Ä–Ω–∏–∫ –ø–∞—Å)", 'info');
                        } else {
                            // Enemy active -> Switch turn
                            isPlayerTurn = false;
                            enemyTurn();
                        }
                    } else {
                        // Bot used Coach -> Smart Switch (Check if player passed)
                        handleTurnSwitch();
                    }
                }, delayMs);
            };

            // --- –õ–û–ì–ò–ö–ê –ö–ê–†–°–ï–î–û ---
            if (coachData.ability === 'carcedo') {
                const isPlayerSide = (coachData === currentPlayerCoach);

                if (kloppOpportunityMissed) {
                    showGameNotification("–ö–∞—Ä—Å–µ–¥–æ —É–ø—É—Å—Ç–∏–ª –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å!", 'error');
                }
                
                // 1. CHECK: Are there victims?
                if (lastKloppVictims && lastKloppVictims.length > 0) {
                    
                    // SMART FILTER: Only resurrect OWN cards.
                    // If Player uses Carcedo -> recover 'player' victims.
                    // If Enemy uses Carcedo -> recover 'enemy' victims.
                    const myVictims = lastKloppVictims.filter(v => 
                        (isPlayerSide && v.owner === 'player') || 
                        (!isPlayerSide && v.owner === 'enemy')
                    );

                    if (myVictims.length === 0) {
                        // All victims belonged to the opponent (Friendly fire by Klopp).
                        // Carcedo laughs and does nothing.
                        showGameNotification("–ö–∞—Ä—Å–µ–¥–æ –¥–æ–≤–æ–ª–µ–Ω: —Å–æ–ø–µ—Ä–Ω–∏–∫ —É–¥–∞–ª–∏–ª —Å–≤–æ–∏—Ö!", 'success');
                        lastKloppVictims = []; // Clear history
                        finalizeAbility(1000);
                        return;
                    }

                    console.log(`–ö–∞—Ä—Å–µ–¥–æ –æ—Ç–º–µ–Ω—è–µ—Ç —Ä–µ—à–µ–Ω–∏–µ –ö–ª–æ–ø–ø–∞! –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç ${myVictims.length} —Å–≤–æ–∏—Ö –∏–≥—Ä–æ–∫–æ–≤.`);
                    let resurrectedCount = 0;

                    myVictims.forEach((victim, index) => {
                        const victimId = victim.cardData.id;
                        // ... (Rest of resurrection logic uses 'victim' object) ...
                        
                        // Select Graveyard/Field based on OWNER of the victim (which matches Carcedo user)
                        const graveyard = isPlayerSide ? playerGraveyardCards : enemyGraveyardCards;
                        const fieldArray = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                        
                        const graveyardIndex = graveyard.findIndex(c => c.id === victimId);
                        
                        if (graveyardIndex !== -1) {
                            const resurrectedCard = graveyard.splice(graveyardIndex, 1)[0];
                            const targetRowId = victim.rowId;
                            
                            fieldArray.push({ cardData: resurrectedCard, rowId: targetRowId });
                            
                            // Visuals
                            setTimeout(() => {
                                const targetRow = isPlayerSide ? getTargetRow(targetRowId) : getEnemyTargetRow(targetRowId);
                                if (targetRow) {
                                    const fieldCard = document.createElement('div');
                                    fieldCard.className = 'card-on-field';
                                    if (resurrectedCard.isHero || resurrectedCard.cardtype === 'hero') fieldCard.classList.add('hero');
                                    
                                    const img = document.createElement('img');
                                    img.src = resurrectedCard.miniImg || resurrectedCard.img;
                                    fieldCard.appendChild(img);
                                    
                                    fieldCard.setAttribute('data-card-id', resurrectedCard.id);
                                    fieldCard.setAttribute('data-full-img', resurrectedCard.img);
                                    fieldCard.addEventListener('dragstart', e => e.preventDefault());
                                    addInspectionEvents(fieldCard, resurrectedCard.img);
                                    addFieldPowerBadge(fieldCard, resurrectedCard);
                                    
                                    fieldCard.style.opacity = '0';
                                    insertCardSmartly(targetRow, fieldCard);
                                    
                                    requestAnimationFrame(() => {
                                        fieldCard.style.transition = 'opacity 0.5s ease';
                                        fieldCard.style.opacity = '1';
                                    });
                                    updateRowLayout(targetRow);
                                }
                            }, index * 200);
                            resurrectedCount++;
                        }
                    });

                    if (resurrectedCount > 0) {
                        showGameNotification(`–ö–∞—Ä—Å–µ–¥–æ –æ—Ç–º–µ–Ω—è–µ—Ç —É–¥–∞–ª–µ–Ω–∏–µ! –í–µ—Ä–Ω—É–ª–∏—Å—å ${resurrectedCount} –∏–≥—Ä–æ–∫–æ–≤!`, 'success');
                        updatePlayerScore();
                        updateEnemyScore();
                        updateGraveyardVisuals();
                        lastKloppVictims = []; 
                        finalizeAbility(1000 + (resurrectedCount * 200));
                        return;
                    }
                }
                
                // 2. CHECK: Did Celestini just buff units?
                else if (lastCelestiniBuffs && lastCelestiniBuffs.length > 0) {
                    console.log(`–ö–∞—Ä—Å–µ–¥–æ –æ—Ç–º–µ–Ω—è–µ—Ç —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫—É –ß–µ–ª–µ—Å—Ç–∏–Ω–∏! –°–Ω–∏–º–∞–µ—Ç —É—Å–∏–ª–µ–Ω–∏–µ —Å ${lastCelestiniBuffs.length} –∏–≥—Ä–æ–∫–æ–≤.`);
                    
                    let debuffCount = 0;
                    
                    lastCelestiniBuffs.forEach(buff => {
                        // Revert power
                        let currentP = parseInt(buff.cardData.power);
                        buff.cardData.power = currentP - buff.amount;
                        debuffCount++;
                        
                        // Visual "Shrink" Animation
                        if (buff.rowElement) {
                            const cardEl = buff.rowElement.querySelector(`[data-card-id="${buff.cardData.id}"]`);
                            if (cardEl) {
                                cardEl.style.transition = "transform 0.3s ease, filter 0.3s ease";
                                cardEl.style.transform = "scale(0.9)";
                                cardEl.style.filter = "grayscale(50%)"; // Visual indicator of negation
                                setTimeout(() => {
                                    cardEl.style.transform = "scale(1)";
                                    cardEl.style.filter = "none";
                                }, 400);
                            }
                        }
                    });
                    
                    if (debuffCount > 0) {
                        showGameNotification(`–ö–∞—Ä—Å–µ–¥–æ –æ—Ç–º–µ–Ω—è–µ—Ç —Ç–∞–∫—Ç–∏–∫—É –ß–µ–ª–µ—Å—Ç–∏–Ω–∏! (-${debuffCount * 2} –æ—á–∫–æ–≤)`, 'success');
                        updatePlayerScore();
                        updateEnemyScore();
                        lastCelestiniBuffs = []; // Clear logic
                        finalizeAbility(1000);
                        return;
                    }
                }
                
                // ... (Rest of logic for silencing enemy coach) ...
                if (enemyCoachActive) {
                    // ... existing logic ...
                    enemyCoachBonusScore = 0;
                    enemyCoachActive = false;
                    const enemyCoachCard = enemyDefenseRightSlot?.querySelector('.coach-card');
                    if (enemyCoachCard) enemyCoachCard.classList.remove('used');
                    showGameNotification("–ö–∞—Ä—Å–µ–¥–æ –∑–∞–≥–ª—É—à–∞–µ—Ç —Ç—Ä–µ–Ω–µ—Ä–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞!", 'success');
                    updateEnemyScore();
                } else {
                    showGameNotification("–ö–∞—Ä—Å–µ–¥–æ –∫—Ä–∏—á–∏—Ç, –Ω–æ —Å—É–¥—å—è –Ω–µ —Å–ª—ã—à–∏—Ç...", 'warning');
                }
                finalizeAbility(1000);
                return;
            } 
            
            // --- –õ–û–ì–ò–ö–ê –ö–õ–û–ü–ü–ê / REDCARD ---
            else if (coachData.ability === 'klopp' || coachData.ability === 'redcard') {
                // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –∂–µ—Ä—Ç–≤ –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π
                lastKloppVictims = [];
                kloppOpportunityMissed = false; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ —É–ø—É—â–µ–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                
                // 1. –°–±–æ—Ä –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ (—Ç–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–µ –∫–∞—Ä—Ç—ã, –Ω–µ –≥–µ—Ä–æ–∏)
                const allCandidates = [];
                
                const processCards = (cardsArray, isPlayerSide) => {
                    cardsArray.forEach(entry => {
                        const card = entry.cardData;
                        const rowId = entry.rowId;
                        if (card.isHero || card.cardtype === 'hero') return;
                        
                        let power = card.power || 0;
                        const currentField = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                        const currentTactics = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
                        const cardsInRow = currentField.filter(c => c.rowId === rowId);
                        
                        const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                        if (hasLeader && card.ability !== 'leader') power += 1;
                        
                        let multiplier = 1;
                        if (card.ability === 'bond' && cardsInRow.filter(c => c.cardData.ability === 'bond').length >= 2) multiplier *= 2;
                        
                        let buffActive = false;
                        const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                        const hasSupport = currentTactics.some(c => c.rowId === rowId && c.cardData.ability === 'support');
                        if ((hasCaptain && card.ability !== 'captain') || hasSupport) buffActive = true;
                        if (buffActive) multiplier *= 2;
                        
                        allCandidates.push({ entry, isPlayer: isPlayerSide, effectivePower: power * multiplier });
                    });
                };
                
                processCards(playerCardsOnField, true);
                processCards(enemyCardsOnField, false);
                
                // –ï—Å–ª–∏ —Ü–µ–ª–µ–π –Ω–µ—Ç –≤–æ–æ–±—â–µ
                if (allCandidates.length === 0) {
                    showGameNotification("–ù–µ—Ç —Ü–µ–ª–µ–π –¥–ª—è –ö–ª–æ–ø–ø–∞", 'warning');
                    finalizeAbility(500);
                    return;
                }
                
                const maxPower = Math.max(...allCandidates.map(c => c.effectivePower));
                const strongestCards = allCandidates.filter(c => c.effectivePower === maxPower);
                
                // –ï—Å–ª–∏ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Ü–µ–ª–µ–π –Ω–µ—Ç (—Å—Ç—Ä–∞–Ω–Ω–æ, –Ω–æ –±—ã–≤–∞–µ—Ç)
                if (strongestCards.length === 0) {
                    finalizeAbility(500);
                    return;
                }
                
                // 2. –£–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç
                let removedCount = 0;
                const totalCards = strongestCards.length;
                
                const abilityName = coachData.ability === 'redcard' ? '–ö—Ä–∞—Å–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞' : '–ö–ª–æ–ø–ø';
                showGameNotification(`${abilityName} —É–¥–∞–ª—è–µ—Ç —Å–∏–ª—å–Ω–µ–π—à–∏—Ö! (–°–∏–ª–∞: ${maxPower})`, 'error');
                
                strongestCards.forEach((candidate, index) => {
                    const { cardData } = candidate.entry;
                    const { rowId } = candidate.entry;
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –∂–µ—Ä—Ç–≤—É –≤ –º–∞—Å—Å–∏–≤ (–¥–ª—è –ö–∞—Ä—Å–µ–¥–æ)
                    lastKloppVictims.push({
                        cardData: cardData,
                        rowId: rowId,
                        owner: candidate.isPlayer ? 'player' : 'enemy'
                    });

                    // –ò—â–µ–º —ç–ª–µ–º–µ–Ω—Ç –≤ DOM
                    let row, cardElement;
                    if (candidate.isPlayer) {
                        row = getTargetRow(rowId);
                        // –ï—Å–ª–∏ –≤ —Ä—è–¥—É –Ω–µ –Ω–∞—à–ª–∏, –∏—â–µ–º –≤ —Ç–∞–∫—Ç–∏–∫–µ
                        if (row) cardElement = row.querySelector(`[data-card-id="${cardData.id}"]`);
                        if (!cardElement) {
                             const tSlot = getTacticsSlot(rowId);
                             if (tSlot) cardElement = tSlot.querySelector(`[data-card-id="${cardData.id}"]`);
                        }
                    } else {
                        row = getEnemyTargetRow(rowId);
                        if (row) cardElement = row.querySelector(`[data-card-id="${cardData.id}"]`);
                        if (!cardElement) {
                             const tSlot = getEnemyTacticsSlot(rowId);
                             if (tSlot) cardElement = tSlot.querySelector(`[data-card-id="${cardData.id}"]`);
                        }
                    }

                    // –£–¥–∞–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –º–∞—Å—Å–∏–≤–æ–≤ –ù–ï–ú–ï–î–õ–ï–ù–ù–û (—á—Ç–æ–±—ã –ª–æ–≥–∏–∫–∞ –∏–≥—Ä—ã –æ–±–Ω–æ–≤–∏–ª–∞—Å—å —Å—Ä–∞–∑—É)
                    if (candidate.isPlayer) {
                        playerCardsOnField = playerCardsOnField.filter(c => c.cardData.id !== cardData.id);
                        playerTacticsCards = playerTacticsCards.filter(c => c.cardData.id !== cardData.id);
                        playerGraveyardCards.push(cardData);
                    } else {
                        enemyCardsOnField = enemyCardsOnField.filter(c => c.cardData.id !== cardData.id);
                        enemyTacticsCards = enemyTacticsCards.filter(c => c.cardData.id !== cardData.id);
                        enemyGraveyardCards.push(cardData);
                    }
                    updateGraveyardVisuals(); // <--- ADD THIS AFTER PUSH

                    // –ê–Ω–∏–º–∞—Ü–∏—è
                    const graveyard = candidate.isPlayer ? playerGraveyard : enemyGraveyard;
                    
                    if (cardElement && graveyard) {
                        setTimeout(() => {
                            animateCardToGraveyard(cardElement, graveyard, () => {
                                if (cardElement.parentNode) cardElement.remove();
                                if (row) updateRowLayout(row);
                                removedCount++;
                                if (removedCount === totalCards) {
                                    updatePlayerScore();
                                    updateEnemyScore();
                                }
                            });
                        }, index * 200);
                    } else {
                        // –ï—Å–ª–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ –Ω–µ—Ç –≤ DOM (–±–∞–≥), –ø—Ä–æ—Å—Ç–æ —Å—á–∏—Ç–∞–µ–º —É–¥–∞–ª–µ–Ω–Ω—ã–º
                        console.warn('DOM element not found for card removal:', cardData.name);
                        removedCount++;
                    }
                });

                // 3. –í—ã–∑—ã–≤–∞–µ–º —Ñ–∏–Ω–∞–ª —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π, –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–π –¥–ª—è –≤—Å–µ—Ö –∞–Ω–∏–º–∞—Ü–∏–π
                const animationDelay = (totalCards * 200) + 800;
                finalizeAbility(animationDelay);
            } 
            
            // --- –õ–û–ì–ò–ö–ê –ß–ï–õ–ï–°–¢–ò–ù–ò (Boost Attackers) ---
            else if (coachData.ability === 'celestini') {
                const isPlayerSide = (coachData === currentPlayerCoach);
                const targetList = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                const rowElement = isPlayerSide ? attackRow : enemyAttackRow;
                
                // Clear previous records
                lastCelestiniBuffs = [];
                // Reset opportunity flag
                kloppOpportunityMissed = false; 
                
                let buffCount = 0;

                console.log(`Celestini activated for ${isPlayerSide ? 'Player' : 'Enemy'}`);

                targetList.forEach(entry => {
                    const card = entry.cardData;
                    
                    // FILTER: Attack Row + Base Card + Not Hero + NOT Dummy/Support/Special
                    if (entry.rowId === 'attack' && 
                        card.cardtype === 'base' && 
                        !card.isHero && 
                        card.cardtype !== 'hero' &&
                        card.ability !== 'dummy' &&     // No Mannequins
                        card.ability !== 'support' &&   // No Tribunes
                        card.type !== 'special') {      // No Specials
                        
                        // FIX: Force Integer Conversion to prevent "5" + 2 = "52"
                        let currentP = parseInt(card.power);
                        if (isNaN(currentP)) currentP = 0;
                        
                        const buffAmount = 2; // Celestini gives +2
                        card.power = currentP + buffAmount;
                        
                        // RECORD THE BUFF FOR CARCEDO
                        lastCelestiniBuffs.push({
                            cardData: card,
                            amount: buffAmount,
                            rowElement: rowElement // Store for visual update
                        });
                        
                        buffCount++;

                        // Animation
                        if (rowElement) {
                            const cardEl = rowElement.querySelector(`[data-card-id="${card.id}"]`);
                            if (cardEl) {
                                cardEl.style.transition = "transform 0.3s ease";
                                cardEl.style.transform = "scale(1.15)";
                                setTimeout(() => cardEl.style.transform = "scale(1)", 300);
                            }
                        }
                    }
                });

                if (buffCount > 0) {
                    const msg = `–ß–µ–ª–µ—Å—Ç–∏–Ω–∏ —É—Å–∏–ª–∏–≤–∞–µ—Ç –∞—Ç–∞–∫—É! (+${buffCount * 2})`;
                    showGameNotification(msg, 'success');
                    updatePlayerScore();
                    updateEnemyScore();
                } else {
                    showGameNotification("–ß–µ–ª–µ—Å—Ç–∏–Ω–∏: –ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –Ω–∞–ø–∞–¥–∞—é—â–∏—Ö.", 'warning');
                }

                finalizeAbility(1000);
            }
            
            // --- –î–†–£–ì–ò–ï –¢–†–ï–ù–ï–†–´ ---
            else {
                showGameNotification("–¢—Ä–µ–Ω–µ—Ä —á—Ç–æ-—Ç–æ –∫—Ä–∏—á–∏—Ç!", 'info');
                finalizeAbility(1000);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ —Ä—É–∫–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ (–≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —Ä—É–±–∞—à–µ–∫)
        function renderOpponentHand() {
            if (!opponentHand) {
                console.warn('–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä opponent-hand –Ω–µ –Ω–∞–π–¥–µ–Ω');
                return;
            }
            
            // –û—á–∏—â–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
            opponentHand.innerHTML = '';
            
            // –ü–æ–ª—É—á–∞–µ–º –∞—Å—Å–µ—Ç—ã –¥–ª—è —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
            const enemyAssets = teamAssets[enemyTeamKey];
            
            // –°–æ–∑–¥–∞–µ–º —Ä—É–±–∞—à–∫–∏ –∫–∞—Ä—Ç –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –ù–ï–ò–°–ü–û–õ–¨–ó–û–í–ê–ù–ù–´–• –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
            const unusedCards = enemyCards.filter(card => !card.used);
            unusedCards.forEach((cardData, index) => {
                const cardBack = document.createElement('div');
                cardBack.className = 'card-back';
                cardBack.setAttribute('data-opponent-card-index', index);
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–æ–Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
                if (enemyAssets && enemyAssets.cardBack) {
                    cardBack.style.backgroundImage = `url('${enemyAssets.cardBack}')`;
                }
                
                opponentHand.appendChild(cardBack);
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∏ –∫–∞—Ä—Ç –≤ —Å–æ—Å—Ç–∞–≤–µ
        function sortSquadCards(cardsArray) {
            return cardsArray.sort((a, b) => {
                // 1. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Å–∏–ª–µ (—É–±—ã–≤–∞–Ω–∏–µ)
                const powerA = a.power || 0;
                const powerB = b.power || 0;
                
                if (powerB !== powerA) {
                    return powerB - powerA; // –°–Ω–∞—á–∞–ª–∞ —Å–∏–ª—å–Ω—ã–µ
                }
                
                // 2. –ï—Å–ª–∏ —Å–∏–ª–∞ —Ä–∞–≤–Ω–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π
                // –°—á–∏—Ç–∞–µ–º —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å—é –Ω–∞–ª–∏—á–∏–µ –ø–æ–ª—è ability –∏–ª–∏ –µ—Å–ª–∏ –∫–∞—Ä—Ç–∞ –≥–µ—Ä–æ–π
                const hasAbilityA = (a.ability || a.isHero || a.cardtype === 'hero') ? 1 : 0;
                const hasAbilityB = (b.ability || b.isHero || b.cardtype === 'hero') ? 1 : 0;
                
                // –ï—Å–ª–∏ —É B –µ—Å—Ç—å —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å, –∞ —É A –Ω–µ—Ç - B –∏–¥–µ—Ç —Ä–∞–Ω—å—à–µ
                return hasAbilityB - hasAbilityA;
            });
        }
        
        // --- GLOBAL SUBSTITUTION LOGIC ---
        window.performSubstitutions = function() {
            console.log(">>> ACTION: Performing Substitutions...");
            
            // 1. Validation
            if (selectedCardsForSwap.length === 0) {
                showGameNotification("–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—ã –¥–ª—è –∑–∞–º–µ–Ω—ã!", "warning");
                return;
            }
            if (usedReplacements >= 3) {
                showGameNotification("–õ–∏–º–∏—Ç –∑–∞–º–µ–Ω –∏—Å—á–µ—Ä–ø–∞–Ω!", "error");
                return;
            }

            // 2. Identify what goes and what stays
            const discardedIds = [...selectedCardsForSwap]; // IDs to remove
            // Cards currently in hand that we KEEP
            const cardsKeeping = myCards.filter(c => !discardedIds.includes(c.id));
            const cardsKeepingIds = cardsKeeping.map(c => c.id);
            
            // Blacklist: Don't draw what we hold, and don't redraw what we just discarded
            const forbiddenIds = [...cardsKeepingIds, ...discardedIds];
            
            // 3. Build the Source Pool (The "Optimized Deck" of 23 Best Cards)
            const allCardsRaw = allGameData[playerTeamKey];
            // Filter out managers
            const playableCardsRaw = allCardsRaw.filter(card => 
                card.position !== 'manager' && card.cardtype !== 'manager'
            );
            // Re-build the competitive deck
            const optimizedPool = buildOptimizedDeck(playableCardsRaw, 23);
            
            // 4. Find Valid Replacements
            // Filter the pool to find cards that are NOT in the blacklist
            let availableReplacements = optimizedPool.filter(card => !forbiddenIds.includes(card.id));
            
            // 5. Fallback Strategy (If Top 23 pool is exhausted)
            if (availableReplacements.length < discardedIds.length) {
                console.warn("Subs: Optimized pool exhausted. Searching full collection...");
                const rawPool = shuffleArray(playableCardsRaw);
                availableReplacements = rawPool.filter(card => !forbiddenIds.includes(card.id));
            }
            
            // 6. Draw New Cards
            const countNeeded = discardedIds.length;
            const newCards = availableReplacements.slice(0, countNeeded);
            
            // 7. Update Hand
            // Mark new cards with isNew: true to lock them visually if needed
            const labeledNewCards = newCards.map(card => ({ ...card, isNew: true }));
            myCards = [...cardsKeeping, ...labeledNewCards];
            
            // 8. Update State Counters
            const actuallySwapped = newCards.length;
            replacementsLeft -= actuallySwapped;
            usedReplacements += actuallySwapped;
            
            // 9. Cleanup & Refresh UI
            selectedCardsForSwap = []; // Clear selection
            sortSquadCards(myCards);   // Re-sort hand by power
            renderSquadGrid();         // Re-render grid
            updateSquadCounters();     // Update button text and status
            
            // Optional: Notify user
            // showGameNotification(`–ó–∞–º–µ–Ω–µ–Ω–æ –∫–∞—Ä—Ç: ${actuallySwapped}`, "success");
        };
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ —ç–∫—Ä–∞–Ω–∞ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–∞–≤–æ–º
        function showSquadScreen() {
            console.log(">>> SHOWING SQUAD SCREEN");

            // 1. FORCE HIDE ALL OTHER SCREENS IMMEDIATELY
            // Do not rely on fade-out animations for blocking interaction
            const screens = ['start-screen', 'faction-screen', 'game-screen', 'collection-screen', 'collection-cards-screen'];
            screens.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = 'none';
            });

            // 2. Show Squad Screen
            const squadScreen = document.getElementById('squad-screen');
            squadScreen.style.display = 'flex';
            squadScreen.style.opacity = '1';
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            selectedCardsForSwap = [];
            replacementsLeft = 3;
            usedReplacements = 0;
            newlyArrivedCardIds = [];
            
            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º 11 —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–∞—Ä—Ç –¥–ª—è –∏–≥—Ä–æ–∫–∞ –∏–∑ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–ª–æ–¥—ã
            // Generate the competitive pool of 23 cards first
            const allCards = allGameData[playerTeamKey];
            // –ò—Å–∫–ª—é—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –∏–∑ –∫–∞—Ä—Ç –¥–ª—è –≤—ã–±–æ—Ä–∞ —Å–æ—Å—Ç–∞–≤–∞
            const playableCards = allCards.filter(card => 
                card.position !== 'manager' && card.cardtype !== 'manager'
            );
            const optimizedPool = buildOptimizedDeck(playableCards, 23);
            
            // Take the top 11 cards from this optimized pool for the hand
            // (buildOptimizedDeck already shuffles, so we can just slice)
            // –í—Å–µ –Ω–∞—á–∞–ª—å–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏–º–µ—é—Ç isNew: false (–¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –∑–∞–º–µ–Ω—ã)
            myCards = optimizedPool.slice(0, 11).map(card => ({ ...card, isNew: false }));
            
            // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∫–∞—Ä—Ç—ã —Å—Ä–∞–∑—É –ø–æ—Å–ª–µ —Ä–∞–∑–¥–∞—á–∏
            sortSquadCards(myCards);
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∫–∞—Ä—Ç—ã –≤ —Å–µ—Ç–∫–µ —Å–æ—Å—Ç–∞–≤–∞
            renderSquadGrid();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Å—á–µ—Ç—á–∏–∫ –Ω–∞ 0/3)
            updateSquadCounters();
            
            // --- FINAL PRODUCTION BINDING ---
            setTimeout(() => {
                const subBtn = document.getElementById('btn-subs-action');
                const startBtn = document.getElementById('btn-start-action');
                
                if (subBtn) {
                    subBtn.disabled = false;
                    subBtn.onclick = (e) => {
                        e.stopPropagation();
                        // alert removed
                        window.forceSubsClick();
                    };
                }
                
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.onclick = (e) => {
                        e.stopPropagation();
                        // alert removed
                        window.forceStartClick();
                    };
                }
                updateSquadCounters();
            }, 100);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–∞–π–º–µ—Ä
            startSquadTimer();
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫–∞—Ä—Ç –≤ —Å–µ—Ç–∫–µ —Å–æ—Å—Ç–∞–≤–∞
        function renderSquadGrid() {
            const squadGrid = document.getElementById('squad-grid');
            squadGrid.innerHTML = '';
            
            myCards.forEach((cardData, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'squad-card';
                cardElement.setAttribute('data-card-id', cardData.id);
                cardElement.setAttribute('data-card-index', index);
                
                // –°—Ç–∞—Ä–∞—è –ª–æ–≥–∏–∫–∞ –∞–Ω–∏–º–∞—Ü–∏–∏ just-arrived —É–¥–∞–ª–µ–Ω–∞ - —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç–∞—Ç–∏—á–Ω–∞—è –∏–∫–æ–Ω–∫–∞ –∑–∞–º–µ–Ω—ã
                
                const cardImage = document.createElement('img');
                cardImage.src = cardData.img;
                cardImage.alt = cardData.name || `–ö–∞—Ä—Ç–∞ ${cardData.id}`;
                
                cardElement.appendChild(cardImage);
                
                /* REMOVED AS REQUESTED
                // Add power badge
                if (cardData.power !== undefined) {
                    const powerBadge = document.createElement('div');
                    powerBadge.className = 'card-power';
                    powerBadge.textContent = cardData.power;
                    cardElement.appendChild(powerBadge);
                }
                */
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –¥–ª—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç (isNew: true)
                if (cardData.isNew === true) {
                    cardElement.classList.add('replaced-card');
                }

                // --- NEW: ADD INSPECTION EVENTS (Long Press to Zoom) ---
                // Only enable inspection if the card is not replaced (optional, but cleaner)
                // Passing cardElement and the image source
                addInspectionEvents(cardElement, cardData.img);
                
                // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–∞—Ä—Ç—ã (Swap Logic)
                cardElement.addEventListener('click', function(e) {
                    // --- CONFLICT FIX: RESPECT INSPECT MODE ---
                    // Like on the game board, if we just finished inspecting (long press), 
                    // we must ignore this click event to prevent accidental selection.
                    if (ignoreNextClick) {
                        console.log("Squad click ignored due to inspection");
                        // Reset flag immediately to prevent locking (optional safety, usually handled by stopInspection)
                        // ignoreNextClick = false; 
                        return;
                    }

                    // Prevent double firing if needed
                    e.stopPropagation(); 
                    
                    // –ù–µ –ø–æ–∑–≤–æ–ª—è–µ–º –≤—ã–±–∏—Ä–∞—Ç—å –∫–∞—Ä—Ç—ã, –µ—Å–ª–∏ –ª–∏–º–∏—Ç –∑–∞–º–µ–Ω –∏—Å—á–µ—Ä–ø–∞–Ω
                    if (usedReplacements >= 3 && !this.classList.contains('selected-swap')) {
                         showGameNotification(`–õ–∏–º–∏—Ç –∑–∞–º–µ–Ω –∏—Å—á–µ—Ä–ø–∞–Ω (3/3)`, 'warning');
                         return;
                    }
                    
                    // –ù–µ –ø–æ–∑–≤–æ–ª—è–µ–º –≤—ã–±–∏—Ä–∞—Ç—å –∫–∞—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –ø–æ–ª—É—á–µ–Ω—ã –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –∑–∞–º–µ–Ω—ã (locked)
                    if (cardData.isNew === true) return;
                    
                    const cardId = parseInt(this.getAttribute('data-card-id'));
                    const isSelected = this.classList.contains('selected-swap');
                    
                    if (isSelected) {
                        // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ
                        this.classList.remove('selected-swap');
                        selectedCardsForSwap = selectedCardsForSwap.filter(id => id !== cardId);
                    } else {
                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ª–∏–º–∏—Ç –≤—ã–±–æ—Ä–∞ (–Ω–µ –±–æ–ª—å—à–µ, —á–µ–º –æ—Å—Ç–∞–ª–æ—Å—å –∑–∞–º–µ–Ω)
                        const maxCanUse = 3 - usedReplacements;
                        if (selectedCardsForSwap.length < maxCanUse) {
                            this.classList.add('selected-swap');
                            selectedCardsForSwap.push(cardId);
                        } else {
                            // –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ
                            showGameNotification(`–ú–æ–∂–Ω–æ –≤—ã–±—Ä–∞—Ç—å –º–∞–∫—Å–∏–º—É–º ${maxCanUse} –∫–∞—Ä—Ç(—ã) –¥–ª—è –∑–∞–º–µ–Ω—ã`, 'warning');
                        }
                    }
                    
                    updateSquadCounters();
                });
                
                squadGrid.appendChild(cardElement);
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç—á–∏–∫–æ–≤
        function updateSquadCounters() {
            const subBtn = document.getElementById('btn-subs-action');
            const startBtn = document.getElementById('btn-start-action');
            const counterEl = document.getElementById('subs-counter');
            const count = selectedCardsForSwap.length;
            
            // Update Counter Text
            if (counterEl) counterEl.textContent = `–ó–∞–º–µ–Ω: ${usedReplacements}/3`;

            // Update Substitution Button Logic
            if (subBtn) {
                subBtn.disabled = false; 
                
                if (usedReplacements >= 3) {
                    // Limit Reached (Force 2 lines)
                    subBtn.innerHTML = "–í—Å–µ –∑–∞–º–µ–Ω—ã<br>—Å–¥–µ–ª–∞–Ω—ã";
                    subBtn.style.background = "#4a4a4a"; 
                    subBtn.style.color = "rgba(255, 255, 255, 0.5)";
                    subBtn.style.boxShadow = "none";
                    subBtn.style.border = "1px solid rgba(255,255,255,0.1)";
                } else if (count === 0) {
                    // Waiting for selection (Force 2 lines)
                    subBtn.innerHTML = "–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—ã<br>–¥–ª—è –∑–∞–º–µ–Ω—ã";
                    subBtn.style.background = "#4a4a4a";
                    subBtn.style.color = "rgba(255, 255, 255, 0.5)";
                    subBtn.style.boxShadow = "none";
                    subBtn.style.border = "1px solid rgba(255,255,255,0.1)";
                } else {
                    // Ready to Swap (Already 2 lines)
                    const suffix = count === 1 ? '–∫–∞—Ä—Ç—É' : '–∫–∞—Ä—Ç—ã';
                    subBtn.innerHTML = `–ó–∞–º–µ–Ω–∏—Ç—å<br>${count} ${suffix}`;
                    
                    subBtn.style.background = "linear-gradient(135deg, #ff3333, #cc0000)";
                    subBtn.style.color = "white";
                    subBtn.style.boxShadow = "0 4px 10px rgba(0,0,0,0.5)";
                    subBtn.style.border = "none";
                }
            }
            
            if (startBtn) {
                startBtn.disabled = false;
                startBtn.style.opacity = '1';
                // Ensure Start button is also consistent if needed, but "–ù–∞—á–∞—Ç—å –º–∞—Ç—á" fits in 1 line.
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ —Ç–∞–π–º–µ—Ä–∞
        function startSquadTimer() {
            const timerElement = document.getElementById('squad-timer');
            let timeLeft = 30;
            timerElement.textContent = timeLeft;
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä, –µ—Å–ª–∏ –µ—Å—Ç—å
            if (squadTimerInterval) {
                clearInterval(squadTimerInterval);
            }
            
            squadTimerInterval = setInterval(function() {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    clearInterval(squadTimerInterval);
                    // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞—á–∏–Ω–∞–µ–º –º–∞—Ç—á
                    startMatch();
                }
            }, 1000);
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç—Ä–µ–Ω–µ—Ä–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–º–∞–Ω–¥—ã
        function getCoachForTeam(teamKey) {
            if (teamKey === 'allSpartakCards') {
                return { ...carcedoCoach, isUsed: false };
            } else if (teamKey === 'allFootballStarsCards') {
                return { ...kloppCoach, isUsed: false };
            } else if (teamKey === 'allRPLCards') {
                return { ...celestiniCoach, isUsed: false };
            } else {
                return null; // –ö–æ–º–∞–Ω–¥–∞ –±–µ–∑ —Ç—Ä–µ–Ω–µ—Ä–∞
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏—è –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –∫–æ–ª–æ–¥—ã –∏–∑ –ª—É—á—à–∏—Ö –∫–∞—Ä—Ç
        function buildOptimizedDeck(allCards, targetSize = 23) {
            // 0. –ò—Å–∫–ª—é—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ (—Ç—Ä–µ–Ω–µ—Ä–æ–≤) –∏–∑ –∫–æ–ª–æ–¥—ã
            const playableCards = allCards.filter(c => 
                c.position !== 'manager' && c.cardtype !== 'manager'
            );
            
            // 1. Filter High Value Cards (Heroes, Specials, Abilities)
            const highValue = playableCards.filter(c => 
                c.isHero || 
                c.cardtype === 'hero' ||
                c.type === 'special' ||
                c.cardtype === 'special' ||
                (c.ability && c.ability !== '' && c.ability !== 'none')
            );

            // 2. Filter Standard Units (The rest)
            const standardUnits = playableCards.filter(c => !highValue.includes(c));
            
            // 3. Sort Standard Units by Power (Descending)
            standardUnits.sort((a, b) => (b.power || 0) - (a.power || 0));

            // 4. Construct Deck
            let finalDeck = [...highValue];

            // 5. Fill remaining slots with strongest standard units
            if (finalDeck.length < targetSize) {
                const needed = targetSize - finalDeck.length;
                finalDeck = finalDeck.concat(standardUnits.slice(0, needed));
            } 
            // Edge case: If high value cards alone exceed targetSize, sort by power and take top cards
            else if (finalDeck.length > targetSize) {
                // Sort highValue by power just in case we have to cut
                finalDeck.sort((a, b) => (b.power || 0) - (a.power || 0));
                finalDeck = finalDeck.slice(0, targetSize);
            }

            // 6. Shuffle
            return shuffleArray(finalDeck);
        }
        
        // –§—É–Ω–∫—Ü–∏—è –Ω–∞—á–∞–ª–∞ –∏–≥—Ä—ã (–ö—Ä—É–ø—å–µ) - —Ç–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —É–∂–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã
        // –í–ê–ñ–ù–û: –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –≤—ã–∑—ã–≤–∞—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –Ω–∞—á–∞–ª–µ –º–∞—Ç—á–∞
        let gameStarted = false; // –§–ª–∞–≥ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞
        function initializeMatchResources() {
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏ —Ç—Ä–µ–Ω–µ—Ä–æ–≤
            enemyCoachActive = false;
            enemyCoachUsed = false;
            enemyCoachBonusScore = 0;
            
            // myCards —É–∂–µ –∑–∞–ø–æ–ª–Ω–µ–Ω –≤ showSquadScreen, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é –∫–æ–ª–æ–¥—É –∏–≥—Ä–æ–∫–∞: –ª—É—á—à–∏–µ 23 –∫–∞—Ä—Ç—ã
            const allPlayerCards = allGameData[playerTeamKey];
            // –ò—Å–∫–ª—é—á–∞–µ–º –º–µ–Ω–µ–¥–∂–µ—Ä–æ–≤ –∏–∑ –∫–æ–ª–æ–¥—ã –∏–≥—Ä–æ–∫–∞
            const playablePlayerCards = allPlayerCards.filter(card => 
                card.position !== 'manager' && card.cardtype !== 'manager'
            );
            const optimizedDeck = buildOptimizedDeck(playablePlayerCards, 23);
            
            // –§–∏–ª—å—Ç—Ä—É–µ–º –∫–∞—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –≤ —Ä—É–∫–µ
            const cardsInHandIds = myCards.map(card => card.id);
            myDeck = optimizedDeck
                .filter(card => !cardsInHandIds.includes(card.id))
                .map(card => ({ ...card, used: false }));
            
            // –ö–æ–ª–æ–¥–∞ —É–∂–µ –ø–µ—Ä–µ–º–µ—à–∞–Ω–∞ –≤ buildOptimizedDeck, –Ω–æ –º–æ–∂–Ω–æ –ø–µ—Ä–µ–º–µ—à–∞—Ç—å –µ—â–µ —Ä–∞–∑ –¥–ª—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π —Å–ª—É—á–∞–π–Ω–æ—Å—Ç–∏
            myDeck = shuffleArray(myDeck);
            
            console.log('–ö–æ–ª–æ–¥–∞ –∏–≥—Ä–æ–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞. –ö–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ:', myDeck.length);
            
            // --- AI DECK GENERATION (Universal 23-Card Pool) ---
            const allEnemyCards = allGameData[enemyTeamKey];
            
            // 1. Filter playable cards (No managers)
            const playableEnemyCards = allEnemyCards.filter(card => 
                card.position !== 'manager' && card.cardtype !== 'manager'
            );
            
            // 2. Build Optimized Pool (Best 23 Cards) for ANY faction
            const optimizedEnemyPool = buildOptimizedDeck(playableEnemyCards, 23);
            
            // 3. Split into Hand (11) and Draw Pile (12)
            enemyCards = optimizedEnemyPool.slice(0, 11).map(card => ({ 
                ...card, 
                used: false 
            }));
            
            enemyDrawPile = optimizedEnemyPool.slice(11).map(card => ({ 
                ...card, 
                used: false 
            }));
            
            // Shuffle the draw pile immediately
            enemyDrawPile = shuffleArray(enemyDrawPile);
            
            console.log(`Enemy Deck initialized for ${enemyTeamKey}. Hand: 11, Deck: ${enemyDrawPile.length}`);
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∫–∞—Ä—Ç—ã –≤ —Ä—É–∫–µ –∏–≥—Ä–æ–∫–∞
            renderPlayerHand();
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –∫–∞—Ä—Ç—ã –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π
            renderEnemyHand();
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é —Ä—É–∫–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
            renderOpponentHand();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞—Å—Å–µ—Ç—ã –∫–æ–º–∞–Ω–¥ (–∫–æ–ª–æ–¥—ã, –æ—Ç–±–æ–∏, —Ä—É–±–∞—à–∫–∏ –∫–∞—Ä—Ç)
            updateTeamAssets();
            
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç—Ä–µ–Ω–µ—Ä–æ–≤ –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ –≤–µ—Å—å –º–∞—Ç—á
            currentPlayerCoach = getCoachForTeam(playerTeamKey);
            currentEnemyCoach = getCoachForTeam(enemyTeamKey);
            
            // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Ç—Ä–µ–Ω–µ—Ä–æ–≤
            if (playerDefenseRightSlot) {
                renderCoach(playerDefenseRightSlot, currentPlayerCoach, true);
            }
            
            if (enemyDefenseRightSlot) {
                renderCoach(enemyDefenseRightSlot, currentEnemyCoach, false);
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫–∏ –∫–æ–ª–æ–¥
            updatePlayerDeckCounter();
            updateEnemyDeckCounter();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω–æ–µ —Ç–∞–±–ª–æ
            updateMatchScore();
            updatePlayerScore();
            updateEnemyScore();
            
            // Initialize graveyard visuals (empty at start)
            updateGraveyardVisuals();
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–≥–æ—Ç–∏–ø—ã –∫–æ–º–∞–Ω–¥
            updateTeamLogos();
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ –ø–∞—Å–∞
            if (passButton) {
                updatePassButtonState();
            }
            
            // –ï—Å–ª–∏ –Ω–∞—á–∏–Ω–∞–µ—Ç –±–æ—Ç, –∑–∞–ø—É—Å–∫–∞–µ–º –µ–≥–æ —Ö–æ–¥ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            if (!isPlayerTurn) {
                setTimeout(enemyTurn, 1500);
            }
        }
        
        function startGame() {
            // –ó–∞—â–∏—Ç–∞ –æ—Ç –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤—ã–∑–æ–≤–∞
            if (gameStarted) {
                console.warn('startGame() —É–∂–µ –±—ã–ª–∞ –≤—ã–∑–≤–∞–Ω–∞ —Ä–∞–Ω–µ–µ. –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤.');
                return;
            }
            gameStarted = true;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫–∏ —Ä–∞—É–Ω–¥–æ–≤ –∏ –ø–æ–±–µ–¥
            currentRound = 1;
            playerMatchWins = 0;
            enemyMatchWins = 0;
            playerPassed = false;
            enemyPassed = false;
            isProcessingRoundEnd = false;
            
            // 1. –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï –ü–ï–†–í–û–ì–û –•–û–î–ê (–ê–¥–º–∏–Ω—Ä–µ—Å—É—Ä—Å –†–ü–õ –∏–ª–∏ –ú–æ–Ω–µ—Ç–∫–∞)
            const isPlayerRPL = playerTeamKey === 'allRPLCards';
            const isEnemyRPL = enemyTeamKey === 'allRPLCards';
            
            if (isPlayerRPL) {
                // –°—Ü–µ–Ω–∞—Ä–∏–π –ê: –ò–≥—Ä–æ–∫ –∏–≥—Ä–∞–µ—Ç –∑–∞ –†–ü–õ - –æ–Ω –≤—ã–±–∏—Ä–∞–µ—Ç
                console.log('–ò–≥—Ä–æ–∫ –∏–≥—Ä–∞–µ—Ç –∑–∞ –†–ü–õ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞');
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ª–æ–≥–æ—Ç–∏–ø—ã –≤ –æ–≤–µ—Ä–ª–µ–π
                const choicePlayerLogo = document.getElementById('choice-player-logo');
                const choiceEnemyLogo = document.getElementById('choice-enemy-logo');
                const rplOverlay = document.getElementById('rpl-choice-overlay');
                
                if (choicePlayerLogo && teamLogos[playerTeamKey]) {
                    choicePlayerLogo.src = teamLogos[playerTeamKey].light;
                }
                if (choiceEnemyLogo && teamLogos[enemyTeamKey]) {
                    choiceEnemyLogo.src = teamLogos[enemyTeamKey].light;
                }
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–≤–µ—Ä–ª–µ–π
                if (rplOverlay) {
                    rplOverlay.style.display = 'flex';
                    
                    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤—ã–±–æ—Ä–∞
                    const btnChoicePlayer = document.getElementById('btn-choice-player');
                    const btnChoiceEnemy = document.getElementById('btn-choice-enemy');
                    
                    const handleChoice = (choice) => {
                        // –£–¥–∞–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ—Å–ª–µ –≤—ã–±–æ—Ä–∞
                        btnChoicePlayer.removeEventListener('click', handlePlayerChoice);
                        btnChoiceEnemy.removeEventListener('click', handleEnemyChoice);
                        
                        // –°–∫—Ä—ã–≤–∞–µ–º –æ–≤–µ—Ä–ª–µ–π
                        rplOverlay.style.display = 'none';
                        
                        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥—è—â–µ–≥–æ
                        if (choice === 'player') {
                            matchStarter = 'player';
                            isPlayerTurn = true;
                            console.log('–ò–≥—Ä–æ–∫ –≤—ã–±—Ä–∞–ª: –Ø –Ω–∞—á–∏–Ω–∞—é');
                            showGameNotification('–†–∞—É–Ω–¥ 1. –í—ã –Ω–∞—á–∏–Ω–∞–µ—Ç–µ –ø–µ—Ä–≤—ã–º!', 'info');
                        } else {
                            matchStarter = 'enemy';
                            isPlayerTurn = false;
                            console.log('–ò–≥—Ä–æ–∫ –≤—ã–±—Ä–∞–ª: –°–æ–ø–µ—Ä–Ω–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç');
                            showGameNotification('–†–∞—É–Ω–¥ 1. –°–æ–ø–µ—Ä–Ω–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç –ø–µ—Ä–≤—ã–º!', 'info');
                        }
                        
                        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –∏–≥—Ä—ã
                        initializeMatchResources();
                    };
                    
                    const handlePlayerChoice = () => handleChoice('player');
                    const handleEnemyChoice = () => handleChoice('enemy');
                    
                    btnChoicePlayer.addEventListener('click', handlePlayerChoice);
                    btnChoiceEnemy.addEventListener('click', handleEnemyChoice);
                } else {
                    // Fallback: –µ—Å–ª–∏ –æ–≤–µ—Ä–ª–µ–π –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–Ω–¥–æ–º
                    console.warn('–û–≤–µ—Ä–ª–µ–π –≤—ã–±–æ—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ä–∞–Ω–¥–æ–º');
                    const isPlayerStart = Math.random() < 0.5;
                    matchStarter = isPlayerStart ? 'player' : 'enemy';
                    isPlayerTurn = isPlayerStart;
                    showGameNotification(`–†–∞—É–Ω–¥ 1. –ü–µ—Ä–≤—ã–º —Ö–æ–¥–∏—Ç ${isPlayerStart ? '–ò–≥—Ä–æ–∫' : '–°–æ–ø–µ—Ä–Ω–∏–∫'}!`, 'info');
                    initializeMatchResources();
                }
                
            } else if (isEnemyRPL) {
                // –°—Ü–µ–Ω–∞—Ä–∏–π –ë: –ë–æ—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ –†–ü–õ - –æ–Ω —Ä–µ—à–∞–µ—Ç
                console.log('–ë–æ—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ –†–ü–õ - –æ–Ω —Ä–µ—à–∞–µ—Ç –ø–µ—Ä–≤—ã–π —Ö–æ–¥');
                
                // –ë–æ—Ç –≤ 95% —Å–ª—É—á–∞–µ–≤ –æ—Ç–¥–∞–µ—Ç —Ö–æ–¥ –∏–≥—Ä–æ–∫—É (–≤—ã–≥–æ–¥–Ω–µ–µ)
                const botGivesTurnToPlayer = Math.random() < 0.95;
                
                if (botGivesTurnToPlayer) {
                    matchStarter = 'player';
                    isPlayerTurn = true;
                    showGameNotification('–ê–¥–º–∏–Ω—Ä–µ—Å—É—Ä—Å! –†–ü–õ —Ä–µ—à–∏–ª–∞, —á—Ç–æ –≤—ã —Ö–æ–¥–∏—Ç–µ –ø–µ—Ä–≤—ã–º', 'info');
                } else {
                    matchStarter = 'enemy';
                    isPlayerTurn = false;
                    showGameNotification('–†–ü–õ —Ä–µ—à–∏–ª–∞, —á—Ç–æ –±—É–¥–µ—Ç —Ö–æ–¥–∏—Ç—å –ø–µ—Ä–≤–æ–π', 'warning');
                }
                
                console.log(`–ú–∞—Ç—á –Ω–∞—á–∞–ª—Å—è! –ü–µ—Ä–≤—ã–º —Ö–æ–¥–∏—Ç: ${isPlayerTurn ? '–ò–≥—Ä–æ–∫' : '–°–æ–ø–µ—Ä–Ω–∏–∫'}`);
                initializeMatchResources();
                
            } else {
                // –°—Ü–µ–Ω–∞—Ä–∏–π –í: –ù–µ—Ç –†–ü–õ - –æ–±—ã—á–Ω–∞—è –º–æ–Ω–µ—Ç–∫–∞ 50/50
                const isPlayerStart = Math.random() < 0.5;
                matchStarter = isPlayerStart ? 'player' : 'enemy';
                isPlayerTurn = isPlayerStart;
                
                console.log(`–ú–∞—Ç—á –Ω–∞—á–∞–ª—Å—è! –ü–µ—Ä–≤—ã–º —Ö–æ–¥–∏—Ç: ${isPlayerStart ? '–ò–≥—Ä–æ–∫' : '–°–æ–ø–µ—Ä–Ω–∏–∫'}`);
                showGameNotification(`–†–∞—É–Ω–¥ 1. –ü–µ—Ä–≤—ã–º —Ö–æ–¥–∏—Ç ${isPlayerStart ? '–ò–≥—Ä–æ–∫' : '–°–æ–ø–µ—Ä–Ω–∏–∫'}!`, 'info');
                initializeMatchResources();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –Ω–∞—á–∞–ª–∞ –º–∞—Ç—á–∞
        function startMatch() {
            cleanUpVisualArtifacts(); // <--- ADD THIS
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä
            if (squadTimerInterval) {
                clearInterval(squadTimerInterval);
                squadTimerInterval = null;
            }
            
            // –£–¥–∞–ª—è–µ–º –≤—Å–µ —Ñ–ª–∞–≥–∏ isNew –∏–∑ –∫–∞—Ä—Ç –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º –º–∞—Ç—á–∞
            myCards = myCards.map(card => {
                const { isNew, ...cardWithoutIsNew } = card;
                return cardWithoutIsNew;
            });
            
            // –°–∫—Ä—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω —Å–æ—Å—Ç–∞–≤–∞ –∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–≥—Ä–æ–≤–æ–µ –ø–æ–ª–µ
            showScreen(gameScreen, squadScreen);
            
            // –ó–∞–ø—É—Å–∫–∞–µ–º –∏–≥—Ä—É
            setTimeout(function() {
                startGame();
            }, 320);
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–∑–∏—Ü–∏–∏ —ç–ª–µ–º–µ–Ω—Ç–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ viewport
        function getElementPosition(element) {
            const rect = element.getBoundingClientRect();
            return {
                x: rect.left + rect.width / 2,
                y: rect.top + rect.height / 2,
                width: rect.width,
                height: rect.height
            };
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ—Å—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∏–≥—Ä–æ–∫–∞ (SAFE MODE)
        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ—Å—á–µ—Ç–∞ –æ—á–∫–æ–≤ –∏–≥—Ä–æ–∫–∞ (FIXED: One-to-One Mapping & Tactics Support)
        function calculatePlayerScore() {
            try {
                let score = 0;
                const rows = ['attack', 'midfield', 'defense'];
                
                // –°–µ—Ç –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —É–∂–µ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö DOM-—ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —ç—Ç–æ–º —Ü–∏–∫–ª–µ
                // –≠—Ç–æ –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥–≤–æ–π–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤ (–∫–æ–≥–¥–∞ –æ–¥–Ω–∞ –∫–∞—Ä—Ç–∞ –æ–±–Ω–æ–≤–ª—è–µ—Ç –≤—Å–µ—Ö –∫–ª–æ–Ω–æ–≤)
                const updatedElements = new Set();

                rows.forEach(rowId => {
                    const cardsInRow = playerCardsOnField.filter(card => card.rowId === rowId);
                    
                    const hasCaptain = cardsInRow.some(card => card.cardData.ability === 'captain');
                    const hasSupport = playerTacticsCards.some(card => card.rowId === rowId && card.cardData.ability === 'support');
                    const hasLeader = cardsInRow.some(card => card.cardData.ability === 'leader');
                    
                    // –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã: –†—è–¥ –∏ –°–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏
                    const rowElement = getTargetRow(rowId);
                    const tacticsElement = getTacticsSlot(rowId);

                    cardsInRow.forEach(entry => {
                        const card = entry.cardData;
                        let currentPower = parseInt(card.power);
                        if (isNaN(currentPower)) currentPower = 0;
                        
                        // --- –†–∞—Å—á–µ—Ç —Å–∏–ª—ã ---
                        let finalPower = currentPower;

                        // Heroes AND Dummies are immune to buffs/debuffs
                        if (card.isHero || card.cardtype === 'hero' || card.ability === 'dummy') {
                            score += currentPower;
                            finalPower = currentPower;
                        } else {
                            // Leader
                            if (hasLeader && card.ability !== 'leader') {
                                currentPower += 1;
                            }

                            let multiplier = 1;

                            // Bond
                            if (card.ability === 'bond') {
                                const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                                if (bondCount >= 2) multiplier *= 2;
                            }

                            // Captain / Support
                            let buffActive = false;
                            if (hasCaptain && card.ability !== 'captain') buffActive = true;
                            if (hasSupport) buffActive = true;

                            if (buffActive) multiplier *= 2;

                            finalPower = currentPower * multiplier;
                            score += finalPower;
                        }
                        
                        // --- –í–ò–ó–£–ê–õ–¨–ù–û–ï –û–ë–ù–û–í–õ–ï–ù–ò–ï (Smart Mapping) ---
                        // 1. –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ—Ö –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ (–∏ –≤ —Ä—è–¥—É, –∏ –≤ —Ç–∞–∫—Ç–∏–∫–µ) —Å —Ç–∞–∫–∏–º ID
                        let candidates = [];
                        if (rowElement) {
                            const foundInRow = rowElement.querySelectorAll(`.card-on-field[data-card-id="${card.id}"]`);
                            candidates = [...candidates, ...foundInRow];
                        }
                        if (tacticsElement) {
                            const foundInTactics = tacticsElement.querySelectorAll(`.card-on-field[data-card-id="${card.id}"]`);
                            candidates = [...candidates, ...foundInTactics];
                        }

                        // 2. –ò—â–µ–º –ø–µ—Ä–≤–æ–≥–æ –∫–∞–Ω–¥–∏–¥–∞—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –µ—â–µ –ù–ï –±—ã–ª –æ–±–Ω–æ–≤–ª–µ–Ω –≤ —ç—Ç–æ–º —Ü–∏–∫–ª–µ
                        const targetEl = candidates.find(el => !updatedElements.has(el));

                        // 3. –û–±–Ω–æ–≤–ª—è–µ–º –∏ –ø–æ–º–µ—á–∞–µ–º –∫–∞–∫ "–∑–∞–Ω—è—Ç—ã–π"
                        if (targetEl) {
                            applyBadgeUpdate(targetEl, finalPower);
                            updatedElements.add(targetEl);
                        }
                    });
                });
                return score;
            } catch (error) {
                console.error('Error in calculatePlayerScore:', error);
                return 0;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ—Å—á–µ—Ç–∞ –æ—á–∫–æ–≤ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ (FIXED: One-to-One Mapping & Tactics Support)
        function calculateEnemyScore() {
            try {
                let score = 0;
                const rows = ['attack', 'midfield', 'defense'];
                const updatedElements = new Set(); // –°–µ—Ç –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç –¥—É–±–ª–∏–∫–∞—Ç–æ–≤

                rows.forEach(rowId => {
                    const cardsInRow = enemyCardsOnField.filter(card => card.rowId === rowId);
                    
                    const hasCaptain = cardsInRow.some(card => card.cardData.ability === 'captain');
                    const hasSupport = enemyTacticsCards.some(card => card.rowId === rowId && card.cardData.ability === 'support');
                    const hasLeader = cardsInRow.some(card => card.cardData.ability === 'leader');
                    
                    const rowElement = getEnemyTargetRow(rowId);
                    const tacticsElement = getEnemyTacticsSlot(rowId);

                    cardsInRow.forEach(entry => {
                        const card = entry.cardData;
                        let currentPower = parseInt(card.power);
                        if (isNaN(currentPower)) currentPower = 0;
                        
                        let finalPower = currentPower;

                        // Heroes AND Dummies are immune to buffs/debuffs
                        if (card.isHero || card.cardtype === 'hero' || card.ability === 'dummy') {
                            score += currentPower;
                            finalPower = currentPower;
                        } else {
                            if (hasLeader && card.ability !== 'leader') {
                                currentPower += 1;
                            }

                            let multiplier = 1;

                            if (card.ability === 'bond') {
                                const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                                if (bondCount >= 2) multiplier *= 2;
                            }

                            let buffActive = false;
                            if (hasCaptain && card.ability !== 'captain') buffActive = true;
                            if (hasSupport) buffActive = true;

                            if (buffActive) multiplier *= 2;

                            finalPower = currentPower * multiplier;
                            score += finalPower;
                        }
                        
                        // --- Smart Mapping ---
                        let candidates = [];
                        if (rowElement) {
                            const foundInRow = rowElement.querySelectorAll(`.card-on-field[data-card-id="${card.id}"]`);
                            candidates = [...candidates, ...foundInRow];
                        }
                        if (tacticsElement) {
                            const foundInTactics = tacticsElement.querySelectorAll(`.card-on-field[data-card-id="${card.id}"]`);
                            candidates = [...candidates, ...foundInTactics];
                        }

                        const targetEl = candidates.find(el => !updatedElements.has(el));

                        if (targetEl) {
                            applyBadgeUpdate(targetEl, finalPower);
                            updatedElements.add(targetEl);
                        }
                    });
                });
                
                score += enemyCoachBonusScore;
                return score;
            } catch (error) {
                console.error('Error in calculateEnemyScore:', error);
                return 0;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∞—Å—Å–µ—Ç–æ–≤ –∫–æ–º–∞–Ω–¥ (–∫–æ–ª–æ–¥—ã, –æ—Ç–±–æ–∏, —Ä—É–±–∞—à–∫–∏ –∫–∞—Ä—Ç)
        function updateTeamAssets() {
            try {
                // –ü–æ–ª—É—á–∞–µ–º –∞—Å—Å–µ—Ç—ã –¥–ª—è –∏–≥—Ä–æ–∫–∞ –∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
                const playerAssets = teamAssets[playerTeamKey];
                const enemyAssets = teamAssets[enemyTeamKey];
                
                if (!playerAssets || !enemyAssets) {
                    console.warn('–ê—Å—Å–µ—Ç—ã –¥–ª—è –∫–æ–º–∞–Ω–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã');
                    return;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–æ–¥—É –∏ –æ—Ç–±–æ–π –∏–≥—Ä–æ–∫–∞
                if (playerDeck) {
                    playerDeck.style.backgroundImage = `url('${playerAssets.deck}')`;
                }
                if (playerGraveyard) {
                    playerGraveyard.style.backgroundImage = `url('${playerAssets.graveyard}')`;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–ª–æ–¥—É –∏ –æ—Ç–±–æ–π —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
                if (enemyDeck) {
                    enemyDeck.style.backgroundImage = `url('${enemyAssets.deck}')`;
                }
                if (enemyGraveyard) {
                    enemyGraveyard.style.backgroundImage = `url('${enemyAssets.graveyard}')`;
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ä—É–±–∞—à–∫–∏ –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ (–µ—Å–ª–∏ –æ–Ω–∏ —É–∂–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω—ã)
                if (opponentHand) {
                    const cardBacks = opponentHand.querySelectorAll('.card-back');
                    cardBacks.forEach(cardBack => {
                        cardBack.style.backgroundImage = `url('${enemyAssets.cardBack}')`;
                    });
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ä—É–±–∞—à–∫–∏ –∫–∞—Ä—Ç –≤ enemyCardsContainer (–µ—Å–ª–∏ –æ–Ω–∏ —É–∂–µ –æ—Ç—Ä–∏—Å–æ–≤–∞–Ω—ã)
                if (enemyCardsContainer) {
                    const enemyCardBacks = enemyCardsContainer.querySelectorAll('.enemy-card-back');
                    enemyCardBacks.forEach(cardBack => {
                        cardBack.style.backgroundImage = `url('${enemyAssets.cardBack}')`;
                        cardBack.style.backgroundSize = 'cover';
                        cardBack.style.backgroundRepeat = 'no-repeat';
                        cardBack.style.backgroundPosition = 'center';
                    });
                }
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ü–≤–µ—Ç —Å—á–µ—Ç—á–∏–∫–æ–≤ –∫–æ–ª–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ—Ä–∞–∫—Ü–∏–∏
                // –î–ª—è –†–ü–õ (—Ç–µ–º–Ω–∞—è —Ä—É–±–∞—à–∫–∞) - –±–µ–ª—ã–π —Ü–≤–µ—Ç, –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö - —á–µ—Ä–Ω—ã–π
                if (playerDeckCounter) {
                    if (playerTeamKey === 'allRPLCards') {
                        playerDeckCounter.style.color = '#ffffff';
                    } else {
                        playerDeckCounter.style.color = '#000000';
                    }
                }
                
                if (enemyDeckCounter) {
                    if (enemyTeamKey === 'allRPLCards') {
                        enemyDeckCounter.style.color = '#ffffff';
                    } else {
                        enemyDeckCounter.style.color = '#000000';
                    }
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∞—Å—Å–µ—Ç–æ–≤ –∫–æ–º–∞–Ω–¥:', error);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ª–æ–≥–æ—Ç–∏–ø–æ–≤ –∫–æ–º–∞–Ω–¥
        function updateTeamLogos() {
            try {
                // –õ–æ–≥–æ—Ç–∏–ø –∏–≥—Ä–æ–∫–∞ (–ª–µ–≤—ã–π)
                const playerLogo = document.getElementById('player-team-logo');
                if (playerLogo && teamLogos[playerTeamKey]) {
                    // –î–ª—è —Ç–∞–±–ª–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–º–Ω—É—é –≤–µ—Ä—Å–∏—é (–±–µ–ª—ã–π –ª–æ–≥–æ—Ç–∏–ø)
                    playerLogo.src = teamLogos[playerTeamKey].dark;
                    playerLogo.alt = playerTeamKey === 'allSpartakCards' ? 'Spartak' : 'Football Stars';
                }
                
                // –õ–æ–≥–æ—Ç–∏–ø —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ (–ø—Ä–∞–≤—ã–π)
                const enemyLogo = document.getElementById('enemy-team-logo');
                if (enemyLogo && teamLogos[enemyTeamKey]) {
                    // –î–ª—è —Ç–∞–±–ª–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–º–Ω—É—é –≤–µ—Ä—Å–∏—é (–±–µ–ª—ã–π –ª–æ–≥–æ—Ç–∏–ø)
                    enemyLogo.src = teamLogos[enemyTeamKey].dark;
                    enemyLogo.alt = enemyTeamKey === 'allSpartakCards' ? 'Spartak' : 'Football Stars';
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ª–æ–≥–æ—Ç–∏–ø–æ–≤ –∫–æ–º–∞–Ω–¥:', error);
            }
        }
        
        function updatePlayerScore() {
            try {
                console.log('–°—á–∏—Ç–∞–µ–º –æ—á–∫–∏ –∏–≥—Ä–æ–∫–∞...');
                const oldScore = totalScore;
                totalScore = calculatePlayerScore();
                if (currentScorePlayer) {
                    currentScorePlayer.textContent = totalScore;
                    // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –≤—Å–ø—ã—à–∫–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
                    if (oldScore !== totalScore) {
                        currentScorePlayer.classList.add('flash');
                        setTimeout(() => {
                            currentScorePlayer.classList.remove('flash');
                        }, 400);
                    }
                }
                console.log('–û—á–∫–∏ –∏–≥—Ä–æ–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã:', totalScore);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ updatePlayerScore:', error);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—á–µ—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –æ—Ç–±–æ—è (–∞–∫—Ç–∏–≤–µ–Ω/–Ω–µ–∞–∫—Ç–∏–≤–µ–Ω)
        function updateGraveyardVisuals() {
            const pSlot = document.getElementById('playerGraveyard');
            if (pSlot) {
                if (playerGraveyardCards.length === 0) {
                    pSlot.classList.add('graveyard-empty');
                } else {
                    pSlot.classList.remove('graveyard-empty');
                }
            }

            const eSlot = document.getElementById('enemyGraveyard');
            if (eSlot) {
                if (enemyGraveyardCards.length === 0) {
                    eSlot.classList.add('graveyard-empty');
                } else {
                    eSlot.classList.remove('graveyard-empty');
                }
            }
        }

        function updateEnemyScore() {
            try {
                console.log('–°—á–∏—Ç–∞–µ–º –æ—á–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞...');
                const oldScore = enemyScore;
                enemyScore = calculateEnemyScore();
                if (currentScoreEnemy) {
                    currentScoreEnemy.textContent = enemyScore;
                    // –î–æ–±–∞–≤–ª—è–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –≤—Å–ø—ã—à–∫–∏ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏
                    if (oldScore !== enemyScore) {
                        currentScoreEnemy.classList.add('flash');
                        setTimeout(() => {
                            currentScoreEnemy.classList.remove('flash');
                        }, 400);
                    }
                }
                console.log('–û—á–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω—ã:', enemyScore);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ updateEnemyScore:', error);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –æ–±—â–µ–≥–æ —Å—á–µ—Ç–∞ –º–∞—Ç—á–∞
        function updateMatchScore() {
            if (matchScore) {
                matchScore.textContent = `${playerMatchWins}:${enemyMatchWins}`;
                matchScore.classList.add('flash');
                setTimeout(() => {
                    matchScore.classList.remove('flash');
                }, 500);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ —Ä—è–¥–∞ –ø–æ –ø–æ–∑–∏—Ü–∏–∏
        function getTargetRow(position) {
            switch(position) {
                case 'attack':
                    return attackRow;
                case 'midfield':
                    return midfieldRow;
                case 'defense':
                    return defenseRow;
                case 'any':
                    // –î–ª—è –∫–∞—Ä—Ç —Å position === 'any' –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null, —Ç–∞–∫ –∫–∞–∫ —Ä—è–¥ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –≤—Ä—É—á–Ω—É—é
                    return null;
                default:
                    return attackRow;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ü–µ–ª–µ–≤–æ–≥–æ —Ä—è–¥–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –ø–æ –ø–æ–∑–∏—Ü–∏–∏
        function getEnemyTargetRow(position) {
            switch(position) {
                case 'attack':
                    return enemyAttackRow;
                case 'midfield':
                    return enemyMidfieldRow;
                case 'defense':
                    return enemyDefenseRow;
                case 'any':
                    // –î–ª—è –∫–∞—Ä—Ç —Å position === 'any' –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null, —Ç–∞–∫ –∫–∞–∫ —Ä—è–¥ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                    return null;
                default:
                    return enemyAttackRow;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ª–æ—Ç–∞ —Ç–∞–∫—Ç–∏–∫–∏ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –ø–æ rowId
        function getEnemyTacticsSlot(rowId) {
            switch(rowId) {
                case 'attack':
                    return enemyAttackTacticsSlot;
                case 'midfield':
                    return enemyMidfieldTacticsSlot;
                case 'defense':
                    return enemyDefenseTacticsSlot;
                default:
                    return null;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –æ—á–∫–æ–≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ä—è–¥–∞ –±–æ—Ç–∞ (—Å —É—á–µ—Ç–æ–º –≤—Å–µ—Ö –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤, –≤–∫–ª—é—á–∞—è support –µ—Å–ª–∏ –æ–Ω —É–∂–µ –µ—Å—Ç—å)
        function getEnemyRowScore(rowId) {
            try {
                const cardsInRow = enemyCardsOnField.filter(card => {
                    return card && card.cardData && card.cardData.rowId === rowId;
                });
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–∞–ø–∏—Ç–∞–Ω–∞ –≤ —Ä—è–¥—É
                const hasCaptain = cardsInRow.some(card => {
                    return card.cardData && card.cardData.ability && card.cardData.ability === 'captain';
                });
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–∞—Ä—Ç –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ç—Ä–∏–±—É–Ω –≤ —Å–ª–æ—Ç–µ —Ç–∞–∫—Ç–∏–∫–∏ —ç—Ç–æ–≥–æ —Ä—è–¥–∞
                const hasSupport = enemyTacticsCards.some(card => {
                    return card && card.cardData && card.rowId === rowId && card.cardData.ability === 'support';
                });
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –ª–∏–¥–µ—Ä–∞ –≤ —Ä—è–¥—É
                const hasLeader = cardsInRow.some(card => {
                    return card.cardData && card.cardData.ability && card.cardData.ability === 'leader';
                });
                
                const bondCards = cardsInRow.filter(card => {
                    return card.cardData && card.cardData.ability && card.cardData.ability === 'bond';
                });
                const hasBondBonus = bondCards.length >= 2;
                
                // –°–æ–∑–¥–∞–µ–º –∫–æ–ø–∏—é –∫–∞—Ä—Ç —Å –±–∞–∑–æ–≤–æ–π —Å–∏–ª–æ–π
                const cardsWithPower = cardsInRow.map(card => {
                    if (!card.cardData || typeof card.cardData.power !== 'number') {
                        return null;
                    }
                    return {
                        cardData: card.cardData,
                        currentPower: card.cardData.power || 0
                    };
                }).filter(card => card !== null);
                
                // --- –õ–û–ì–ò–ö–ê –õ–ò–î–ï–†–ê (+1 –≤—Å–µ–º –±–∞–∑–æ–≤—ã–º, –ö–†–û–ú–ï –õ–ò–î–ï–†–ê) ---
                // –ë–æ–Ω—É—Å +1 –¥–∞–µ—Ç—Å—è –≤—Å–µ–º –±–∞–∑–æ–≤—ã–º –∫–∞—Ä—Ç–∞–º, –∫—Ä–æ–º–µ —Å–∞–º–æ–≥–æ –ª–∏–¥–µ—Ä–∞
                // –î–û –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –º–Ω–æ–∂–∏—Ç–µ–ª–µ–π
                if (hasLeader) {
                    cardsWithPower.forEach(card => {
                        // –ì–µ—Ä–æ–∏ –Ω–µ –ø–æ–ª—É—á–∞—é—Ç –±–æ–Ω—É—Å –ª–∏–¥–µ—Ä–∞, –∏ —Å–∞–º –ª–∏–¥–µ—Ä —Ç–æ–∂–µ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç
                        if (!card.cardData.isHero && card.cardData.cardtype !== 'hero' && card.cardData.ability !== 'leader') {
                            card.currentPower += 1;
                        }
                    });
                }
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã
                if (hasBondBonus) {
                    cardsWithPower.forEach(card => {
                        if (card.cardData.ability === 'bond') {
                            card.currentPower *= 2;
                        }
                    });
                }
                
                if (hasCaptain) {
                    cardsWithPower.forEach(card => {
                        const isCaptain = card.cardData.ability === 'captain';
                        const cardType = card.cardData.cardtype;
                        
                        if (!isCaptain && cardType === 'base') {
                            card.currentPower *= 2;
                        }
                    });
                }
                
                if (hasSupport) {
                    cardsWithPower.forEach(card => {
                        card.currentPower *= 2;
                    });
                }
                
                // –°—É–º–º–∏—Ä—É–µ–º –æ—á–∫–∏ —Ä—è–¥–∞
                let rowScore = 0;
                cardsWithPower.forEach(card => {
                    rowScore += card.currentPower;
                });
                
                return rowScore;
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ getEnemyRowScore:', error);
                return 0;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—á–µ—Ç–∞ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª–∞ —Ä—è–¥–∞ —Å —É—á–µ—Ç–æ–º –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ
        function calculateRowPotential(rowId) {
            try {
                // 1. –¢–µ–∫—É—â–∏–µ –æ—á–∫–∏ –≤ —Ä—è–¥—É (—É–∂–µ –≤—ã–ª–æ–∂–µ–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã)
                const currentScore = getEnemyRowScore(rowId);
                
                // 2. –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ä—Ç—ã –≤ —Ä—É–∫–µ –±–æ—Ç–∞ (–Ω–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–µ)
                const availableCardsInHand = enemyCards.filter(card => !card.used);
                
                // 3. –§–∏–ª—å—Ç—Ä—É–µ–º –∫–∞—Ä—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Ä–∞–∑–º–µ—â–µ–Ω—ã –≤ —ç—Ç–æ–º —Ä—è–¥—É
                // –ö–∞—Ä—Ç–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–º–µ—â–µ–Ω–∞ –≤ —ç—Ç–æ–º —Ä—è–¥—É, –µ—Å–ª–∏:
                // - position === rowId (—Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ)
                // - position === 'any' (–º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–º–µ—â–µ–Ω–∞ –≤ –ª—é–±–æ–º —Ä—è–¥—É)
                const cardsForThisRow = availableCardsInHand.filter(card => {
                    return card.position === rowId || card.position === 'any';
                });
                
                // 4. –°—É–º–º–∞—Ä–Ω–∞—è —Å–∏–ª–∞ –∫–∞—Ä—Ç —Ç–æ–≥–æ –∂–µ —Ç–∏–ø–∞ –≤ —Ä—É–∫–µ
                // –ò—Å–∫–ª—é—á–∞–µ–º —à–ø–∏–æ–Ω–æ–≤ –∏ support –∫–∞—Ä—Ç—ã (–æ–Ω–∏ –Ω–µ –¥–∞—é—Ç –æ—á–∫–∏ –≤ —Ä—è–¥—É)
                let handPowerSum = 0;
                cardsForThisRow.forEach(card => {
                    if (card.ability !== 'spy' && card.ability !== 'support') {
                        handPowerSum += (card.power || 0);
                    }
                });
                
                // 5. –ü–æ—Ç–µ–Ω—Ü–∏–∞–ª = –¢–µ–∫—É—â–∏–µ –æ—á–∫–∏ + –°—É–º–º–∞ —Å–∏–ª—ã –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ
                const potential = currentScore + handPowerSum;
                
                return {
                    currentScore: currentScore,
                    handPowerSum: handPowerSum,
                    potential: potential
                };
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ calculateRowPotential:', error);
                return {
                    currentScore: 0,
                    handPowerSum: 0,
                    potential: 0
                };
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ü–µ–Ω–∫–∏ –ª—É—á—à–µ–≥–æ —Ä—è–¥–∞ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –ø–æ–¥–¥–µ—Ä–∂–∫–∏ (support)
        // –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø –í–ï–†–°–ò–Ø: –ò–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç –ì–µ—Ä–æ–µ–≤ (–æ–Ω–∏ –Ω–µ —É—Å–∏–ª–∏–≤–∞—é—Ç—Å—è)
        function evaluateBestSupportRow() {
            try {
                const rows = ['attack', 'midfield', 'defense'];
                let bestRow = 'attack'; 
                let maxBuffablePower = -1;

                rows.forEach(rowId => {
                    // 1. –ü–†–û–í–ï–†–ö–ê: –ó–∞–Ω—è—Ç –ª–∏ —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏?
                    const isSlotOccupied = enemyTacticsCards.some(c => c.rowId === rowId);
                    if (isSlotOccupied) return; 

                    // 2. –°—á–∏—Ç–∞–µ–º –£–°–ò–õ–ò–í–ê–ï–ú–£–Æ —Å–∏–ª—É –Ω–∞ –ø–æ–ª–µ (Buffable Field Power)
                    // –¢–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–µ –∫–∞—Ä—Ç—ã, –ù–ï –ì–ï–†–û–ò
                    const fieldBuffable = enemyCardsOnField.reduce((sum, entry) => {
                        if (entry.rowId !== rowId) return sum;
                        const c = entry.cardData;
                        
                        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ì–µ—Ä–æ–µ–≤
                        if (c.isHero || c.cardtype === 'hero') return sum;
                        
                        // –ë–µ—Ä–µ–º —Ç–µ–∫—É—â—É—é —Å–∏–ª—É (—Å —É—á–µ—Ç–æ–º —É–∂–µ –¥–µ–π—Å—Ç–≤—É—é—â–∏—Ö –±–∞—Ñ–æ–≤, –µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å)
                        // –ù–æ –µ—Å–ª–∏ –±–∞—Ñ—Ñ—ã –º—É–ª—å—Ç–∏–ø–ª–∏–∫–∞—Ç–∏–≤–Ω—ã–µ, –ª—É—á—à–µ –±—Ä–∞—Ç—å –±–∞–∑—É? 
                        // –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –±–µ—Ä–µ–º current power, —Ç–∞–∫ –∫–∞–∫ Support —É–º–Ω–æ–∂–∞–µ—Ç –∏—Ç–æ–≥.
                        // (–•–æ—Ç—è –≤ –ì–≤–∏–Ω—Ç–µ Support –æ–±—ã—á–Ω–æ —É–¥–≤–∞–∏–≤–∞–µ—Ç –±–∞–∑—É/–±–æ–Ω–¥, –Ω–æ —Ç—É—Ç —É –Ω–∞—Å x2 –≤ –∫–æ–Ω—Ü–µ).
                        // –ë–µ–∑–æ–ø–∞—Å–Ω–µ–µ –±—Ä–∞—Ç—å –ø—Ä–æ—Å—Ç–æ (power || 0).
                        return sum + (parseInt(c.power) || 0);
                    }, 0);

                    // 3. –°—á–∏—Ç–∞–µ–º –£–°–ò–õ–ò–í–ê–ï–ú–£–Æ —Å–∏–ª—É –≤ —Ä—É–∫–µ (Buffable Hand Power)
                    // –¢–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–µ –∫–∞—Ä—Ç—ã, –ù–ï –ì–ï–†–û–ò, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥—Ö–æ–¥—è—Ç –≤ —ç—Ç–æ—Ç —Ä—è–¥
                    const handBuffable = enemyCards.reduce((sum, card) => {
                        // –§–∏–ª—å—Ç—Ä—ã –≤–∞–ª–∏–¥–Ω–æ—Å—Ç–∏
                        if (card.used) return sum;
                        if (card.ability === 'spy') return sum;
                        if (card.ability === 'dummy') return sum;
                        if (card.type === 'special') return sum;
                        
                        // –ì–õ–ê–í–ù–û–ï: –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ì–µ—Ä–æ–µ–≤ –≤ —Ä—É–∫–µ
                        if (card.isHero || card.cardtype === 'hero') return sum;
                        
                        // –ü–æ–¥—Ö–æ–¥–∏—Ç –ª–∏ –∫–∞—Ä—Ç–∞ –≤ —ç—Ç–æ—Ç —Ä—è–¥?
                        const fitsRow = (card.position === rowId || card.position === 'any');
                        
                        if (fitsRow) {
                            return sum + (parseInt(card.power) || 0);
                        }
                        return sum;
                    }, 0);

                    // 4. –û–±—â–∏–π –≤–µ—Å (–ü–æ–ª–µ + –†—É–∫–∞) –¥–ª—è –æ–±—ã—á–Ω—ã—Ö –∫–∞—Ä—Ç
                    // Support –¥–∞–µ—Ç –ø—Ä–∏—Ä–æ—Å—Ç —Ä–∞–≤–Ω—ã–π —ç—Ç–æ–π —Å—É–º–º–µ (x -> 2x, –ø—Ä–∏—Ä–æ—Å—Ç = x)
                    const totalBuffable = fieldBuffable + handBuffable;

                    console.log(`AI Support Check [${rowId}]: Non-Hero Field(${fieldBuffable}) + Non-Hero Hand(${handBuffable}) = Valid Target(${totalBuffable})`);

                    // 5. –í—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ
                    if (totalBuffable > maxBuffablePower) {
                        maxBuffablePower = totalBuffable;
                        bestRow = rowId;
                    }
                });
                
                // –¢–∞–π-–±—Ä–µ–π–∫ –¥–ª—è –ø—É—Å—Ç–æ–≥–æ —Å—Ç–æ–ª–∞
                if (maxBuffablePower === 0) {
                     const randomRow = rows[Math.floor(Math.random() * rows.length)];
                     return randomRow;
                }

                console.log(`AI Selected Best Support Row: ${bestRow} (Buffable Power: ${maxBuffablePower})`);
                return bestRow;

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ evaluateBestSupportRow:', error);
                return 'attack';
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –∏–∑ —Ä—É–∫–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–∞ –ø–æ–ª–µ
        async function animateCardTransition(cardData, targetSlot) {
            return new Promise(resolve => {
                // 1. –ò—Å—Ö–æ–¥–Ω–∞—è —Ç–æ—á–∫–∞ (–†—É–∫–∞ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞)
                const handContainer = document.getElementById('opponent-hand');
                if (!handContainer) {
                    console.warn('–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä opponent-hand –Ω–µ –Ω–∞–π–¥–µ–Ω');
                    resolve();
                    return;
                }
                
                // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∫–∞—Ä—Ç—É –∏–ª–∏ —Å–∞–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –µ—Å–ª–∏ –∫–∞—Ä—Ç –Ω–µ—Ç (–∑–∞—â–∏—Ç–∞)
                const cardBack = handContainer.lastElementChild || handContainer; 
                const startRect = cardBack.getBoundingClientRect();

                // 2. –¶–µ–ª–µ–≤–∞—è —Ç–æ—á–∫–∞ (–°–ª–æ—Ç –Ω–∞ –ø–æ–ª–µ)
                const targetRect = targetSlot.getBoundingClientRect();
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —à–∏—Ä–∏–Ω—É –∫–∞—Ä—Ç—ã –¥–ª—è –±–æ—Ç–∞ (–∞–¥–∞–ø—Ç–∏–≤–Ω–æ)
                let fieldCardWidth = 45;
                if (window.innerWidth <= 480) fieldCardWidth = 40;
                if (window.innerWidth <= 360) fieldCardWidth = 35;

                // 3. –°–æ–∑–¥–∞–µ–º –ü—Ä–∏–∑—Ä–∞–∫–∞
                const ghost = document.createElement('div');
                ghost.className = 'ghost-card';
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∏–ª–∏ –ø—Ä–∏–∑—Ä–∞–∫–∞ –≤—Ä—É—á–Ω—É—é, —á—Ç–æ–±—ã –ø–µ—Ä–µ–±–∏—Ç—å CSS –∫–ª–∞—Å—Å—ã –µ—Å–ª–∏ —á—Ç–æ
                Object.assign(ghost.style, {
                    position: 'fixed',
                    zIndex: '9999',
                    width: `${startRect.width}px`,
                    height: `${startRect.height}px`,
                    left: `${startRect.left}px`,
                    top: `${startRect.top}px`,
                    borderRadius: '6px',
                    overflow: 'hidden',
                    boxShadow: '0 4px 8px rgba(0, 0, 0, 0.5)',
                    transition: 'all 0.6s cubic-bezier(0.45, 0, 0.55, 1)', // –ü–ª–∞–≤–Ω–∞—è –∫—Ä–∏–≤–∞—è
                    transformStyle: 'preserve-3d',
                    transform: 'rotateY(0deg)' // –ù–∞—á–∞–ª–æ: —Å–º–æ—Ç—Ä–∏–º –Ω–∞ —Ä—É–±–∞—à–∫—É
                });
                
                // –†—É–±–∞—à–∫–∞ –∫–∞—Ä—Ç—ã (–Ω–∞—á–∞–ª—å–Ω—ã–π –≤–∏–¥)
                ghost.style.background = 'linear-gradient(135deg, #ffffff, #f0f0f0)';
                ghost.style.border = '2px solid #ccc';
                ghost.style.display = 'flex';
                ghost.style.alignItems = 'center';
                ghost.style.justifyContent = 'center';
                ghost.style.fontSize = '24px';
                ghost.style.fontWeight = 'bold';
                ghost.style.color = '#666';
                ghost.textContent = '?';
                
                document.body.appendChild(ghost);

                // –°–∫—Ä—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª –≤ —Ä—É–∫–µ (–≤–∏–∑—É–∞–ª—å–Ω–æ —É–¥–∞–ª—è–µ–º)
                if (handContainer.lastElementChild) {
                    handContainer.lastElementChild.style.opacity = '0';
                }

                // 4. –ó–∞–ø—É—Å–∫ –∞–Ω–∏–º–∞—Ü–∏–∏ (—á–µ—Ä–µ–∑ requestAnimationFrame –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏)
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        // --- –£–ú–ù–´–ô –†–ê–°–ß–ï–¢ –ö–û–û–†–î–ò–ù–ê–¢ ---
                        let targetCenterX = targetRect.left + targetRect.width / 2;
                        const targetCenterY = targetRect.top + targetRect.height / 2;

                        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–æ–π (–ø–æ –∫–ª–∞—Å—Å—É)
                        const isTactics = targetSlot.classList.contains('tactics-slot');

                        if (!isTactics) {
                            const existingCount = targetSlot.querySelectorAll('.card-on-field').length;
                            const comingIndex = existingCount + 1;
                            
                            if (comingIndex % 2 === 0) {
                                targetCenterX += (existingCount * fieldCardWidth) / 2;
                            }
                        }
                        
                        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –ø—Ä–∏–∑—Ä–∞–∫ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –µ–≥–æ —Ä–∞–∑–º–µ—Ä–æ–≤
                        const endLeft = targetCenterX - (startRect.width / 2);
                        const endTop = targetCenterY - (startRect.height / 2);
                        // -----------------------------

                        // --- –°–ê–ú–û–ï –í–ê–ñ–ù–û–ï: –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–ï–†–ö–ê–õ–¨–ù–û–°–¢–ò ---
                        // –ú—ã –≤—Ä–∞—â–∞–µ–º –Ω–∞ 180 (—á—Ç–æ–±—ã –ø–µ—Ä–µ–≤–µ—Ä–Ω—É—Ç—å), –Ω–æ –¥–æ–±–∞–≤–ª—è–µ–º scaleX(-1), 
                        // —á—Ç–æ–±—ã –ª–∏—Ü–æ –∏–≥—Ä–æ–∫–∞ –Ω–µ –±—ã–ª–æ –æ—Ç–∑–µ—Ä–∫–∞–ª–µ–Ω–Ω—ã–º.
                        ghost.style.transform = 'rotateY(180deg) scaleX(-1)'; 
                        
                        ghost.style.left = `${endLeft}px`;
                        ghost.style.top = `${endTop}px`;
                        
                        // –ú–µ–Ω—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É –Ω–∞ –ø–æ–ª–ø—É—Ç–∏ (200–º—Å) - –ø–æ–∫–∞ –∫–∞—Ä—Ç–∞ –±–æ–∫–æ–º (90deg)
                        setTimeout(() => {
                            ghost.textContent = '';
                            ghost.style.background = `url(${cardData.img}) center/cover no-repeat`;
                            ghost.style.border = 'none';
                        }, 200); // –ß—É—Ç—å —Ä–∞–Ω—å—à–µ —Å–µ—Ä–µ–¥–∏–Ω—ã, –ø–æ–∫–∞ –∫–∞—Ä—Ç–∞ –±–æ–∫–æ–º (90deg)
                    });
                });

                // 5. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ
                setTimeout(() => {
                    ghost.remove();
                    // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç—É –∏–∑ —Ä—É–∫–∏ —Å–æ–≤—Å–µ–º
                    if (handContainer.lastElementChild) {
                        handContainer.lastElementChild.remove();
                    }
                    resolve(); // –ì–æ—Ç–æ–≤–æ
                }, 650); // –ß—É—Ç—å –±–æ–ª—å—à–µ —á–µ–º transition (0.6s)
            });
        }
        
        // Helper function to check if a card can be resurrected
        function isRevivable(card) {
            if (!card) return false; // SAFETY CHECK: Return false if card is null/undefined
            
            // Cannot resurrect Heroes
            if (card.isHero === true || card.cardtype === 'hero') {
                return false;
            }
            
            // Cannot resurrect Medics
            if (card.ability === 'medic') {
                return false;
            }

            // Cannot resurrect Support cards (Tactics)
            if (card.ability === 'support') {
                return false;
            }
            
            // Cannot resurrect special cards (Tactics/Weather/Decoy/Horn/Scorch)
            if (card.type === 'special') {
                return false;
            }
            
            // Default: can be resurrected
            return true;
        }
        
        // AI Helper: Calculate the "Net Profit" of reviving a specific card
        // AI Helper: Calculate the "Net Profit" of reviving a specific card
        function calculateReviveValue(target, context) {
            try {
                if (!target || !context) return 0; // Safety check
                
                const { deckCount, isSurvivalMode, enemyCardsOnField } = context;
                const AVG_CARD_VALUE = 7;
                const CA_BONUS = 3;

                // 1. SPY
                if (target.ability === 'spy') {
                    if (deckCount === 0) return -target.power;
                    let drawValue = (AVG_CARD_VALUE * 2);
                    let strategicValue = isSurvivalMode ? -5 : CA_BONUS; 
                    return drawValue - (target.power || 0) + strategicValue;
                }

                // 2. BOND
                if (target.ability === 'bond') {
                    const rowId = target.position === 'any' ? 'attack' : target.position;
                    // Safe check for enemyCardsOnField
                    const field = enemyCardsOnField || [];
                    const hasPartner = field.some(c => c && c.cardData && c.cardData.ability === 'bond' && c.rowId === rowId);
                    
                    if (hasPartner) {
                        return (target.power || 0) * 3;
                    }
                }

                return target.power || 0;
            } catch (e) {
                return target.power || 0; // Fallback to raw power
            }
        }
        
        // Function to handle AI playing a Medic card
        // Function to handle AI playing a Medic card
        async function aiPlayMedic(medicCard) {
            try {
                // 1. CRITICAL SAFETY CHECK: Empty Graveyard
                if (!enemyGraveyardCards || enemyGraveyardCards.length === 0) {
                    console.log("AI Medic: Graveyard is empty. Nothing to resurrect.");
                    showGameNotification("–ë–æ—Ç —Å—ã–≥—Ä–∞–ª –º–µ–¥–∏–∫–∞, –Ω–æ –≤–æ—Å–∫—Ä–µ—à–∞—Ç—å –Ω–µ–∫–æ–≥–æ.", 'info');
                    return false; // Exit immediately
                }

                // Check enemy graveyard for valid targets
                const validTargets = enemyGraveyardCards.filter(card => isRevivable(card));
                
                if (validTargets.length === 0) {
                    console.log("AI Medic: No VALID targets in graveyard (only heroes/medics).");
                    return false;
                }
                
                // Prepare Context
                const context = {
                    deckCount: getEnemyDeckCount(),
                    isSurvivalMode: (playerPassed && enemyScore < totalScore), // Simple check
                    enemyCardsOnField: enemyCardsOnField
                };

                // Sort by Calculated Value (Descending)
                validTargets.sort((a, b) => {
                    const scoreA = calculateReviveValue(a, context);
                    const scoreB = calculateReviveValue(b, context);
                    return scoreB - scoreA;
                });
                
                // Pick the best target
                const targetCard = validTargets[0];
                
                // Remove from graveyard
                const targetIndex = enemyGraveyardCards.findIndex(card => card.id === targetCard.id);
                if (targetIndex !== -1) {
                    enemyGraveyardCards.splice(targetIndex, 1);
                }
                updateGraveyardVisuals();
                
                // Logic for Spy (Goes to Player's field) vs Normal Unit (Goes to Enemy's field)
                const isSpy = targetCard.ability === 'spy';
                
                let rowId = targetCard.position;
                if (!rowId || rowId === 'any') rowId = 'attack';
                
                // Determine Target Side and Arrays
                let targetRow, targetList;
                if (isSpy) {
                    targetRow = getTargetRow(rowId); // Goes to Player's side
                    targetList = playerCardsOnField;
                } else {
                    targetRow = getEnemyTargetRow(rowId); // Goes to Enemy's side
                    targetList = enemyCardsOnField;
                }
                
                // Create field card element
                const fieldCard = document.createElement('div');
                fieldCard.className = 'card-on-field';
                fieldCard.style.opacity = '0';
                
                if (targetCard.isHero || targetCard.cardtype === 'hero') {
                    fieldCard.classList.add('hero');
                }
                
                const fieldCardImage = document.createElement('img');
                const imageSrc = (targetCard.miniImg && targetCard.miniImg !== "") ? targetCard.miniImg : targetCard.img;
                fieldCardImage.src = imageSrc;
                fieldCardImage.alt = targetCard.name;
                fieldCard.appendChild(fieldCardImage);
                
                fieldCard.addEventListener('dragstart', (e) => e.preventDefault());
                fieldCard.setAttribute('data-full-img', targetCard.img);
                fieldCard.setAttribute('data-card-id', targetCard.id);
                addInspectionEvents(fieldCard, targetCard.img);
                addFieldPowerBadge(fieldCard, targetCard);
                
                // Add to logic array
                targetList.push({ cardData: targetCard, rowId });
                
                // Insert into DOM
                insertCardSmartly(targetRow, fieldCard);
                
                // Animation: Fade In
                requestAnimationFrame(() => {
                    fieldCard.style.transition = 'opacity 0.5s ease';
                    fieldCard.style.opacity = '1';
                });
                
                updateRowLayout(targetRow);
                updateEnemyScore();
                updatePlayerScore();
                
                const cardName = targetCard.name || 'Card';
                showGameNotification(`–ë–æ—Ç –≤–æ—Å–∫—Ä–µ—Å–∏–ª: ${cardName}`, 'warning');
                
                // --- TRIGGER ABILITIES ---
                
                // 1. If Spy was resurrected -> Bot draws 2 cards
                if (isSpy) {
                    setTimeout(() => {
                        showGameNotification("–®–ø–∏–æ–Ω! –ë–æ—Ç –±–µ—Ä–µ—Ç 2 –∫–∞—Ä—Ç—ã.", 'error');
                        const newCards = drawCardsFromEnemyDeck(2);
                        if (newCards.length > 0) {
                            enemyCards.push(...newCards);
                            updateEnemyDeckCounter();
                            
                            if (enemyDeck) {
                                animateCardsFromEnemyDeck(newCards, enemyDeck, () => {
                                    renderEnemyHand();
                                    renderOpponentHand();
                                });
                            } else {
                                renderEnemyHand();
                                renderOpponentHand();
                            }
                        }
                    }, 500);
                }
                
                console.log('AI (Medic): Resurrected', cardName);
                return true;
                
            } catch (error) {
                console.error('Error in aiPlayMedic:', error);
                return false;
            }
        }
        
        // Helper: Find the best target for AI Decoy based on Priority
        function getDecoyBestTarget(enemyCardsOnField, enemyGraveyardCards) {
            // Safety check
            if (!enemyCardsOnField || enemyCardsOnField.length === 0) return null;

            // Filter out Heroes (Cannot be decoyed)
            const validTargets = enemyCardsOnField.filter(entry => {
                const c = entry.cardData;
                return !(c.isHero || c.cardtype === 'hero');
            });

            if (validTargets.length === 0) return null;

            // --- PRIORITY 1: SPIES (God Tier) ---
            // If the player played a spy on our side, take it to replay it!
            const spy = validTargets.find(t => t.cardData.ability === 'spy');
            if (spy) {
                console.log("AI Decoy Target: Found Spy (Priority 1)");
                return spy;
            }

            // --- PRIORITY 2: MEDICS (High Tier) ---
            // Only if we have something in graveyard to resurrect
            const hasGraveyardTargets = enemyGraveyardCards && enemyGraveyardCards.some(c => 
                !c.isHero && c.cardtype !== 'hero' && c.ability !== 'medic' && c.type !== 'special'
            );
            
            if (hasGraveyardTargets) {
                const medic = validTargets.find(t => t.cardData.ability === 'medic');
                if (medic) {
                    console.log("AI Decoy Target: Found Medic (Priority 2)");
                    return medic;
                }
            }

            // --- PRIORITY 3: PROVOCATEUR (Tactical Tier) ---
            // Replay scorch if valid
            const provocateur = validTargets.find(t => t.cardData.ability === 'provocateur');
            if (provocateur) {
                // Ideally we check if enemy has targets, but for now just prioritizing the capability is enough
                console.log("AI Decoy Target: Found Provocateur (Priority 3)");
                return provocateur;
            }

            // --- PRIORITY 4: SAVE STRONG UNIT (Survival Tier) ---
            // Only if we have no other options and the unit is valuable (Power >= 8)
            // Sort by power descending
            validTargets.sort((a, b) => (b.cardData.power || 0) - (a.cardData.power || 0));
            const strongest = validTargets[0];
            
            if ((strongest.cardData.power || 0) >= 8) {
                console.log("AI Decoy Target: Saving Strong Unit (Priority 4)");
                return strongest;
            }

            // No good targets found
            return null;
        }
        
        // ================================================================
        // MISSING HELPER FUNCTIONS (PROVOCATEUR & ANIMATIONS)
        // ================================================================

        // 1. Helper: Calculate effective power of a single unit on the field
        function calculateUnitPower(cardEntry, isPlayerSide) {
            const card = cardEntry.cardData;
            const rowId = cardEntry.rowId;
            let power = card.power || 0;

            // Heroes allow no buffs
            if (card.isHero || card.cardtype === 'hero') return power;

            // Context
            const fieldArray = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
            const tacticsArray = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
            const cardsInRow = fieldArray.filter(c => c.rowId === rowId);

            // Leader Bonus (+1 to base units except self)
            const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
            if (hasLeader && card.ability !== 'leader' && card.cardtype === 'base') {
                power += 1;
            }

            // Multipliers
            let multiplier = 1;

            // Bond
            if (card.ability === 'bond') {
                const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                if (bondCount >= 2) multiplier *= 2;
            }

            // Buffs (Captain / Support)
            let buffActive = false;
            const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
            const hasSupport = tacticsArray.some(c => c.rowId === rowId && c.cardData.ability === 'support');

            if ((hasCaptain && card.ability !== 'captain') || hasSupport) buffActive = true;
            if (buffActive) multiplier *= 2;

            return power * multiplier;
        }

        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –±–µ–π–¥–∂–∞ (—á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥)
        function applyBadgeUpdate(cardElement, newPower) {
            if (!cardElement) return;
            
            const badge = cardElement.querySelector('.field-power-badge');
            if (!badge) return;

            // –ß–∏—Ç–∞–µ–º "–ò—Å—Ç–∏–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ" –∏–∑ –∞—Ç—Ä–∏–±—É—Ç–∞
            // –ï—Å–ª–∏ –∞—Ç—Ä–∏–±—É—Ç–∞ –Ω–µ—Ç (–±–∞–≥), —Å—á–∏—Ç–∞–µ–º —á—Ç–æ —Ç–∞–º -999, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –æ–±–Ω–æ–≤–∏—Ç—å
            const attrValue = badge.getAttribute('data-power');
            const oldPower = attrValue === null ? -999 : parseInt(attrValue);

            // –°–¢–†–û–ñ–ê–ô–®–ê–Ø –ü–†–û–í–ï–†–ö–ê: –ï—Å–ª–∏ —Ü–∏—Ñ—Ä—ã —Ä–∞–≤–Ω—ã - –°–¢–û–ü. –ù–∏–∫–∞–∫–∏—Ö –∞–Ω–∏–º–∞—Ü–∏–π.
            if (oldPower === newPower) {
                return; 
            }

            // –ï—Å–ª–∏ –º—ã –∑–¥–µ—Å—å, –∑–Ω–∞—á–∏—Ç –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–µ–∞–ª—å–Ω–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
            // 1. –û–±–Ω–æ–≤–ª—è–µ–º "–ò—Å—Ç–∏–Ω—É"
            badge.setAttribute('data-power', newPower);
            
            // 2. –û–±–Ω–æ–≤–ª—è–µ–º –í–∏–∑—É–∞–ª
            badge.textContent = newPower;

            // --- –ù–û–í–û–ï: –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∫–µ—Ä–Ω–∏–Ω–≥ –¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª ---
            if (newPower >= 20) {
                badge.classList.add('tight-text');
            } else {
                badge.classList.remove('tight-text');
            }
            
            // 3. –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å -999)
            if (oldPower !== -999) {
                badge.classList.remove('badge-increase', 'badge-decrease');
                void badge.offsetWidth; // Reflow hack
                
                if (newPower > oldPower) {
                    badge.classList.add('badge-increase');
                } else if (newPower < oldPower) {
                    badge.classList.add('badge-decrease');
                }
                
                setTimeout(() => {
                    badge.classList.remove('badge-increase', 'badge-decrease');
                }, 500);
            }
        }

        // 2. Helper: Animates a card flying to graveyard with Safety Timeout
        function flyCardToGraveyard(cardElement, graveyardElement, onComplete) {
            if (!cardElement || !graveyardElement) {
                if (onComplete) onComplete();
                return;
            }

            const rect = cardElement.getBoundingClientRect();
            
            // Placeholder to prevent layout jump
            const placeholder = document.createElement('div');
            placeholder.style.width = `${rect.width}px`;
            placeholder.style.height = `${rect.height}px`;
            placeholder.style.margin = getComputedStyle(cardElement).margin;
            if (cardElement.parentNode) cardElement.parentNode.insertBefore(placeholder, cardElement);

            // Fixed positioning for flight
            cardElement.style.position = 'fixed';
            cardElement.style.top = `${rect.top}px`;
            cardElement.style.left = `${rect.left}px`;
            cardElement.style.width = `${rect.width}px`;
            cardElement.style.height = `${rect.height}px`;
            cardElement.style.zIndex = '9999';
            cardElement.style.pointerEvents = 'none';
            cardElement.style.transition = 'all 0.6s ease-in-out';

            // Destination
            const graveRect = graveyardElement.getBoundingClientRect();
            const destTop = graveRect.top + (graveRect.height / 2) - (rect.height / 2);
            const destLeft = graveRect.left + (graveRect.width / 2) - (rect.width / 2);

            // Trigger Animation
            void cardElement.offsetWidth; // Force reflow
            setTimeout(() => {
                cardElement.style.top = `${destTop}px`;
                cardElement.style.left = `${destLeft}px`;
                cardElement.style.transform = 'scale(0.2) rotate(360deg)';
                cardElement.style.opacity = '0';
            }, 10);

            // Cleanup
            let finished = false;
            const finishAnimation = () => {
                if (finished) return;
                finished = true;
                if (cardElement && cardElement.parentNode) cardElement.remove();
                if (placeholder && placeholder.parentNode) placeholder.remove();
                if (onComplete) onComplete();
            };

            cardElement.addEventListener('transitionend', finishAnimation);
            setTimeout(finishAnimation, 700); // Safety fallback
        }

        // 3. Ability: Provocateur (Destroys strongest unit in the mirror row)
        async function executeProvocateur(attackerCard, rowId, isPlayerAttacker) {
            console.log(`Provocateur triggered by ${isPlayerAttacker ? 'Player' : 'AI'} in row ${rowId}`);

            try {
                // Determine Targets based on who is attacking
                const targetList = isPlayerAttacker ? enemyCardsOnField : playerCardsOnField;
                const graveyardTarget = isPlayerAttacker ? enemyGraveyard : playerGraveyard;
                const graveyardArray = isPlayerAttacker ? enemyGraveyardCards : playerGraveyardCards;
                const isTargetPlayerSide = !isPlayerAttacker; // For calculating power

                // 1. Find Valid Targets in Mirror Row (No Heroes)
                const validTargets = targetList.filter(entry => {
                    const c = entry.cardData;
                    return entry.rowId === rowId && !(c.isHero || c.cardtype === 'hero');
                });

                if (validTargets.length === 0) {
                    showGameNotification("–ü—Ä–æ–≤–æ–∫–∞—Ç–æ—Ä: –ù–µ—Ç —Ü–µ–ª–µ–π –¥–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è", "info");
                    return;
                }

                // 2. Calculate Effective Power & Find Victims
                const targetsWithPower = validTargets.map(t => ({
                    entry: t,
                    effectivePower: calculateUnitPower(t, isTargetPlayerSide)
                }));

                const maxPower = Math.max(...targetsWithPower.map(t => t.effectivePower));
                const victims = targetsWithPower
                    .filter(t => t.effectivePower === maxPower)
                    .map(t => t.entry);

                if (victims.length === 0) return;

                // Generic notification (handles multiple kills cleanly)
                showGameNotification("–ü—Ä–æ–≤–æ–∫–∞—Ç–æ—Ä —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç —Å–∏–ª—å–Ω–µ–π—à–∏–µ –æ—Ç—Ä—è–¥—ã!", "error");

                // 3. Process Victims (Remove & Animate)
                const animationPromises = [];

                for (const victim of victims) {
                    const victimId = victim.cardData.id;

                    // Remove from Logic Arrays
                    if (isPlayerAttacker) {
                        const idx = enemyCardsOnField.findIndex(c => c.cardData.id === victimId);
                        if (idx !== -1) enemyCardsOnField.splice(idx, 1);
                    } else {
                        const idx = playerCardsOnField.findIndex(c => c.cardData.id === victimId);
                        if (idx !== -1) playerCardsOnField.splice(idx, 1);
                    }
                    graveyardArray.push(victim.cardData);

                    // Find DOM Element
                    let cardElement;
                    if (isPlayerAttacker) {
                        const rowEl = getEnemyTargetRow(rowId);
                        if (rowEl) cardElement = rowEl.querySelector(`[data-card-id="${victimId}"]`);
                    } else {
                        const rowEl = getTargetRow(rowId);
                        if (rowEl) cardElement = rowEl.querySelector(`[data-card-id="${victimId}"]`);
                    }

                    // Start Animation
                    if (cardElement && graveyardTarget) {
                        animationPromises.push(new Promise(resolve => {
                            flyCardToGraveyard(cardElement, graveyardTarget, resolve);
                        }));
                    }
                }

                // 4. Wait for animations
                if (animationPromises.length > 0) {
                    await Promise.race([
                        Promise.all(animationPromises),
                        new Promise(r => setTimeout(r, 1000))
                    ]);
                }

                // 5. Update Layouts
                if (isPlayerAttacker) {
                    const r = getEnemyTargetRow(rowId);
                    if (r) updateRowLayout(r);
                } else {
                    const r = getTargetRow(rowId);
                    if (r) updateRowLayout(r);
                }

            } catch (error) {
                console.error("Provocateur Error:", error);
            } finally {
                // 6. Always update scores
                updateGraveyardVisuals();
                updatePlayerScore();
                updateEnemyScore();
            }
        }
        
        // 4. Ability: RedCard (Destroys strongest units on field, identical to Klopp)
        async function executeRedCard(cardData, isPlayerAttacker) {
            console.log(`RedCard triggered by ${isPlayerAttacker ? 'Player' : 'AI'}`);
            
            try {
                // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤ –∂–µ—Ä—Ç–≤ –ø–µ—Ä–µ–¥ –Ω–æ–≤–æ–π –∞–∫—Ç–∏–≤–∞—Ü–∏–µ–π
                lastKloppVictims = [];
                kloppOpportunityMissed = false;
                
                // 1. –°–±–æ—Ä –∫–∞–Ω–¥–∏–¥–∞—Ç–æ–≤ (—Ç–æ–ª—å–∫–æ –æ–±—ã—á–Ω—ã–µ –∫–∞—Ä—Ç—ã, –Ω–µ –≥–µ—Ä–æ–∏)
                const allCandidates = [];
                
                const processCards = (cardsArray, isPlayerSide) => {
                    cardsArray.forEach(entry => {
                        const card = entry.cardData;
                        const rowId = entry.rowId;
                        if (card.isHero || card.cardtype === 'hero') return;
                        
                        let power = card.power || 0;
                        const currentField = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                        const currentTactics = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
                        const cardsInRow = currentField.filter(c => c.rowId === rowId);
                        
                        const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                        if (hasLeader && card.ability !== 'leader') power += 1;
                        
                        let multiplier = 1;
                        if (card.ability === 'bond' && cardsInRow.filter(c => c.cardData.ability === 'bond').length >= 2) multiplier *= 2;
                        
                        let buffActive = false;
                        const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                        const hasSupport = currentTactics.some(c => c.rowId === rowId && c.cardData.ability === 'support');
                        if ((hasCaptain && card.ability !== 'captain') || hasSupport) buffActive = true;
                        if (buffActive) multiplier *= 2;
                        
                        allCandidates.push({ entry, isPlayer: isPlayerSide, effectivePower: power * multiplier });
                    });
                };
                
                processCards(playerCardsOnField, true);
                processCards(enemyCardsOnField, false);
                
                // –ï—Å–ª–∏ —Ü–µ–ª–µ–π –Ω–µ—Ç –≤–æ–æ–±—â–µ
                if (allCandidates.length === 0) {
                    showGameNotification("–ù–µ—Ç —Ü–µ–ª–µ–π –¥–ª—è –ö—Ä–∞—Å–Ω–æ–π –∫–∞—Ä—Ç–æ—á–∫–∏", 'warning');
                    return;
                }
                
                const maxPower = Math.max(...allCandidates.map(c => c.effectivePower));
                const strongestCards = allCandidates.filter(c => c.effectivePower === maxPower);
                
                // –ï—Å–ª–∏ –ø–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ —Ü–µ–ª–µ–π –Ω–µ—Ç
                if (strongestCards.length === 0) {
                    return;
                }
                
                // 2. –£–¥–∞–ª–µ–Ω–∏–µ –∫–∞—Ä—Ç
                let removedCount = 0;
                const totalCards = strongestCards.length;
                
                showGameNotification(`–ö—Ä–∞—Å–Ω–∞—è –∫–∞—Ä—Ç–æ—á–∫–∞ —É–¥–∞–ª—è–µ—Ç —Å–∏–ª—å–Ω–µ–π—à–∏—Ö! (–°–∏–ª–∞: ${maxPower})`, 'error');
                
                strongestCards.forEach((candidate, index) => {
                    const { cardData } = candidate.entry;
                    const { rowId } = candidate.entry;
                    
                    // CRITICAL FIX: Do NOT push to lastKloppVictims.
                    // RedCard is a base unit ability, Carcedo cannot counter it.
                    // lastKloppVictims.push({...}); <--- REMOVED

                    // Determine DOM elements
                    let row, cardElement;
                    if (candidate.isPlayer) {
                        row = getTargetRow(rowId);
                        if (row) cardElement = row.querySelector(`[data-card-id="${cardData.id}"]`);
                        if (!cardElement) {
                             const tSlot = getTacticsSlot(rowId);
                             if (tSlot) cardElement = tSlot.querySelector(`[data-card-id="${cardData.id}"]`);
                        }
                    } else {
                        row = getEnemyTargetRow(rowId);
                        if (row) cardElement = row.querySelector(`[data-card-id="${cardData.id}"]`);
                        if (!cardElement) {
                             const tSlot = getEnemyTacticsSlot(rowId);
                             if (tSlot) cardElement = tSlot.querySelector(`[data-card-id="${cardData.id}"]`);
                        }
                    }

                    // Remove from Logic Arrays
                    if (candidate.isPlayer) {
                        playerCardsOnField = playerCardsOnField.filter(c => c.cardData.id !== cardData.id);
                        playerTacticsCards = playerTacticsCards.filter(c => c.cardData.id !== cardData.id);
                        playerGraveyardCards.push(cardData);
                    } else {
                        enemyCardsOnField = enemyCardsOnField.filter(c => c.cardData.id !== cardData.id);
                        enemyTacticsCards = enemyTacticsCards.filter(c => c.cardData.id !== cardData.id);
                        enemyGraveyardCards.push(cardData);
                    }
                    updateGraveyardVisuals();

                    // Animation
                    const graveyard = candidate.isPlayer ? playerGraveyard : enemyGraveyard;
                    
                    if (cardElement && graveyard) {
                        setTimeout(() => {
                            animateCardToGraveyard(cardElement, graveyard, () => {
                                if (cardElement.parentNode) cardElement.remove();
                                if (row) updateRowLayout(row);
                                removedCount++;
                                if (removedCount === totalCards) {
                                    updatePlayerScore();
                                    updateEnemyScore();
                                }
                            });
                        }, index * 200);
                    } else {
                        removedCount++;
                    }
                });
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –æ—á–∫–∏ –ø–æ—Å–ª–µ –≤—Å–µ—Ö –∞–Ω–∏–º–∞—Ü–∏–π
                setTimeout(() => {
                    updatePlayerScore();
                    updateEnemyScore();
                }, (totalCards * 200) + 800);
                
            } catch (error) {
                console.error("RedCard Error:", error);
            }
        }
        // ================================================================
        
        // --- GLOBAL TURN SWITCHER HELPER ---
        function handleTurnSwitch() {
            // Update UI State
            updatePassButtonState(); 
            
            // 1. Check if Round Ended immediately
            checkRoundEndCondition();
            if (isProcessingRoundEnd) return;

            // 2. Decide who goes next
            if (playerPassed) {
                // Player passed. Bot must continue playing (Solitaire Mode).
                // The Bot's logic (Phase 2) will decide whether to Play or Pass next.
                console.log("Turn Switch: Player passed -> Bot continues.");
                setTimeout(enemyTurn, 1000);
            } else {
                // Player is active. Hand over control.
                console.log("Turn Switch: Handing over to Player.");
                isPlayerTurn = true;
                updatePassButtonState();
                showGameNotification("–í–∞—à —Ö–æ–¥!", 'info');
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Ö–æ–¥–∞ –±–æ—Ç–∞
        // –§—É–Ω–∫—Ü–∏—è —Ö–æ–¥–∞ –±–æ—Ç–∞ (AI)
        async function enemyTurn() {
            console.log("--- –•–û–î –ë–û–¢–ê ---");

            try {
                // FIX: Sanitize hand immediately to prevent crashes later
                enemyCards = enemyCards.filter(c => c && typeof c === 'object'); 

                updateAccordionState();
                updateEnemyScore();
                updatePlayerScore();

                // --- STEP 0: RESOURCE CHECK (ANTI-FREEZE) ---
                // Explicitly filter unused cards
                const actualAvailableCards = enemyCards.filter(c => !c.used);
                // Check global coach state strictly
                const hasActiveCoachResource = currentEnemyCoach && currentEnemyCoach.isUsed === false;

                if (actualAvailableCards.length === 0 && !hasActiveCoachResource) {
                    console.log("AI: Start of turn check - No resources left. Auto-passing.");
                    enemyPassed = true;
                    showGameNotification("–£ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã. –ü–∞—Å.", 'info'); // Added Notification
                    
                    // Check if round ends immediately
                    checkRoundEnd();
                    
                    // CRITICAL FIX: Verify if we need to return control to player
                    // Return control if player hasn't passed AND (has cards OR has active Coach)
                    if (!playerPassed && (myCards.length > 0 || (currentPlayerCoach && !currentPlayerCoach.isUsed))) {
                        isPlayerTurn = true;
                        updatePassButtonState();
                    }
                    return; // CRITICAL: Stop execution here
                }
                // ---------------------------------------------

                // ============================================
                // –ë–õ–û–ö –ü–†–û–í–ï–†–ö–ò –ì–ê–†–ê–ù–¢–ò–†–û–í–ê–ù–ù–û–ô –ü–û–ë–ï–î–´
                // ============================================
            // FIX: Don't assume 0 cards means "Player Finished" if Coach is active.
            if (enemyScore > totalScore && (playerPassed === true || myCards.length === 0)) {
                console.log("AI: –ü–æ–±–µ–¥–∞ –≤ —Ä–∞—É–Ω–¥–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–∞ (–ø–æ –∫–∞—Ä—Ç–∞–º). –ü–∞—Å—É—é.");
                enemyPassed = true;
                showGameNotification("–ë–æ—Ç –ø–∞—Å—É–µ—Ç (–ü–æ–±–µ–¥–∞ –≤ —Ä–∞—É–Ω–¥–µ)", 'info');
                
                checkRoundEnd();

                // CRITICAL FIX: If the round didn't end (e.g. Player has active Coach), GIVE TURN BACK.
                // Check if player hasn't passed yet.
                if (!playerPassed) {
                    console.log("AI: Passing control back to Player (Coach opportunity?)");
                    isPlayerTurn = true;
                    updatePassButtonState();
                    
                    // Visual cue if Coach is available
                    const hasActiveCoach = currentPlayerCoach && currentPlayerCoach.isUsed === false;
                    if (hasActiveCoach && myCards.length === 0) {
                        const coachCard = playerDefenseRightSlot?.querySelector('.coach-card');
                        if (coachCard && !coachCard.classList.contains('used')) {
                            coachCard.classList.add('coach-urgent');
                        }
                        showGameNotification("–í–∞—à —Ö–æ–¥! (–¢—Ä–µ–Ω–µ—Ä –∏–ª–∏ –ü–∞—Å)", 'warning');
                    }
                }
                return;
            }

            // ============================================
            // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –ò –õ–û–ì–ò–ö–ê –¢–†–ï–ù–ï–†–ê
            // ============================================
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–µ—Ä–∞
            const enemyCoach = currentEnemyCoach;
            const hasActiveCoach = enemyCoach && !enemyCoach.isUsed;
            
            // –ü–æ–ª—É—á–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–µ –∫–∞—Ä—Ç—ã
            const availableCards = enemyCards.filter(card => !card.used);
            
            // –ï—Å–ª–∏ –∫–∞—Ä—Ç –Ω–µ—Ç –∏ —Ç—Ä–µ–Ω–µ—Ä–∞ –Ω–µ—Ç -> –ü–ê–°–£–ï–ú
            if (availableCards.length === 0 && !hasActiveCoach) {
                console.log("AI: –ö–∞—Ä—Ç—ã –∫–æ–Ω—á–∏–ª–∏—Å—å –∏ —Ç—Ä–µ–Ω–µ—Ä–∞ –Ω–µ—Ç. –ü–∞—Å—É—é.");
                enemyPassed = true;
                checkRoundEnd();
                return;
            }
                        
            // –õ–û–ì–ò–ö–ê –¢–†–ï–ù–ï–†–ê (–ö–æ–Ω—Ç—Ä—É–¥–∞—Ä –ö–∞—Ä—Å–µ–¥–æ –∏–ª–∏ –ê—Ç–∞–∫–∞ –ö–ª–æ–ø–ø–∞)
            if (hasActiveCoach) {
                // –ö–∞—Ä—Å–µ–¥–æ (–ë–æ—Ç)
                if (enemyCoach.ability === 'carcedo') {
                    // 1. Counter Klopp (Existing)
                    if (typeof lastKloppVictims !== 'undefined' && lastKloppVictims.length > 0) {
                        if (Math.random() < 0.15) {
                            console.log("AI (Carcedo): –£–ø—É—Å—Ç–∏–ª –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å!");
                            lastKloppVictims = [];
                        } else {
                            console.log("AI (Carcedo): Countering Klopp!");
                            activateCoachAbility(enemyCoach);
                            return;
                        }
                    }
                    // 2. NEW: Counter Celestini
                    else if (typeof lastCelestiniBuffs !== 'undefined' && lastCelestiniBuffs.length > 0) {
                        // Always counter if score benefit is significant (> 2 points) or it's late game
                        console.log("AI (Carcedo): Countering Celestini Buffs!");
                        activateCoachAbility(enemyCoach);
                        return;
                    }
                }
                // --- –õ–û–ì–ò–ö–ê CELESTINI (–ë–æ—Ç) ---
                else if (enemyCoach.ability === 'celestini') {
                    // 1. Identify valid targets (Base units in Attack row, NO Dummies/Support)
                    const validTargets = enemyCardsOnField.filter(entry => 
                        entry.rowId === 'attack' && 
                        entry.cardData.cardtype === 'base' && 
                        !entry.cardData.isHero && 
                        entry.cardData.cardtype !== 'hero' &&
                        entry.cardData.ability !== 'dummy' &&
                        entry.cardData.ability !== 'support' &&
                        entry.cardData.type !== 'special'
                    );
                    
                    const potentialGain = validTargets.length * 2;
                    const scoreGap = totalScore - enemyScore;
                    
                    let shouldUseCelestini = false;

                    if (potentialGain >= 6) {
                        shouldUseCelestini = true;
                    }
                    else if (scoreGap > 0 && potentialGain > scoreGap) {
                        shouldUseCelestini = true;
                    }
                    else if (availableCards.length <= 2 && potentialGain >= 4) {
                        shouldUseCelestini = true;
                    }

                    if (shouldUseCelestini) {
                        activateCoachAbility(enemyCoach);
                        return;
                    }
                }
                // –ö–ª–æ–ø–ø / RedCard (–ë–æ—Ç): –§–∏–Ω–∞–ª (–†–µ–∞–ª—å–Ω–∞—è —Å–∏–ª–∞ + Net Profit + Score Flip)
                else if (enemyCoach.ability === 'klopp' || enemyCoach.ability === 'redcard') {
                    let shouldUseKlopp = false;
                    
                    // --- 1. HELPER: –†–∞—Å—á–µ—Ç —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏–ª—ã (–¢–í–û–ô –ö–û–î –í–û–ó–í–†–ê–©–ê–ï–¢–°–Ø) ---
                    const getEffectivePower = (entry, isPlayerSide) => {
                        const card = entry.cardData;
                        const rowId = entry.rowId;
                        let power = card.power || 0;
                        
                        // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –≥–µ—Ä–æ–µ–≤
                        if (card.isHero || card.cardtype === 'hero') return -1;

                        // –ö–æ–Ω—Ç–µ–∫—Å—Ç
                        const fieldArray = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                        const tacticsArray = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
                        const cardsInRow = fieldArray.filter(c => c.rowId === rowId);

                        // Leader Logic (+1 to base units except self)
                        const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                        if (hasLeader && card.ability !== 'leader' && card.cardtype === 'base') {
                            power += 1;
                        }

                        // Multipliers
                        let multiplier = 1;
                        
                        // Bond
                        if (card.ability === 'bond') {
                            const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                            if (bondCount >= 2) multiplier *= 2;
                        }
                        
                        // Buffs (Captain / Support)
                        let buffActive = false;
                        const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                        const hasSupport = tacticsArray.some(c => c.rowId === rowId && c.cardData.ability === 'support');
                        
                        // Captain buffs others, Support buffs all
                        if ((hasCaptain && card.ability !== 'captain') || hasSupport) {
                            buffActive = true;
                        }
                        
                        if (buffActive) multiplier *= 2;
                        
                        return power * multiplier;
                    };
                    // -----------------------------------------------------------

                    // 2. –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö
                    // –°–æ–∑–¥–∞–µ–º –º–∞—Å—Å–∏–≤—ã –æ–±—ä–µ–∫—Ç–æ–≤ { entry, power }
                    const mapToPower = (list, isPlayer) => list
                        .map(c => ({ entry: c, power: getEffectivePower(c, isPlayer) }))
                        .filter(item => item.power > 0); // –£–±–∏—Ä–∞–µ–º –≥–µ—Ä–æ–µ–≤ (-1) –∏ –Ω—É–ª–∏

                    const playerVuls = mapToPower(playerCardsOnField, true);
                    const botVuls = mapToPower(enemyCardsOnField, false);
                    const allVuls = [...playerVuls, ...botVuls];
                    
                    if (allVuls.length > 0) {
                        // 3. –ì–ª–æ–±–∞–ª—å–Ω—ã–π –ú–∞–∫—Å–∏–º—É–º
                        const globalMaxPower = Math.max(...allVuls.map(v => v.power));
                        
                        // 4. –°—á–∏—Ç–∞–µ–º –∂–µ—Ä—Ç–≤—ã
                        const playerVictims = playerVuls.filter(v => v.power === globalMaxPower);
                        const botVictims = botVuls.filter(v => v.power === globalMaxPower);
                        
                        // 5. –ú–∞—Ç–µ–º–∞—Ç–∏–∫–∞ Net Profit
                        const damageToEnemy = playerVictims.reduce((sum, v) => sum + v.power, 0);
                        const damageToSelf = botVictims.reduce((sum, v) => sum + v.power, 0);
                        const netProfit = damageToEnemy - damageToSelf;
                        
                        const scoreGap = totalScore - enemyScore;

                        // 6. –ü—Ä–∏–Ω—è—Ç–∏–µ —Ä–µ—à–µ–Ω–∏—è
                        if (netProfit <= 0) {
                             // Skip (Friendly fire too high or neutral)
                        } 
                        else if (netProfit >= 15) {
                            shouldUseKlopp = true;
                            const abilityName = enemyCoach.ability === 'redcard' ? 'RedCard' : 'Klopp';
                            console.log(`AI (${abilityName}): MASSIVE PROFIT (+${netProfit}). MaxPower: ${globalMaxPower}`);
                        } 
                        else if (scoreGap > 0 && netProfit > scoreGap && netProfit >= 7) {
                            shouldUseKlopp = true;
                            const abilityName = enemyCoach.ability === 'redcard' ? 'RedCard' : 'Klopp';
                            console.log(`AI (${abilityName}): SCORE FLIP (+${netProfit}). Taking the lead!`);
                        } 
                        else if (netProfit >= 8) {
                            const isCriticalMoment = currentRound === 3 || (currentRound === 2 && playerMatchWins === 1);
                            const isLateGame = availableCards.length <= 3;
                            
                            if (isCriticalMoment || isLateGame || scoreGap > 0) {
                                shouldUseKlopp = true;
                                const abilityName = enemyCoach.ability === 'redcard' ? 'RedCard' : 'Klopp';
                                console.log(`AI (${abilityName}): Solid Profit (+${netProfit}). Activating.`);
                            }
                        }
                    }

                    if (shouldUseKlopp) {
                        activateCoachAbility(enemyCoach);
                        return;
                    }
                }
            }
            
            // –ï—Å–ª–∏ –∫–∞—Ä—Ç –Ω–µ—Ç, –∞ —Ç—Ä–µ–Ω–µ—Ä –±—ã–ª (–Ω–æ –º—ã —Ä–µ—à–∏–ª–∏ –µ–≥–æ –Ω–µ —é–∑–∞—Ç—å) -> –ü–ê–°–£–ï–ú
            if (availableCards.length === 0) {
                console.log("AI: –ö–∞—Ä—Ç –Ω–µ—Ç, —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–µ–π –ø–æ–ª–µ–∑–Ω—ã—Ö –Ω–µ—Ç. –ü–∞—Å—É—é.");
                enemyPassed = true;
                showGameNotification("–£ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã. –ü–∞—Å.", 'info'); // VISUAL NOTIFICATION
                
                checkRoundEnd();
                
                // CRITICAL: Explicitly return control to player if round continues
                if (!playerPassed) {
                    isPlayerTurn = true;
                    updatePassButtonState();
                }
                return;
            }
            
            // –ï—Å–ª–∏ –±–æ—Ç –¥–µ–ª–∞–µ—Ç —Ö–æ–¥ –∫–∞—Ä—Ç–æ–π, –æ–Ω —É–ø—É—Å–∫–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∫–æ–Ω—Ç—Ä—É–¥–∞—Ä–∞ –ö–∞—Ä—Å–µ–¥–æ (–µ—Å–ª–∏ –æ–Ω–∞ –±—ã–ª–∞)
            if (typeof lastKloppVictims !== 'undefined' && lastKloppVictims.length > 0) {
                lastKloppVictims = [];
            }
            lastCelestiniBuffs = [];

            // ============================================
            // –§–ê–ó–ê 0: DUMMY (MANNEQUIN) LOGIC
            // ============================================
            const dummyCard = availableCards.find(card => card.ability === 'dummy');
            let dummyWasUsed = false;
            
            if (dummyCard) {
                // Use the Priority Helper to find a target
                const bestTargetEntry = getDecoyBestTarget(enemyCardsOnField, enemyGraveyardCards);

                if (bestTargetEntry) {
                    const targetData = bestTargetEntry.cardData;
                    const targetRowId = bestTargetEntry.rowId;

                    console.log(`AI playing Dummy on: ${targetData.name}`);
                    
                    // Execute the swap
                    await executeEnemyDummySwap(dummyCard, targetData, targetRowId);
                    dummyWasUsed = true;

                    // IMPORTANT: After using Dummy, the turn is technically over (Dummy played).
                    // We must return control to the player or end the turn logic here.
                    
                    // Update UI
                    updateAccordionState();
                    updateEnemyScore();
                    updatePlayerScore();
                    
                    // Hand control back... or continue if player passed
                    showGameNotification("–ë–æ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –ß—É—á–µ–ª–æ", 'warning');
                    setTimeout(() => {
                        // CRITICAL FIX: If player passed, AI must go again immediately.
                        if (playerPassed) {
                            console.log("AI used Dummy, Player passed -> AI goes again.");
                            enemyTurn();
                        } else {
                            isPlayerTurn = true;
                            updatePassButtonState();
                        }
                    }, 1500);
                    
                    return; // EXIT current execution loop
                }
            }

            // ============================================
            // –§–ê–ó–ê 1: MUST-PLAY CHECK (SPIES)
            // ============================================
            // –§–∏–ª—å—Ç—Ä—É–µ–º –ú–∞–Ω–µ–∫–µ–Ω –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ä—Ç, –µ—Å–ª–∏ –æ–Ω –Ω–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω
            // –ï—Å–ª–∏ –ú–∞–Ω–µ–∫–µ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –Ω–æ –Ω–µ –±—ã–ª –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω (–Ω–∏ –æ–¥–∏–Ω —Å—Ü–µ–Ω–∞—Ä–∏–π –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª), –∏—Å–∫–ª—é—á–∞–µ–º –µ–≥–æ
            // Check if we have any non-dummy cards left
            const nonDummyCards = availableCards.filter(c => c.ability !== 'dummy');
            
            // FIX: Hide Dummy ONLY if we have other options. 
            // If Dummy is the LAST card(s) left, keep it visible so we can play it as a unit.
            const cardsWithoutDummy = (dummyCard && !dummyWasUsed && nonDummyCards.length > 0) 
                ? nonDummyCards 
                : availableCards;
            
            // FIX: Define context variables globally for all phases
            const isLeading = enemyScore > totalScore;
            const handDiff = cardsWithoutDummy.length - myCards.length;
            const scoreGap = Math.abs(totalScore - enemyScore);
            const isMustWin = (currentRound === 3) || (currentRound === 2 && playerMatchWins > 0);
            
            // --- FIX: PLAY DUMMY AS UNIT (LAST RESORT) ---
            // If the only card left is a Dummy (and no targets to swap), play it as a raw unit (0 points).
            // This prevents the bot from freezing or passing prematurely.
            if (availableCards.length > 0 && cardsWithoutDummy.length === 0 && !dummyWasUsed) {
                console.log("AI: Only Dummy left. Playing it as a raw unit to stall/finish.");
                
                // Select the Dummy and set preferred row
                const dummyToPlay = availableCards.find(c => c.ability === 'dummy') || availableCards[0];
                
                // Assign a random row since position is 'any'
                const rows = ['attack', 'midfield', 'defense'];
                dummyToPlay._preferredRowId = rows[Math.floor(Math.random() * rows.length)];
                
                // Continue execution - the Dummy will be picked up in Phase 4 fallback
                // (since cardsWithoutDummy is empty, selectedCard will remain null until Phase 4)
            }
            
            const spyCard = cardsWithoutDummy.find(card => card.ability === 'spy');
            
            // LOGIC FIX: Should we play the Spy?
            let playSpy = false;
            
            if (spyCard) {
                playSpy = true; // Default behavior
                
                // EXCEPTION: "Suicide Spy"
                // If we MUST win this round (R1 lost), Player passed, and we are currently LOSING.
                // Playing a spy gives Player more points, making it harder to catch up.
                // Better to play value cards to win the round first.
                if (isMustWin && playerPassed && totalScore > enemyScore) {
                     console.log("AI: Skipping Spy. Must win round and currently losing. Focusing on points.");
                     playSpy = false;
                }
            }

            if (playSpy && spyCard) {
                const spyCardBackElement = enemyCardsContainer.querySelector(`[data-enemy-card-id="${spyCard.id}"]`);
                await placeEnemySpyCard(spyCardBackElement, spyCard);
                return;
            }

            // ============================================
            // –§–ê–ó–ê 1.5: SMART MEDIC (Value Calculation)
            // ============================================
            let selectedCard = null; 
            
            // isMustWin already defined globally, reuse it here
            
            try {
                const medicInHand = cardsWithoutDummy.find(c => c.ability === 'medic');
                
                // CRITICAL CHECK: Only run complex math if we have a Medic AND the graveyard has cards
                const hasGraveyardCards = enemyGraveyardCards && enemyGraveyardCards.length > 0;

                if (medicInHand && hasGraveyardCards) {
                    const context = {
                        deckCount: getEnemyDeckCount(), 
                        isSurvivalMode: (playerPassed && enemyScore < totalScore) || (currentRound === 3 && enemyScore < totalScore),
                        enemyCardsOnField: enemyCardsOnField
                    };

                    const scoredTargets = enemyGraveyardCards
                        .filter(c => isRevivable(c))
                        .map(c => ({ card: c, score: calculateReviveValue(c, context) }));

                    scoredTargets.sort((a, b) => b.score - a.score);

                    if (scoredTargets.length > 0) {
                        const bestOption = scoredTargets[0];
                        const isWorthIt = bestOption.score >= 8 || cardsWithoutDummy.length <= 2; 

                        if (isWorthIt && !selectedCard) {
                            console.log(`AI: SMART MEDIC! Best Target: ${bestOption.card.name} (Profit: ${bestOption.score}).`);
                            selectedCard = medicInHand;
                            if (!selectedCard._preferredRowId) {
                                selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                            }
                        }
                    }
                }
            } catch (medicError) {
                console.error("AI Warning: Smart Medic Logic crashed. Skipping phase.", medicError);
            }

            // ============================================
            // –§–ê–ó–ê 2: GRANDMASTER PASS DECISION
            // ============================================
            
            // FIX: Declare pass variables in the main scope of enemyTurn
            let shouldPass = false;
            let passReason = '';

            // Skip pass logic if we already selected a card (e.g., from Phase 1.5 Spy Theft)
            if (!selectedCard) {
            
            // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç
            const playerHandCount = myCards.length;
            const enemyHandCount = cardsWithoutDummy.length;
            // isMustWin already defined in Phase 1.5, reuse it here
            // isLeading already defined globally
            
            // --- NEW ROUND 1 LOGIC ---
            const gap = totalScore - enemyScore;
            const hasSpy = cardsWithoutDummy.some(c => c.ability === 'spy');
            const botHandCount = cardsWithoutDummy.length;

            // Dynamic Threshold: The more cards we have, the bigger the gap we are willing to chase.
            // Base 6 + 2 points per card in hand.
            // e.g. 10 cards = 26 pts gap allowed. 3 cards = 12 pts gap allowed.
            const dynamicGapThreshold = 6 + (botHandCount * 2);

            // 1. Cut Losses (Round 1) - Dynamic
            // Condition: Gap is big, BUT we check if we can catch up with ONE card before giving up.
            if (currentRound === 1 && !playerPassed && gap > dynamicGapThreshold && !hasSpy) {
                // Check if we have a "Hero" move (single card that covers the gap)
                const canCatchUpWithOneCard = cardsWithoutDummy.some(c => (c.power || 0) > gap);
                
                if (!canCatchUpWithOneCard) {
                    shouldPass = true;
                    passReason = "–†–∞–∑—Ä—ã–≤ —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫. –ë–æ—Ç –±–µ—Ä–µ–∂–µ—Ç —Å–∏–ª—ã.";
                } else {
                    console.log("AI: Gap is huge, but I have a strong card to fight back!");
                }
            }

            // 2. Tempo Pressure (Round 1)
            if (!shouldPass && currentRound === 1 && !playerPassed && enemyScore > totalScore + 10 && !hasSpy) {
                shouldPass = true;
                passReason = "–¢–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Å! –ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ.";
            }

            // 3. Expensive Win (Player passed, Round 1)
            if (!shouldPass && currentRound === 1 && playerPassed && enemyScore < totalScore) {
                const pointsNeeded = gap + 1;
                // Find strongest available card
                const strongestCard = cardsWithoutDummy.reduce((max, card) => (card.power || 0) > (max.power || 0) ? card : max, { power: 0 });
                
                // If even the strongest card isn't enough, we'd need 2+ cards. That's too expensive.
                if ((strongestCard.power || 0) < pointsNeeded) {
                    shouldPass = true;
                    passReason = "–ü–æ–±–µ–¥–∞ –≤ —Ä–∞—É–Ω–¥–µ —Å—Ç–æ–∏—Ç —Å–ª–∏—à–∫–æ–º –¥–æ—Ä–æ–≥–æ. –ë–æ—Ç —Å–¥–∞–µ—Ç —Ä–∞—É–Ω–¥.";
                }
            }
            // -------------------------
            
            // --- GAMBLER'S PASS (Round 2 Risk) ---
            // If we are leading in R2 (Must Win), holding our last powerful card, 
            // we dare the player to beat our score instead of wasting the finisher.
            if (!shouldPass && currentRound === 2 && enemyMatchWins === 0 && !playerPassed && isLeading) {
                const gap = enemyScore - totalScore;
                const cardsLeft = cardsWithoutDummy.length;
                
                if (cardsLeft === 1) {
                    const lastCard = cardsWithoutDummy[0];
                    const isHighValue = (lastCard.power || 0) >= 8 || lastCard.isHero || lastCard.cardtype === 'hero' || lastCard.ability === 'medic' || lastCard.ability === 'spy';
                    
                    // If we have a decent lead (5+) and a high value card, SAVE IT.
                    if (gap >= 5 && isHighValue) {
                        shouldPass = true;
                        passReason = "–ë–æ—Ç —Ä–∏—Å–∫—É–µ—Ç –∏ –æ—Ç–¥–∞–µ—Ç —Ö–æ–¥, —Å–æ—Ö—Ä–∞–Ω—è—è –∫–æ–∑—ã—Ä—å!";
                    }
                }
            }
            
            // 1. Standard Tempo Pass (Tactic 1)
            if (!isMustWin && !playerPassed && isLeading) {
                const scoreLead = enemyScore - totalScore;
                if ((scoreLead >= 12 && handDiff >= 0) || (scoreLead >= 20 && handDiff >= -1)) {
                    shouldPass = true;
                    passReason = "–ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–∞—Ä—Ç—ã (–£–º–Ω—ã–π –ø–∞—Å)!";
                }
            }
            
            // 2. Cutting Losses (Tactic 1)
            if (!shouldPass && !isMustWin && !playerPassed && !isLeading) {
                // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –ø–æ—Ä–æ–≥ –¥–ª—è "Cutting Losses"
                let gapThreshold = 15; // –ë–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                
                // Round 1: –ë–æ—Ä–µ–º—Å—è –∞–∫—Ç–∏–≤–Ω–µ–µ (–ø–æ—Ä–æ–≥ –≤—ã—à–µ)
                if (currentRound === 1) {
                    gapThreshold = 30;
                }
                
                // –ï—Å–ª–∏ —É –±–æ—Ç–∞ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –ø–æ –∫–∞—Ä—Ç–∞–º - —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–æ—Ä–æ–≥
                if (handDiff > 0) {
                    gapThreshold += 15;
                }
                // –ï—Å–ª–∏ —É –±–æ—Ç–∞ —Ä–∞–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç - –Ω–µ–º–Ω–æ–≥–æ —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º –ø–æ—Ä–æ–≥
                else if (handDiff === 0) {
                    gapThreshold += 5;
                }
                
                const gap = totalScore - enemyScore;
                if (gap > gapThreshold) {
                    const standardCardsForGapCheck = cardsWithoutDummy.filter(card => 
                        !(card.isHero === true || card.cardtype === 'hero' || (card.power || 0) >= 10)
                    );
                    const canCatchUpWithStandard = standardCardsForGapCheck.some(card => 
                        (card.power || 0) > gap
                    );
                    if (!canCatchUpWithStandard) {
                        shouldPass = true;
                        passReason = "–ë–æ—Ç –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Ä–∞–∑—Ä—ã–≤ –∏ –ø–∞—Å—É–µ—Ç";
                    }
                }
            }
            
            // 3. Bleeding Stop (Tactic 2)
            // Bot won R1 (1-0), now in R2. Checks if it should stop pushing to save cards for R3.
            // FIX: Ensure we only bleed if we are LEADING (1-0). If it's a draw (1-1), we must fight!
            if (!shouldPass && currentRound === 2 && enemyMatchWins === 1 && playerMatchWins === 0 && !playerPassed) {
                const gap = totalScore - enemyScore;
                // Check if coach is available (global variable currentEnemyCoach)
                const hasActiveCoach = currentEnemyCoach && currentEnemyCoach.isUsed === false;
                
                // Condition A: Gap is massive (unrecoverable)
                const isGapTooBig = gap >= 15;
                
                // Condition B: We are behind by 2+ cards (dangerous territory)
                const isSevereCardDisadvantage = handDiff < -1;
                
                // Condition C: We are behind by 1 card AND have no Coach to help us
                // (If we have a Coach, we should play it first before passing)
                const isMildDisadvantageNoBackup = (handDiff < 0 && !hasActiveCoach);

                if (isGapTooBig || isSevereCardDisadvantage || isMildDisadvantageNoBackup) {
                    shouldPass = true;
                    passReason = "–ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∫–∞—Ä—Ç—ã –Ω–∞ —Ñ–∏–Ω–∞–ª (Bleeding Stop)!";
                }
            }
            
            // 4. Cheap Win / Catch Up (Player Passed)
            if (!shouldPass && playerPassed && !isLeading) {
                const pointsNeeded = totalScore - enemyScore + 1;
                const winningCards = cardsWithoutDummy.filter(card => (card.power || 0) >= pointsNeeded);
                
                // If no SINGLE card can win
                if (winningCards.length === 0) {
                    // Only give up if the gap is huge or it's not a must-win round
                    const gap = totalScore - enemyScore;
                    if (!isMustWin && gap > 20) {
                        shouldPass = true;
                        passReason = "–ë–æ—Ç —Ä–µ—à–∞–µ—Ç –Ω–µ —Ç—Ä–∞—Ç–∏—Ç—å –∫–∞—Ä—Ç—ã –∏ –ø–∞—Å—É–µ—Ç.";
                    }
                    // Else: Do nothing here, fall through to Phase 3 to play cards and catch up
                } else {
                    const weakestWinningCard = winningCards.sort((a, b) => (a.power || 0) - (b.power || 0))[0];
                    const isHero = weakestWinningCard.isHero === true || weakestWinningCard.cardtype === 'hero';
                    const onlyHeroesCanWin = winningCards.every(card => 
                        card.isHero === true || card.cardtype === 'hero'
                    );
                    if (onlyHeroesCanWin && currentRound === 1 && !isHero) {
                        shouldPass = true;
                        passReason = "–ë–æ—Ç –æ—Ü–µ–Ω–∏–≤–∞–µ—Ç —Ä–∞–∑—Ä—ã–≤ –∏ –ø–∞—Å—É–µ—Ç";
                    }
                }
            }
            
            // 5. Smart Pass (Player passed, Bot winning)
            if (!shouldPass && playerPassed && isLeading) {
                shouldPass = true;
                passReason = "–°–æ–ø–µ—Ä–Ω–∏–∫ –ø–∞—Å—É–µ—Ç (—Ö–≤–∞—Ç–∏—Ç –æ—á–∫–æ–≤)";
            }
            
            if (shouldPass) {
                console.log("AI: –ü—Ä–∏–Ω—è—Ç–æ —Ä–µ—à–µ–Ω–∏–µ –ø–∞—Å–æ–≤–∞—Ç—å.");
                enemyPassed = true;
                showGameNotification(passReason, 'info');
                
                // FIX: –ü–µ—Ä–µ–¥–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫—É, –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ —Å–ø–∞—Å–æ–≤–∞–ª
                // Return control if player hasn't passed AND (has cards OR has active Coach)
                if (!playerPassed && (myCards.length > 0 || (currentPlayerCoach && !currentPlayerCoach.isUsed))) {
                    isPlayerTurn = true;
                    updatePassButtonState();
                    // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥–æ–ø. —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ, —á—Ç–æ —Ç–µ–ø–µ—Ä—å –∏–≥—Ä–æ–∫ –º–æ–∂–µ—Ç —Ö–æ–¥–∏—Ç—å –¥–æ –∫–æ–Ω—Ü–∞
                    console.log("–•–æ–¥ –≤–æ–∑–≤—Ä–∞—â–µ–Ω –∏–≥—Ä–æ–∫—É –ø–æ—Å–ª–µ –ø–∞—Å–∞ –±–æ—Ç–∞");
                }
                
                checkRoundEnd();
                return;
            }

            // --- FINAL OVERRIDE: THE LAST STAND ---
            // If it's the final round (or match point), the player passed, and we are NOT winning:
            // We MUST play everything we have. Never pass on a Draw/Loss in the final.
            const isMatchPoint = currentRound === 3 || (currentRound === 2 && playerMatchWins === 1);
            
            // FIX: Check STRICTLY if we are not leading (totalScore >= enemyScore)
            if (isMatchPoint && playerPassed && totalScore >= enemyScore && cardsWithoutDummy.length > 0) {
                console.log("AI: Last Stand! Forcing play to win (Score is Draw or Losing).");
                shouldPass = false; // Force play
                passReason = "";
            }
            } // End of Phase 2 conditional (skip if selectedCard already set)

            // ============================================
            // –§–ê–ó–ê 3: STRATEGY SELECTION (THE "JUGGLING")
            // ============================================
            
            // Helper: Should we skip this card?
            // Helper: Should we skip this card?
            const isInefficientMedic = (card) => {
                if (!card) return false;
                if (card.ability !== 'medic') return false;
                
                // CRITICAL FIX: If we are running low on cards (<= 2), 
                // play the Medic for points even if graveyard is empty.
                if (cardsWithoutDummy.length <= 2) return false; 

                if (!enemyGraveyardCards) return true;
                const hasTargets = enemyGraveyardCards.some(c => isRevivable(c));
                
                return !hasTargets;
            };
            
            let playMode = null; // 'BLEEDING', 'SURVIVAL', 'POINT_MAXIMIZATION'
            // Note: selectedCard may already be set by Phase 1.5 (Spy Theft)
            if (!selectedCard) {
                selectedCard = null;
            }
            
            // Mode A: BLEEDING (Round 2, Bot Won R1, Bot has initiative)
            if (!selectedCard && currentRound === 2 && enemyMatchWins === 1 && !playerPassed && handDiff >= 0 && scoreGap < 10) {
                // Updated definition of "Trash/Bleed" cards:
                // 1. Not Heroes.
                // 2. Power <= 8 (increased from 7).
                // 3. OR Cards with 'medic'/'spy' are NEVER trash.
                // 4. 'bond'/'muster'/'tight_bond' can be used as bleed fodder if Power <= 6.
                const trashCards = cardsWithoutDummy.filter(card => {
                    // Skip inefficient medics (empty graveyard, unless desperate)
                    if (isInefficientMedic(card)) return false;
                    
                    const isHero = card.isHero === true || card.cardtype === 'hero';
                    const isKeyAbility = card.ability === 'medic' || card.ability === 'spy' || card.ability === 'dummy';
                    const power = card.power || 0;
                    
                    if (isHero || isKeyAbility) return false;
                    
                    // Allow playing weaker cards or medium cards without abilities
                    if (!card.ability && power <= 8) return true;
                    
                    // Allow playing synergy cards if they are weak enough (risky bleed)
                    if (['bond', 'muster', 'tight_bond', 'morale'].includes(card.ability) && power <= 6) return true;
                    
                    return false;
                });
                if (trashCards.length > 0) {
                    playMode = 'BLEEDING';
                    selectedCard = trashCards.sort((a, b) => (a.power || 0) - (b.power || 0))[0];
                    console.log("AI: –†–µ–∂–∏–º –±–ª–∏–¥–∏–Ω–≥–∞! –í—ã–º–∞–Ω–∏–≤–∞—é –∫–∞—Ä—Ç—ã –∏–≥—Ä–æ–∫–∞ –≤–æ 2-–º —Ä–∞—É–Ω–¥–µ.");
                } else {
                    // No "trash" cards left. We have only Strong cards.
                    
                    // FIX: If we have Card Advantage or Equality, keep pushing!
                    // Don't give the player a free round if we have equal cards (e.g. 6 vs 6).
                    if (handDiff >= 0) {
                        console.log("AI: No trash left, but holding CA/Equality. Forcing play with strongest remaining.");
                        playMode = 'BLEEDING_FORCE';
                        // Play the "weakest" of our strong cards to maintain pressure
                        selectedCard = cardsWithoutDummy.sort((a, b) => (a.power || 0) - (b.power || 0))[0];
                    } else {
                        // We are behind on cards and only have good ones left. Pass to save them.
                    enemyPassed = true;
                    showGameNotification("–ë–æ—Ç —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ç–æ–ø-–∫–∞—Ä—Ç—ã –Ω–∞ —Ñ–∏–Ω–∞–ª!", 'info');
                    checkRoundEnd();
                    return;
                    }
                }
            }
            
            // Mode B: SURVIVAL (Bot MUST win this round)
            if (!selectedCard && isMustWin) {
                playMode = 'SURVIVAL';
                const gap = isLeading ? 0 : (totalScore - enemyScore);
                
                // Helper function to calculate card value (PRO VERSION: Bond + Scorch Logic)
                const calculateCardValue = (card, rowId) => {
                    if (!card) return 0;
                    
                    let value = card.power || 0;
                    
                    // Filter inputs for the specific row
                    const cardsInRow = enemyCardsOnField.filter(c => c && c.cardData && c.rowId === rowId);
                    
                    // Standard Synergies
                    const hasBondOnField = cardsInRow.some(c => c.cardData.ability === 'bond');
                    const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                    const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                    
                    // --- BOND STRATEGY ---
                    if (card.ability === 'bond') {
                        if (hasBondOnField) {
                            value *= 2; 
                            value += 8; 
                        } else {
                            const partnerInHand = cardsWithoutDummy.some(c => 
                                c.id !== card.id && c.ability === 'bond' && (c.position === rowId || c.position === 'any')
                            );
                            if (partnerInHand) value += 4; 
                        }
                    }
                    
                    // --- OTHER SYNERGIES ---
                    if (hasCaptain && card.cardtype === 'base' && !card.ability) value *= 2;
                    if (hasLeader && card.cardtype === 'base' && !card.isHero) value += 1;
                    
                    // --- PROVOCATEUR LOGIC (Smart Scorch) ---
                    if (card.ability === 'provocateur') {
                        const targetRowId = rowId; 
                        
                        // Analyze Player's Row
                        const validTargets = playerCardsOnField.filter(entry => {
                            const c = entry.cardData;
                            return entry.rowId === targetRowId && !(c.isHero || c.cardtype === 'hero');
                        });

                        if (validTargets.length > 0) {
                            // Calculate Destruction Potential
                            const targetsWithPower = validTargets.map(t => ({
                                entry: t,
                                power: calculateUnitPower(t, true) 
                            }));
                            
                            const maxPower = Math.max(...targetsWithPower.map(t => t.power));
                            const victims = targetsWithPower.filter(t => t.power === maxPower);
                            const destructionValue = maxPower * victims.length;
                            
                            value += destructionValue;
                            
                            // 1. MINIMUM THRESHOLD CHECK
                            // Don't waste a dragon on a weak unit (e.g., < 7), unless we are desperate
                            if (maxPower < 7 && cardsWithoutDummy.length > 2) {
                                console.log("AI Provocateur: Target too weak (" + maxPower + "). Holding.");
                                value -= 15; 
                            }

                            // 2. OVERKILL CHECK
                            // If WE (AI) are already winning, save this power card for later
                            // FIX: Changed totalScore > enemyScore to enemyScore > totalScore
                            if (enemyScore > totalScore && destructionValue < 15) {
                                value -= 5;
                            }
                            
                            // 3. GREED LOGIC vs PASSED LOGIC
                            const isVictimBond = victims.some(v => v.entry.cardData.ability === 'bond');
                            
                            if (playerPassed) {
                                // CASE A: Player Passed. No more tricks.
                                // If this play wins the round immediately, BOOST IT.
                                if (totalScore + value > enemyScore) {
                                    value += 50; // MUST PLAY to win
                                }
                            } else {
                                // CASE B: Player Active. Use Smart Greed.
                                if (isVictimBond) {
                                    const totalBondsInRow = validTargets.filter(t => t.cardData.ability === 'bond').length;
                                    if (totalBondsInRow < 2 && cardsWithoutDummy.length > 2) {
                                        console.log("AI Provocateur: Waiting for Bond partner...");
                                        value -= 20; 
                                    } else {
                                        value += 10; // Punish the combo!
                                    }
                                }
                            }
                            
                            // Huge swing bonus
                            if (destructionValue >= 15) value += 10;
                        } else {
                            // Penalty for playing on empty row (wasted ability)
                            value -= 10;
                        }
                    }
                    
                    // --- REDCARD LOGIC (Global Scorch, identical to Klopp) ---
                    if (card.ability === 'redcard') {
                        // Calculate effective power for all cards on field (same logic as Klopp)
                        const getEffectivePower = (entry, isPlayerSide) => {
                            const c = entry.cardData;
                            const rId = entry.rowId;
                            if (c.isHero || c.cardtype === 'hero') return -1;
                            
                            let power = c.power || 0;
                            const fieldArray = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
                            const tacticsArray = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
                            const cardsInRow = fieldArray.filter(c => c.rowId === rId);
                            
                            const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                            if (hasLeader && c.ability !== 'leader' && c.cardtype === 'base') {
                                power += 1;
                            }
                            
                            let multiplier = 1;
                            if (c.ability === 'bond') {
                                const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                                if (bondCount >= 2) multiplier *= 2;
                            }
                            
                            let buffActive = false;
                            const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                            const hasSupport = tacticsArray.some(c => c.rowId === rId && c.cardData.ability === 'support');
                            if ((hasCaptain && c.ability !== 'captain') || hasSupport) {
                                buffActive = true;
                            }
                            if (buffActive) multiplier *= 2;
                            
                            return power * multiplier;
                        };
                        
                        const playerVuls = playerCardsOnField
                            .map(c => ({ entry: c, power: getEffectivePower(c, true) }))
                            .filter(item => item.power > 0);
                        const botVuls = enemyCardsOnField
                            .map(c => ({ entry: c, power: getEffectivePower(c, false) }))
                            .filter(item => item.power > 0);
                        const allVuls = [...playerVuls, ...botVuls];
                        
                        if (allVuls.length > 0) {
                            const globalMaxPower = Math.max(...allVuls.map(v => v.power));
                            const playerVictims = playerVuls.filter(v => v.power === globalMaxPower);
                            const botVictims = botVuls.filter(v => v.power === globalMaxPower);
                            
                            const damageToEnemy = playerVictims.reduce((sum, v) => sum + v.power, 0);
                            const damageToSelf = botVictims.reduce((sum, v) => sum + v.power, 0);
                            const netProfit = damageToEnemy - damageToSelf;
                            
                            value += netProfit;
                            
                            // Similar logic to Provocateur
                            if (netProfit <= 0) {
                                value -= 20; // Penalty for friendly fire
                            } else if (netProfit >= 15) {
                                value += 20; // Huge bonus for massive profit
                            } else if (netProfit >= 8) {
                                value += 10; // Good profit bonus
                            }
                            
                            // If player passed and this wins, boost it
                            if (playerPassed && totalScore + value > enemyScore) {
                                value += 50;
                            }
                        } else {
                            // Penalty if no targets
                            value -= 10;
                        }
                    }
                    
                    return value;
                };
                
                // Find card that takes the lead with minimum overkill
                const candidates = [];
                cardsWithoutDummy.forEach(card => {
                    if (!card) return; // Safety check: skip null/undefined cards
                    // Skip inefficient medics (empty graveyard, unless desperate)
                    if (isInefficientMedic(card)) return;
                    
                    const possibleRows = card.position === 'any' ? ['attack', 'midfield', 'defense'] : [card.position];
                    possibleRows.forEach(rowId => {
                        const value = calculateCardValue(card, rowId);
                        if (value > gap) {
                            candidates.push({ card, rowId, value, overkill: value - gap });
                        }
                    });
                });
                
                if (candidates.length > 0) {
                    // Sort by overkill (ascending), then by value (ascending)
                    candidates.sort((a, b) => {
                        if (a.overkill !== b.overkill) return a.overkill - b.overkill;
                        return a.value - b.value;
                    });
                    selectedCard = candidates[0].card;
                    // Store rowId for later use
                    selectedCard._preferredRowId = candidates[0].rowId;
                } else {
                    // Can't win with single card, play best card
                    selectedCard = cardsWithoutDummy.sort((a, b) => (b.power || 0) - (a.power || 0))[0];
                }
            }
            
            // Mode C: POINT MAXIMIZATION (Round 3 or closing Round 1)
            if (!selectedCard && (currentRound === 3 || (currentRound === 1 && isLeading && handDiff > 0))) {
                playMode = 'POINT_MAXIMIZATION';
                
                // Helper function to calculate potential points with synergy (ROBUST)
                const calculatePotentialPoints = (card, rowId) => {
                    if (!card) return 0; // Safety Check
                    let points = card.power || 0;
                    
                    // CRITICAL FIX: Filter out null/bad entries
                    const cardsInRow = enemyCardsOnField.filter(c => c && c.cardData && c.rowId === rowId);
                    
                    const hasBond = cardsInRow.some(c => c.cardData.ability === 'bond');
                    const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                    const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
                    const baseUnits = cardsInRow.filter(c => c.cardData.cardtype === 'base').length;
                    
                    // Bond logic
                    if (card.ability === 'bond' && hasBond) {
                        points *= 2;
                    }
                    // Captain logic
                    if (hasCaptain && card.cardtype === 'base' && !card.ability) {
                        points *= 2;
                    } else if (card.ability === 'captain') {
                        points += baseUnits * 2;
                    }
                    // Leader logic
                    if (hasLeader && card.cardtype === 'base' && !card.isHero) {
                        points += 1;
                    } else if (card.ability === 'leader') {
                        points += baseUnits;
                    }
                    
                    return points;
                };
                
                const candidates = [];
                cardsWithoutDummy.forEach(card => {
                    if (!card) return; // Safety check: skip null/undefined cards
                    // Skip inefficient medics (empty graveyard, unless desperate)
                    if (isInefficientMedic(card)) return;
                    
                    const possibleRows = card.position === 'any' ? ['attack', 'midfield', 'defense'] : [card.position];
                    possibleRows.forEach(rowId => {
                        const potential = calculatePotentialPoints(card, rowId);
                        candidates.push({ card, rowId, potential });
                    });
                });
                
                if (candidates.length > 0) {
                    candidates.sort((a, b) => b.potential - a.potential);
                    selectedCard = candidates[0].card;
                    selectedCard._preferredRowId = candidates[0].rowId;
                } else {
                    selectedCard = cardsWithoutDummy[0];
                }
            }
            
            // Mode D: SOLITAIRE / CATCH UP (Player passed, we need to win)
            // If Player passed and we are NOT leading, we must play to overtake.
            if (!selectedCard && playerPassed && totalScore >= enemyScore) {
                console.log("AI: Solitaire Mode - Playing to overtake.");
                playMode = 'CATCH_UP';

                const gap = totalScore - enemyScore;

                // 1. Try to find the "Cheapest" card that wins instantly (gap + 1)
                // Filter cards that have enough power to win
                const winningCards = cardsWithoutDummy
                    .filter(c => (c.power || 0) > gap)
                    .sort((a, b) => (a.power || 0) - (b.power || 0)); // Ascending: use smallest winner

                if (winningCards.length > 0) {
                    // We have a card that wins! Play the cheapest one.
                    selectedCard = winningCards[0];
                    console.log(`AI: Found winning card: ${selectedCard.name} (Power: ${selectedCard.power})`);
                } else {
                    // 2. Can't win with 1 card? Play the STRONGEST card to close the gap fast.
                    selectedCard = cardsWithoutDummy.sort((a, b) => (b.power || 0) - (a.power || 0))[0];
                    console.log(`AI: Can't win yet. Playing strongest: ${selectedCard.name}`);
                }

                // Ensure preferred row is set
                if (selectedCard && !selectedCard._preferredRowId) {
                     selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                }
            }
            
            // Fallback: Smart Card Selection (existing logic)
            if (!selectedCard) {
                playMode = 'STANDARD';
                const finishers = cardsWithoutDummy.filter(card => 
                    card.isHero === true || card.cardtype === 'hero' || (card.power || 0) >= 10
                );
                const standardCards = cardsWithoutDummy.filter(card => 
                    !(card.isHero === true || card.cardtype === 'hero' || (card.power || 0) >= 10) &&
                    !isInefficientMedic(card) // Skip inefficient medics
                );
                
                if (enemyScore <= totalScore) {
                    const gap = totalScore - enemyScore;
                    const winningStandardCards = standardCards
                        .filter(card => (card.power || 0) > gap)
                        .sort((a, b) => (a.power || 0) - (b.power || 0));
                    
                    if (winningStandardCards.length > 0) {
                        selectedCard = winningStandardCards[0];
                    } else {
                        const winningFinishers = finishers
                            .filter(card => (card.power || 0) > gap)
                            .sort((a, b) => (a.power || 0) - (b.power || 0));
                        if (winningFinishers.length > 0) {
                            selectedCard = winningFinishers[0];
                        } else {
                            selectedCard = cardsWithoutDummy.sort((a, b) => (a.power || 0) - (b.power || 0))[0];
                        }
                    }
                } else {
                    if (standardCards.length > 0) {
                        selectedCard = standardCards.sort((a, b) => (a.power || 0) - (b.power || 0))[0];
                    } else {
                        selectedCard = finishers.length > 0 
                            ? finishers.sort((a, b) => (a.power || 0) - (b.power || 0))[0] 
                            : cardsWithoutDummy[0];
                    }
                }
            }

            // --- FAIL-SAFE CARD SELECTION ---
            // If logic failed to pick a card, but we have cards, pick the first one.
            if (!selectedCard && !shouldPass && cardsWithoutDummy.length > 0) {
                console.warn("AI Warning: No strategy selected a card. Using fallback (first card).");
                selectedCard = cardsWithoutDummy[0];
                // Ensure we have a valid row ID fallback
                if (!selectedCard._preferredRowId) {
                    selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                }
            }
            
            // If still no card and not passing -> Force Pass directly (we're past the shouldPass check)
            if (!selectedCard && !shouldPass) {
                console.warn("AI Warning: No cards available to play. Forcing pass.");
                enemyPassed = true;
                showGameNotification("–ë–æ—Ç —Ä–µ—à–∏–ª –ø–∞—Å–æ–≤–∞—Ç—å", 'info');
                checkRoundEnd();
                return;
            }

            // ============================================
            // –§–ê–ó–ê 3.5: AGGRESSIVE FAIL-SAFE (CRITICAL FIX)
            // ============================================
            // If the bot decided NOT to pass, but no specific strategy selected a card,
            // we MUST play something. Do not allow the bot to freeze or pass unintentionally.
            
            if (!selectedCard && !shouldPass) {
                console.warn("AI DEBUG: No strategy matched. Engaging Aggressive Fail-Safe.");
                
                // 1. Try to pick the strongest card from filtered list (non-dummies)
                if (cardsWithoutDummy && cardsWithoutDummy.length > 0) {
                    // Sort by Power Descending
                    cardsWithoutDummy.sort((a, b) => (b.power || 0) - (a.power || 0));
                    selectedCard = cardsWithoutDummy[0];
                    console.log("AI Fail-Safe: Playing strongest available (Filtered):", selectedCard.name);
                } 
                // 2. If filtered list is empty (e.g. only Medics with no targets), look at ALL cards
                else if (availableCards && availableCards.length > 0) {
                    // Sort by Power Descending
                    availableCards.sort((a, b) => (b.power || 0) - (a.power || 0));
                    selectedCard = availableCards[0];
                    console.log("AI Fail-Safe: Playing strongest available (Raw):", selectedCard.name);
                }
                
                // 3. Ensure row ID is set
                if (selectedCard) {
                    if (!selectedCard._preferredRowId) {
                        selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                    }
                } else {
                    // This should technically never happen if availableCards.length > 0
                    console.error("AI CRITICAL: Hand has cards but Fail-Safe found nothing!");
                    shouldPass = true; // Forced surrender
                }
            }

            // ============================================
            // –§–ê–ó–ê 4: EXECUTION
            // ============================================
            
            // --- FALLBACK SELECTION (Prevent Crash) ---
            // If no strategy picked a card, just pick the first valid one.
            if (!selectedCard && !shouldPass) {
                console.warn("AI Warning: No strategy selected a card. Using Fallback (First Card).");
                
                if (cardsWithoutDummy.length > 0) {
                    selectedCard = cardsWithoutDummy[0];
                    // Ensure row ID exists if missing
                    if (!selectedCard._preferredRowId) {
                        selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                    }
                } else if (availableCards.length > 0) {
                    // Fallback to availableCards (includes Dummy) if cardsWithoutDummy is empty
                    selectedCard = availableCards[0];
                    // Ensure row ID exists if missing (should already be set from Phase 1 for Dummy)
                    if (!selectedCard._preferredRowId) {
                        selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                    }
                } else {
                    // No cards left at all? Must pass.
                    console.warn("AI Warning: No cards left for fallback. Forcing Pass.");
                    shouldPass = true;
                    passReason = "Emergency Pass (No cards)";
                }
            }

            // ULTIMATE FAILSAFE (If Logic Failed)
            if (!selectedCard && !shouldPass) {
                if (cardsWithoutDummy.length > 0) selectedCard = cardsWithoutDummy[0];
                else if (availableCards.length > 0) selectedCard = availableCards[0];
                
                // Ensure row ID exists if we selected a card
                if (selectedCard && !selectedCard._preferredRowId) {
                    selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                }
            }

            // Re-check Pass Condition after Fallback
            if (shouldPass) {
                console.log("AI: Forced Pass triggered in Fallback.");
                enemyPassed = true;
                showGameNotification(passReason || "–ë–æ—Ç –ø–∞—Å—É–µ—Ç.", 'info');
                // Return control if player hasn't passed AND (has cards OR has active Coach)
                if (!playerPassed && (myCards.length > 0 || (currentPlayerCoach && !currentPlayerCoach.isUsed))) {
                    isPlayerTurn = true;
                    updatePassButtonState();
                }
                checkRoundEnd();
                return;
            }
            // ------------------------------------------

            const availableCard = selectedCard;
            // Safety check: if still null, return to prevent crash
            if (!availableCard) {
                console.error("CRITICAL: availableCard is still null! Aborting turn.");
                isPlayerTurn = true; // Give control back to player to avoid softlock
                return;
            }
            const cardBackElement = enemyCardsContainer.querySelector(`[data-enemy-card-id="${availableCard.id}"]`);

            // –û–ë–´–ß–ù–ê–Ø –ö–ê–†–¢–ê –∏–ª–∏ SUPPORT
            const isSupportCard = availableCard.ability === 'support';
            let targetRow = null;
            let rowId = null;
            let actualTargetElement = null;
            let isTacticsPlacement = false;

            // –í—ã–±–æ—Ä —Ä—è–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —Ä—è–¥ –∏–∑ Phase 3, –µ—Å–ª–∏ –µ—Å—Ç—å)
            if (isSupportCard) {
                rowId = evaluateBestSupportRow();
                targetRow = getEnemyTargetRow(rowId);
                actualTargetElement = getEnemyTacticsSlot(rowId);
                isTacticsPlacement = true;
            } else {
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω—ã–π —Ä—è–¥ –∏–∑ Phase 3, –µ—Å–ª–∏ –æ–Ω –±—ã–ª –æ–ø—Ä–µ–¥–µ–ª–µ–Ω
                if (availableCard._preferredRowId) {
                    rowId = availableCard._preferredRowId;
                    delete availableCard._preferredRowId; // –û—á–∏—â–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å–≤–æ–π—Å—Ç–≤–æ
                } else if (availableCard.position === 'any') {
                    const rows = ['attack', 'midfield', 'defense'];
                    rowId = rows[Math.floor(Math.random() * rows.length)];
                } else {
                    rowId = availableCard.position;
                }
                targetRow = getEnemyTargetRow(rowId);
                actualTargetElement = targetRow;
            }
            
            // Fallback
            if (!actualTargetElement || !targetRow) {
                rowId = 'attack';
                targetRow = enemyAttackRow;
                actualTargetElement = isSupportCard ? getEnemyTacticsSlot(rowId) : targetRow;
            }

            // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è
            const fieldCard = document.createElement('div');
            fieldCard.className = 'card-on-field';
            fieldCard.style.opacity = '0';
            
            if (availableCard.isHero || availableCard.cardtype === 'hero') {
                fieldCard.classList.add('hero');
            }
            
            const fieldCardImage = document.createElement('img');
            const imageSrc = (availableCard.miniImg && availableCard.miniImg !== "") ? availableCard.miniImg : availableCard.img;
            fieldCardImage.src = imageSrc;
            fieldCardImage.alt = availableCard.name || `–ö–∞—Ä—Ç–∞ ${availableCard.id}`;
            
            fieldCard.appendChild(fieldCardImage);
            
            // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
            fieldCard.addEventListener('dragstart', (e) => e.preventDefault());
            fieldCardImage.addEventListener('dragstart', (e) => e.preventDefault());
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –¥–ª—è –∏–Ω—Å–ø–µ–∫—Ü–∏–∏
            fieldCard.setAttribute('data-full-img', availableCard.img);
            addFieldPowerBadge(fieldCard, availableCard);
            
            if (isTacticsPlacement) {
                const existingCard = actualTargetElement.querySelector('.card-on-field');
                if (existingCard) {
                    const existingCardId = parseInt(existingCard.getAttribute('data-card-id'));
                    enemyTacticsCards = enemyTacticsCards.filter(card => card.cardData.id !== existingCardId);
                    existingCard.remove();
                }
                enemyTacticsCards.push({ cardData: availableCard, rowId });
            } else {
                enemyCardsOnField.push({ cardData: availableCard, rowId });
            }
            
            fieldCard.setAttribute('data-card-id', availableCard.id);
            
            // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏–Ω—Å–ø–µ–∫—Ü–∏—é –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
            addInspectionEvents(fieldCard, availableCard.img);
            
            insertCardSmartly(actualTargetElement, fieldCard);
            
            await animateCardTransition(availableCard, fieldCard);
            
            fieldCard.style.opacity = '1';
            if (cardBackElement) cardBackElement.remove();
            availableCard.used = true;
            
            updateEnemyScore();
            movesCount++;
            updatePlayerScore();
            
            if (!isSupportCard) updateRowLayout(actualTargetElement);
            
            // Check if the played card is a Medic and handle resurrection
            if (availableCard.ability === 'medic') {
                const resurrected = await aiPlayMedic(availableCard);
                if (!resurrected) {
                    showGameNotification("–ú–µ–¥–∏–∫ —Å—ã–≥—Ä–∞–Ω, –Ω–æ –æ—Ç–±–æ–π –ø—É—Å—Ç.", 'info');
                }
            } 
            // Check if the played card is a Provocateur
            else if (availableCard.ability === 'provocateur') {
                await executeProvocateur(availableCard, rowId, false); // false = AI is attacker
            }
            // Check if the played card is a RedCard
            else if (availableCard.ability === 'redcard') {
                await executeRedCard(availableCard, false); // false = AI is attacker
            }
            
            checkRoundEndCondition();

            if ((playerPassed || myCards.length === 0) && (enemyPassed || enemyCards.length === 0)) return;
            if (checkAutoPass()) return;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–µ—Ä–∞ –ø–µ—Ä–µ–¥ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–∞—Å–æ–º
            const hasActiveEnemyCoachAfterMove = currentEnemyCoach && currentEnemyCoach.isUsed === false;
            if (enemyCards.filter(c => !c.used).length === 0 && !enemyPassed && !hasActiveEnemyCoachAfterMove) {
                console.log("AI: Played last card. Auto-passing.");
                enemyPassed = true;
                showGameNotification("–£ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã. –ü–∞—Å.", 'info'); // VISUAL FIX
            }

            // --- UNIFIED TURN SWITCH ---
            // If bot didn't pass, handle turn switching logic
            if (!enemyPassed) {
                handleTurnSwitch();
                return; // <--- CRITICAL FIX: Stop execution here!
            } else if (!playerPassed) {
                // Bot passed, Player active -> Player's turn
                isPlayerTurn = true;
                updatePassButtonState();
                return; // <--- CRITICAL FIX: Stop execution here!
            }
            
            if (myCards.length === 0 && enemyCards.length === 0) {
                setTimeout(() => { endRound(); }, 500);
                return;
            }
            
            if (myCards.length === 0 && enemyCards.length > 0 && !playerPassed && !enemyPassed) {
                 setTimeout(() => { enemyTurn(); }, 1000);
                 return;
            }
            
            // ============================================
            // –§–ê–ó–ê 4.5: WINNING FALLBACK (Logic Gap Fix)
            // ============================================
            // If logic didn't pick a card, but we are LEADING, 
            // implies we don't want to waste cards. Pass gracefully.
            if (!selectedCard && !enemyPassed && enemyScore > totalScore) {
                console.log("AI: Leading but no suitable card selected. Executing Strategic Fallback Pass.");
                enemyPassed = true;
                
                // Friendly notification instead of error
                showGameNotification("–ë–æ—Ç –¥–æ–≤–æ–ª–µ–Ω —Å—á–µ—Ç–æ–º –∏ –ø–∞—Å—É–µ—Ç.", 'info');
                
                checkRoundEnd();
                
                // Return control to player if needed
                if (!playerPassed) {
                    isPlayerTurn = true;
                    updatePassButtonState();
                }
                return;
            }
            
            // --- FINAL SAFETY NET ---
            // If we reached this point, it means:
            // 1. We had resources (cards or coach) so we entered the function.
            // 2. But NO strategy decided to play a card.
            // 3. AND NO coach ability was activated.
            // To prevent a soft lock, we must force a Pass.
            if (!enemyPassed) {
                console.warn("AI: Turn ended without action (Coach refused to act?). Forcing Safety Pass.");
                enemyPassed = true;
                showGameNotification("–ë–æ—Ç –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥ (–Ω–µ—Ç —Ä–µ—à–µ–Ω–∏–π).", 'info'); // ADDED NOTIFICATION
                
                checkRoundEnd();
                
                // Ensure player gets control back visually
                if (!playerPassed) {
                    isPlayerTurn = true;
                    updatePassButtonState();
                }
            }
            
            // ============================================
            // –§–ê–ó–ê 4.8: DESPERATION PLAY (Must Catch Up)
            // ============================================
            // CRITICAL FIX: If Player passed and we are losing, NEVER trigger "No decisions".
            // Just play the strongest card available.
            if (!selectedCard && !enemyPassed && playerPassed && totalScore >= enemyScore) {
                console.log("AI: Desperation Mode. Player passed, I am losing. Playing strongest card.");
                
                // 1. Try to find strongest non-dummy
                if (cardsWithoutDummy.length > 0) {
                    cardsWithoutDummy.sort((a, b) => (b.power || 0) - (a.power || 0));
                    selectedCard = cardsWithoutDummy[0];
                } 
                // 2. If only Dummy left, play it (better than error)
                else if (availableCards.length > 0) {
                    selectedCard = availableCards[0];
                }

                // 3. Ensure row ID
                if (selectedCard) {
                    if (!selectedCard._preferredRowId) {
                        selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                    }
                }
            }
            
            // ============================================
            // –§–ê–ó–ê 5: ULTIMATE FALLBACK (BRUTE FORCE)
            // ============================================
            // If logic failed to pick a card, but we still have cards:
            // NEVER PASS due to "no decisions". Just play the strongest card we have.
            
            if (!enemyPassed && !selectedCard) {
                // Get all valid remaining cards
                const remainingCards = enemyCards.filter(c => !c.used);
                
                if (remainingCards.length > 0) {
                    console.warn("AI: Logic skipped all options. Brute-forcing strongest card.");
                    
                    // 1. Sort by Power (Descending)
                    remainingCards.sort((a, b) => (b.power || 0) - (a.power || 0));
                    
                    // 2. Select the winner
                    selectedCard = remainingCards[0];
                    
                    // 3. Ensure Row ID is set
                    if (!selectedCard._preferredRowId) {
                        selectedCard._preferredRowId = selectedCard.position === 'any' ? 'attack' : selectedCard.position;
                    }
                } else {
                    // Truly empty hand (and no coach active check handled earlier)
                    console.log("AI: Hand empty. Passing.");
                    enemyPassed = true;
                    checkRoundEnd();
                    
                    if (!playerPassed) {
                        isPlayerTurn = true;
                        updatePassButtonState();
                    }
                    return;
                }
            }
            } catch (error) {
                console.error("CRITICAL AI ERROR (CRASH):", error);
                showGameNotification("–û—à–∏–±–∫–∞ –ò–ò. –ë–æ—Ç –ø—Ä–æ–ø—É—Å–∫–∞–µ—Ç —Ö–æ–¥.", 'error');
                
                // Emergency Recovery
                enemyPassed = true;
                isPlayerTurn = true;
                updatePassButtonState();
                checkRoundEnd();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–±–µ–¥–∏—Ç–µ–ª—è
        function checkWinner() {
            cleanUpVisualArtifacts(); // <--- ADD THIS
            
            let title = '';
            let titleClass = '';
            
            if (totalScore > enemyScore) {
                title = '–ü–û–ë–ï–î–ê –°–ü–ê–†–¢–ê–ö–ê!';
                titleClass = 'victory';
            } else if (totalScore < enemyScore) {
                title = '–ü–û–†–ê–ñ–ï–ù–ò–ï...';
                titleClass = 'defeat';
            } else {
                title = '–ù–ò–ß–¨–Ø';
                titleClass = 'draw';
            }
            
            resultTitle.textContent = title;
            resultTitle.className = 'game-result-title ' + titleClass;
            resultScore.textContent = `–°—á–µ—Ç: ${totalScore} - ${enemyScore}`;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
            gameOverlay.classList.add('show');
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞
        restartButton.addEventListener('click', function() {
            cleanUpVisualArtifacts(); // <--- ADD THIS
            // –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∂–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
            location.reload();
        });
        
        // –ü–æ–ª—É—á–∞–µ–º –∫–Ω–æ–ø–∫—É –ø–∞—Å–∞
        const passButton = document.getElementById('ingame-pass-btn');
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–µ–π—Å—Ç–≤–∏—è "–ü–∞—Å"
        function handlePassAction() {
            // --- –ê–í–ê–†–ò–ô–ù–´–ô –†–ê–ó–ë–õ–û–ö–ò–†–û–í–©–ò–ö ---
            // –ï—Å–ª–∏ –±–æ—Ç —É–∂–µ –∑–∞–∫–æ–Ω—á–∏–ª –∏–≥—Ä—É (—É –Ω–µ–≥–æ –Ω–µ—Ç –∫–∞—Ä—Ç –∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–µ—Ä–∞ –ò–õ–ò –æ–Ω —Å–ø–∞—Å–æ–≤–∞–ª),
            // –∞ —Ö–æ–¥ –ø–æ—á–µ–º—É-—Ç–æ –Ω–µ —É –Ω–∞—Å -> –ß–ò–ù–ò–ú
            if (!isPlayerTurn && !playerPassed) {
                const enemyEmpty = enemyCards.filter(c => !c.used).length === 0;
                const enemyCoachActive = currentEnemyCoach && currentEnemyCoach.isUsed === false;
                const enemyIsDone = enemyPassed || (enemyEmpty && !enemyCoachActive);
                
                if (enemyIsDone) {
                    console.warn("–û–ë–ù–ê–†–£–ñ–ï–ù SOFT LOCK –≤ handlePassAction! –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ö–æ–¥ –∏–≥—Ä–æ–∫—É.");
                    isPlayerTurn = true;
                    updatePassButtonState();
                    showGameNotification("–•–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!", 'info');
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏, –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞—è –µ—ë
                } else {
                    // –ï—Å–ª–∏ —ç—Ç–æ —Ä–µ–∞–ª—å–Ω–æ —Ö–æ–¥ –±–æ—Ç–∞, —Ç–æ –≤—ã—Ö–æ–¥–∏–º
                    return;
                }
            }
            
            if (!isPlayerTurn || playerPassed) {
                return;
            }
            
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø–∞—Å—É–µ—Ç, –æ–Ω —É–ø—É—Å–∫–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∏—Ç—å –ö–∞—Ä—Å–µ–¥–æ
            if (lastKloppVictims.length > 0) {
                lastKloppVictims = []; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –∂–µ—Ä—Ç–≤
                kloppOpportunityMissed = true; // –°—Ç–∞–≤–∏–º —Ñ–ª–∞–≥ —É–ø—É—â–µ–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                console.log("–ò–≥—Ä–æ–∫ —É–ø—É—Å—Ç–∏–ª –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ö–∞—Ä—Å–µ–¥–æ!");
            }
            lastCelestiniBuffs = [];
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–µ—Ä–∞ (–∏–≥—Ä–æ–∫ –ø–∞—Å—É–µ—Ç)
            playerJustUsedCoach = false;
            
            // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥ –ø–∞—Å–∞
            playerPassed = true;
            
            // Remove urgent pulse animation from coach if present
            const coachCardElement = playerDefenseRightSlot?.querySelector('.coach-card');
            if (coachCardElement) {
                coachCardElement.classList.remove('coach-urgent');
            }
            
            // –ë–ª–æ–∫–∏—Ä—É–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Ö–æ–¥–∏—Ç—å
            isPlayerTurn = false;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
            updatePassButtonState();
            
            // Check if enemy can still play (has cards OR has active coach)
            // Filter by !used to be safe
            const enemyHasCards = enemyCards.filter(c => !c.used).length > 0;
            const enemyHasCoach = currentEnemyCoach && currentEnemyCoach.isUsed === false;

            if (!enemyPassed && (enemyHasCards || enemyHasCoach)) {
                // Enemy is still in the game -> Trigger their turn
                setTimeout(() => {
                    enemyTurn();
                }, 1000);
            } else {
                // Enemy is finished -> Check for round end
                checkRoundEndCondition();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∞–∫–∫–æ—Ä–¥–µ–æ–Ω–∞ –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è
        function updateAccordionState() {
            const gameBoard = document.querySelector('.game-board');
            if (!gameBoard) return;
            
            if (isPlayerTurn) {
                // –•–æ–¥ –∏–≥—Ä–æ–∫–∞
                gameBoard.classList.add('state-player-turn');
                gameBoard.classList.remove('state-opponent-turn');
            } else {
                // –•–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞
                gameBoard.classList.add('state-opponent-turn');
                gameBoard.classList.remove('state-player-turn');
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–∫–∏ "–ü–∞—Å"
        function updatePassButtonState() {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∞–∫–∫–æ—Ä–¥–µ–æ–Ω–∞
            updateAccordionState();
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–µ—Ä–∞
            const hasActiveCoach = playerDefenseRightSlot && playerDefenseRightSlot.querySelector('.coach-card:not(.used)');
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –ø–∞—Å–∞
            if (myCards.length === 0 && !playerPassed && !hasActiveCoach) {
                // –ö–∞—Ä—Ç—ã –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å –∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç—Ä–µ–Ω–µ—Ä–∞ - –±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
                passButton.disabled = true;
                passButton.textContent = '–ö–∞—Ä—Ç –Ω–µ—Ç';
            } else if (playerPassed) {
                // –ò–≥—Ä–æ–∫ —Å–ø–∞—Å–æ–≤–∞–ª
                passButton.disabled = true;
                passButton.textContent = '–ü–∞—Å';
            } else if (isPlayerTurn && (myCards.length > 0 || hasActiveCoach)) {
                // –•–æ–¥ –∏–≥—Ä–æ–∫–∞ –∏ —É –Ω–µ–≥–æ –µ—Å—Ç—å –∫–∞—Ä—Ç—ã –ò–õ–ò –∞–∫—Ç–∏–≤–Ω—ã–π —Ç—Ä–µ–Ω–µ—Ä - –∫–Ω–æ–ø–∫–∞ –∞–∫—Ç–∏–≤–Ω–∞ (–¥–∞–∂–µ –µ—Å–ª–∏ –±–æ—Ç –ø–∞—Å–∞–Ω—É–ª)
                passButton.disabled = false;
                passButton.textContent = '–ü–ê–°';
            } else {
                // –ù–µ —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞ - –±–ª–æ–∫–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É
                passButton.disabled = true;
                passButton.textContent = '–ü–ê–°';
            }
        }
        
        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
        // –í–ê–ñ–ù–û: –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∏–≥—Ä—ã
        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
        // –ì–ª–æ–±–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
        function checkRoundEndCondition() {
            // –í–ê–ñ–ù–û: –ï—Å–ª–∏ –∏–¥–µ—Ç –∞–Ω–∏–º–∞—Ü–∏—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ —Ç—Ä–µ–Ω–µ—Ä–∞, –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
            if (isAbilityAnimating) {
                return;
            }
            
            // –í–ê–ñ–ù–û: –ï—Å–ª–∏ –∏–¥–µ—Ç –¥–æ–±–æ—Ä –∫–∞—Ä—Ç —à–ø–∏–æ–Ω–æ–º, –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
            if (isSpyDrawing) {
                return;
            }
            
            // --- CORRECT RESOURCE CHECK ---
            // Fix: Check for UNUSED cards, not just array length
            
            const playerEmpty = myCards.length === 0; // Player cards are usually spliced, so length 0 is fine
            const enemyEmpty = enemyCards.filter(c => !c.used).length === 0; // Enemy cards are marked used, so filter them
            
            // Check global state objects strictly
            const playerCoachActive = currentPlayerCoach && currentPlayerCoach.isUsed === false;
            const enemyCoachActive = currentEnemyCoach && currentEnemyCoach.isUsed === false;

            // HARD CHECK: –ï—Å–ª–∏ —É –æ–±–æ–∏—Ö –∫–æ–Ω—á–∏–ª–∏—Å—å –∫–∞—Ä—Ç—ã –ò —Ç—Ä–µ–Ω–µ—Ä—ã —É–∂–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã -> –ö–û–ù–ï–¶
            if (playerEmpty && !playerCoachActive && enemyEmpty && !enemyCoachActive) {
                console.log('HARD CHECK: –í—Å–µ —Ä–µ—Å—É—Ä—Å—ã –∏—Å—á–µ—Ä–ø–∞–Ω—ã. –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞—É–Ω–¥–∞.');
                endRound();
                return;
            }
            
            // --- STANDARD LOGIC (–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Ñ–ª–∞–≥–æ–≤) ---

            // 1. –ê–≤—Ç–æ-–ø–∞—Å –ò–≥—Ä–æ–∫–∞
            if (playerEmpty && !playerPassed && !playerCoachActive) {
                playerPassed = true;
                isPlayerTurn = false;
                updatePassButtonState();
                console.log('Auto-pass: Player set to passed');
            }
            
            // 2. –ê–≤—Ç–æ-–ø–∞—Å –ë–æ—Ç–∞
            // REMOVED: This block silently set enemyPassed = true, skipping the visual turn.
            // Now we rely on enemyTurn() to handle pass logic and show notifications.
            /*
            if (enemyEmpty && !enemyPassed && !enemyCoachActive) {
                // –ï—Å–ª–∏ –±–æ—Ç –µ—â–µ –Ω–µ –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ —Å–ø–∞—Å–æ–≤–∞–≤—à–∏–π, –ø–æ–º–µ—á–∞–µ–º
                if (!enemyPassed) {
                    enemyPassed = true;
                    console.log('Auto-pass: Enemy set to passed (cards ran out)');
                }
                
                // –ö–†–ò–¢–ò–ß–ù–û: –ï—Å–ª–∏ –±–æ—Ç –∑–∞–∫–æ–Ω—á–∏–ª, –∞ —É –∏–≥—Ä–æ–∫–∞ –µ—â–µ –µ—Å—Ç—å –∫–∞—Ä—Ç—ã ‚Äî –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫—É
                if (!playerEmpty || playerCoachActive) {
                    if (!playerPassed) {
                         console.log('Auto-pass trigger: Returning control to player');
                         isPlayerTurn = true;
                         updatePassButtonState();
                    }
                }
            }
            */
            
            // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ —Ñ–ª–∞–≥–∞–º (–Ω–∞ —Å–ª—É—á–∞–π, –µ—Å–ª–∏ –∫—Ç–æ-—Ç–æ –Ω–∞–∂–∞–ª –ø–∞—Å —Å –∫–∞—Ä—Ç–∞–º–∏ –Ω–∞ —Ä—É–∫–∞—Ö)
            const playerFinished = playerPassed || (playerEmpty && !playerCoachActive);
            const enemyFinished = enemyPassed || (enemyEmpty && !enemyCoachActive);
            
            if (playerFinished && enemyFinished) {
                console.log('Flag Check: –û–±–∞ –∏–≥—Ä–æ–∫–∞ —Å–ø–∞—Å–æ–≤–∞–ª–∏ –∏–ª–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏.');
                endRound();
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–∞—Å–æ–≤ (–æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
        function checkAutoPass() {
            // –í–ê–ñ–ù–û: –ï—Å–ª–∏ –∏–¥–µ—Ç –¥–æ–±–æ—Ä –∫–∞—Ä—Ç —à–ø–∏–æ–Ω–æ–º, –Ω–µ –≤—ã–ø–æ–ª–Ω—è–µ–º –ø—Ä–æ–≤–µ—Ä–∫–∏
            if (isSpyDrawing) {
                console.log('DEBUG checkAutoPass: –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É - –∏–¥–µ—Ç –¥–æ–±–æ—Ä –∫–∞—Ä—Ç —à–ø–∏–æ–Ω–æ–º');
                return false;
            }
            
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—É—é —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–æ–≤–µ—Ä–∫–∏
            checkRoundEndCondition();
            
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true –µ—Å–ª–∏ —Ä–∞—É–Ω–¥ –∑–∞–≤–µ—Ä—à–µ–Ω (—É—á–∏—Ç—ã–≤–∞—è –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç—Ä–µ–Ω–µ—Ä–æ–≤)
            const hasActivePlayerCoach = currentPlayerCoach && currentPlayerCoach.isUsed === false;
            const hasActiveEnemyCoach = currentEnemyCoach && currentEnemyCoach.isUsed === false;
            const playerFinished = playerPassed || (myCards.length === 0 && !hasActivePlayerCoach);
            const enemyFinished = enemyPassed || (enemyCards.filter(c => !c.used).length === 0 && !hasActiveEnemyCoach);
            return playerFinished && enemyFinished;
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –ø–∞—Å–∞
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –æ–±—ã—á–Ω—É—é –∫–Ω–æ–ø–∫—É –ø–∞—Å–∞
        passButton.addEventListener('click', handlePassAction);
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
        // DEBUG / EMERGENCY FIX: Force AI Move
        // FIXED EMERGENCY KICK BUTTON
        document.getElementById('ingame-settings-btn').addEventListener('click', function() {
            // 1. Safety: Prevent clicking during Player's turn
            if (isPlayerTurn && !playerPassed) {
                showGameNotification("–°–µ–π—á–∞—Å –≤–∞—à —Ö–æ–¥! –ö–Ω–æ–ø–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞.", "info");
                return;
            }

            console.warn("--- EMERGENCY AI KICK ---");
            showGameNotification("–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–∏–Ω–æ–∫ –±–æ—Ç–∞...", "warning");
            
            // 2. Reset ALL locking flags (Fixes "Waiting for animation" freezes)
            isAbilityAnimating = false;
            isSpyDrawing = false;
            isProcessingRoundEnd = false;
            
            // 3. Force AI Turn
            // We set isPlayerTurn to false to ensure the game knows it's the bot's go
            isPlayerTurn = false; 
            updateAccordionState();
            
            // Small delay to ensure UI updates before heavy logic
            setTimeout(() => {
                console.log("Kicking AI logic...");
                // We assume the Fail-Safe inside enemyTurn (Step 2) will handle the rest
                enemyTurn(); 
            }, 200);
        });
        
        // –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ–∫–æ–Ω—á–∞–Ω–∏—è —Ä–∞—É–Ω–¥–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç –Ω–æ–≤—É—é –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é)
        function checkRoundEnd() {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–æ–≤–µ—Ä–∫–∏ —É—Å–ª–æ–≤–∏–π –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
            checkRoundEndCondition();
            
            // –ï—Å–ª–∏ —Ä–∞—É–Ω–¥ –Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω –∏ –∏–≥—Ä–æ–∫ –ø–∞—Å–∞–Ω—É–ª, –∑–∞–ø—É—Å–∫–∞–µ–º —Ö–æ–¥ –±–æ—Ç–∞
            if (playerPassed && !enemyPassed && enemyCards.length > 0) {
                // –ò–≥—Ä–æ–∫ —Å–ø–∞—Å–æ–≤–∞–ª, –±–æ—Ç –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç —Ö–æ–¥–∏—Ç—å
                // –õ–æ–≥–∏–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è —Ö–æ–¥–∞ –±–æ—Ç–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏–∏ enemyTurn
                // –ó–∞–ø—É—Å–∫–∞–µ–º —Ö–æ–¥ –±–æ—Ç–∞, –µ—Å–ª–∏ –æ–Ω –µ—â–µ –Ω–µ –ø–∞—Å–∞–Ω—É–ª
                if (!enemyPassed) {
                    setTimeout(() => {
                        isPlayerTurn = false;
                        enemyTurn();
                    }, 1000);
                }
            }
        }
        
        // –ü–∞—Å—Å–∏–≤–Ω–æ–µ —É–º–µ–Ω–∏–µ "–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞": –≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä—Ç—ã –∏–∑ –æ—Ç–±–æ—è –ø–µ—Ä–µ–¥ 3-–º —Ä–∞—É–Ω–¥–æ–º
        async function triggerStarsPassive() {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —ç—Ç–æ 3-–π —Ä–∞—É–Ω–¥
            if (currentRound !== 3) return;
            
            // 1. –°–Ω–∞—á–∞–ª–∞ –ò–≥—Ä–æ–∫ (–ø–æ–ª–Ω–æ—Å—Ç—å—é –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è)
            await executeSingleResurrection(true);
            
            // 2. –ó–∞—Ç–µ–º –ë–æ—Ç (–∂–¥–µ—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–≥—Ä–æ–∫–∞)
            await executeSingleResurrection(false);
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏—è –æ–¥–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω—ã
        async function executeSingleResurrection(isPlayerSide) {
            return new Promise((resolve) => {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –º–∞—Å—Å–∏–≤ –æ—Ç–±–æ—è –∏ —Ñ—Ä–∞–∫—Ü–∏—é
                const teamKey = isPlayerSide ? playerTeamKey : enemyTeamKey;
                const graveyard = isPlayerSide ? playerGraveyardCards : enemyGraveyardCards;
                const graveyardElement = isPlayerSide ? playerGraveyard : enemyGraveyard;
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏–µ: —Ç–µ–∫—É—â–∞—è –∫–æ–º–∞–Ω–¥–∞ == 'allFootballStarsCards'
                if (teamKey !== 'allFootballStarsCards') {
                    resolve();
                    return;
                }
                
                // –ù–∞—Ö–æ–¥–∏–º –≤–∞–ª–∏–¥–Ω—ã–µ –∫–∞—Ä—Ç—ã (—Ñ–∏–ª—å—Ç—Ä: –Ω–µ –≥–µ—Ä–æ–∏, –Ω–µ support)
                const validCards = graveyard.filter(card => 
                    !card.isHero && 
                    card.cardtype !== 'hero' && 
                    card.ability !== 'support'
                );
                
                // –ï—Å–ª–∏ –∫–∞—Ä—Ç –Ω–µ—Ç ‚Äî –≤—ã–≤–æ–¥–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏ –¥–µ–ª–∞–µ–º resolve()
                if (validCards.length === 0) {
                    if (isPlayerSide) {
                        showGameNotification("–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞: –ù–µ–∫–æ–≥–æ –≤–æ—Å–∫—Ä–µ—à–∞—Ç—å", 'info');
                    }
                    resolve();
                    return;
                }
                
                // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—É—é –∫–∞—Ä—Ç—É
                const randomIndex = Math.floor(Math.random() * validCards.length);
                const selectedCard = validCards[randomIndex];
                
                // 1. –í—ã–≤–æ–¥–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
                if (isPlayerSide) {
                    showGameNotification("–ü–∞—Å—Å–∏–≤–Ω–æ–µ —É–º–µ–Ω–∏–µ: –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –∏–∑ –æ—Ç–±–æ—è!", 'success');
                } else {
                    showGameNotification("–°–æ–ø–µ—Ä–Ω–∏–∫ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø–∞—Å—Å–∏–≤–Ω–æ–µ —É–º–µ–Ω–∏–µ!", 'warning');
                }
                
                // 2. –ü–µ—Ä–µ–º–µ—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –∏–∑ –º–∞—Å—Å–∏–≤–∞ –æ—Ç–±–æ—è –≤ –º–∞—Å—Å–∏–≤ –ø–æ–ª—è
                const cardIndex = graveyard.findIndex(c => c.id === selectedCard.id);
                if (cardIndex !== -1) {
                    graveyard.splice(cardIndex, 1);
                }
                
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ä—è–¥ –¥–ª—è –∫–∞—Ä—Ç—ã
                let targetRowId = selectedCard.position;
                if (!targetRowId || targetRowId === 'any') {
                    // –ï—Å–ª–∏ –ø–æ–∑–∏—Ü–∏—è any, –≤—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —Ä—è–¥ (–∫—Ä–æ–º–µ —Ç–∞–∫—Ç–∏–∫–∏)
                    const rows = ['attack', 'midfield', 'defense'];
                    targetRowId = rows[Math.floor(Math.random() * rows.length)];
                }
                
                // --- –õ–û–ì–ò–ö–ê –û–ü–†–ï–î–ï–õ–ï–ù–ò–Ø –°–¢–û–†–û–ù–´ (Fix for Spies) ---
                // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –∫–∞—Ä—Ç–∞ –∏–¥–µ—Ç —Ç–æ–º—É, —á—å—è –ø–∞—Å—Å–∏–≤–∫–∞ —Å—Ä–∞–±–æ—Ç–∞–ª–∞
                let destinationIsPlayer = isPlayerSide;
                
                // –ù–û –µ—Å–ª–∏ —ç—Ç–æ –®–ø–∏–æ–Ω, –æ–Ω –≤—Å–µ–≥–¥–∞ –ª–µ—Ç–∏—Ç –Ω–∞ –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—É—é —Å—Ç–æ—Ä–æ–Ω—É
                if (selectedCard.ability === 'spy') {
                    destinationIsPlayer = !isPlayerSide;
                }

                // –í—ã–±–∏—Ä–∞–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –¥–∞–Ω–Ω—ã—Ö –∏ DOM-—ç–ª–µ–º–µ–Ω—Ç —Ä—è–¥–∞
                const targetFieldArray = destinationIsPlayer ? playerCardsOnField : enemyCardsOnField;
                const targetRowElement = destinationIsPlayer ? getTargetRow(targetRowId) : getEnemyTargetRow(targetRowId);

                if (!targetRowElement) {
                    console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —Ü–µ–ª–µ–≤–æ–π —Ä—è–¥ –¥–ª—è –ø–∞—Å—Å–∏–≤–Ω–æ–≥–æ —É–º–µ–Ω–∏—è');
                    resolve();
                    return;
                }
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –º–∞—Å—Å–∏–≤ –Ω–∞ –ø–æ–ª–µ
                targetFieldArray.push({
                    cardData: selectedCard,
                    rowId: targetRowId
                });
                
                // 3. –°–æ–∑–¥–∞–µ–º DOM-—ç–ª–µ–º–µ–Ω—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
                // –í–∞–∂–Ω–æ: –ø–µ—Ä–µ–¥–∞–µ–º targetRowElement, –∫–æ—Ç–æ—Ä—ã–π –º—ã —Ç–æ–ª—å–∫–æ —á—Ç–æ –≤—ã—á–∏—Å–ª–∏–ª–∏ —Å —É—á–µ—Ç–æ–º —à–ø–∏–æ–Ω–∞
                animateCardFromGraveyard(selectedCard, graveyardElement, targetRowElement, targetRowId, isPlayerSide, async () => {
                    // 1. –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç –∏ –≤–∏–∑—É–∞–ª (–æ–±—â–∞—è —á–∞—Å—Ç—å)
                    updatePlayerScore();
                    updateEnemyScore();
                    updateGraveyardVisuals();
                    
                    const cardName = selectedCard.name;
                    const isMirrorMatch = (playerTeamKey === 'allFootballStarsCards' && enemyTeamKey === 'allFootballStarsCards');

                    // --- SPY (–®–ü–ò–û–ù) ---
                    if (selectedCard.ability === 'spy') {
                        if (isPlayerSide) {
                            showGameNotification(`${cardName}: –®–ø–∏–æ–Ω –≤–µ—Ä–Ω—É–ª—Å—è! –î–æ–±–æ—Ä 2 –∫–∞—Ä—Ç.`, 'success');
                            const newCards = drawCardsFromPlayerDeck(2);
                            if (newCards.length > 0) {
                                myCards.push(...newCards);
                                renderPlayerHand();
                                updateHandLayout();
                                const pDeck = document.getElementById('playerDeck');
                                if (pDeck) animateCardsFromDeck(newCards, pDeck);
                            }
                        } else {
                            // –õ–û–ì–ò–ö–ê –ë–û–¢–ê
                            showGameNotification("–ë–æ—Ç –≤–µ—Ä–Ω—É–ª –®–ø–∏–æ–Ω–∞! –î–æ–±–æ—Ä 2 –∫–∞—Ä—Ç.", 'error');
                            const newCards = drawCardsFromEnemyDeck(2);
                            if (newCards.length > 0) {
                                enemyCards.push(...newCards);
                                updateEnemyDeckCounter();
                                
                                const eDeck = document.getElementById('enemyDeck');
                                if (eDeck) {
                                    animateCardsFromEnemyDeck(newCards, eDeck, () => {
                                        renderEnemyHand(); 
                                        renderOpponentHand();
                                    });
                                } else {
                                    renderEnemyHand();
                                    renderOpponentHand();
                                }
                            }
                        }
                    }
                    
                    // --- MEDIC (–ú–ï–î–ò–ö) ---
                    else if (selectedCard.ability === 'medic') {
                        if (isPlayerSide) {
                            const hasTargets = playerGraveyardCards.some(c => isRevivable(c));
                            if (hasTargets) {
                                showGameNotification(`${cardName}: –í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–≥–æ –≤–æ—Å–∫—Ä–µ—Å–∏—Ç—å!`, 'warning');
                                isMedicResurrecting = true;
                                openGraveyardView('player', 'medic');
                            } else {
                                showGameNotification(`${cardName}: –ù–µ–∫–æ–≥–æ –≤–æ—Å–∫—Ä–µ—à–∞—Ç—å.`, 'info');
                            }
                        } else {
                            // –õ–û–ì–ò–ö–ê –ë–û–¢–ê
                            // –ë–æ—Ç –ø—ã—Ç–∞–µ—Ç—Å—è —Å—ã–≥—Ä–∞—Ç—å –º–µ–¥–∏–∫–∞ —Å–Ω–æ–≤–∞
                            await aiPlayMedic(selectedCard);
                        }
                    }
                    
                    // --- PROVOCATEUR (–ü–†–û–í–û–ö–ê–¢–û–†) ---
                    else if (selectedCard.ability === 'provocateur') {
                         if (isMirrorMatch) {
                             showGameNotification(`${cardName}: –≠—Ñ—Ñ–µ–∫—Ç –ø—Ä–æ–ø—É—â–µ–Ω (–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≤—ã—Ö–æ–¥)`, 'info');
                         } else {
                             await executeProvocateur(selectedCard, targetRowId, isPlayerSide);
                         }
                    }
                    
                    // --- RED CARD (–ö–†–ê–°–ù–ê–Ø –ö–ê–†–¢–û–ß–ö–ê) ---
                    else if (selectedCard.ability === 'redcard') {
                         if (isMirrorMatch) {
                             showGameNotification(`${cardName}: –≠—Ñ—Ñ–µ–∫—Ç –ø—Ä–æ–ø—É—â–µ–Ω (–æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≤—ã—Ö–æ–¥)`, 'info');
                         } else {
                             await executeRedCard(selectedCard, isPlayerSide);
                         }
                    }

                    // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø—Ä–æ–º–∏—Å
                    resolve();
                });
            });
        }
        
        // –ê–Ω–∏–º–∞—Ü–∏—è –ø–æ–ª–µ—Ç–∞ –∫–∞—Ä—Ç—ã –∏–∑ –æ—Ç–±–æ—è –Ω–∞ –ø–æ–ª–µ
        function animateCardFromGraveyard(cardData, graveyardElement, targetRow, rowId, isPlayer, onComplete) {
            if (!graveyardElement || !targetRow) {
                if (onComplete) onComplete();
                return;
            }
            
            const graveyardRect = graveyardElement.getBoundingClientRect();
            const imageSrc = (cardData.miniImg && cardData.miniImg.trim() !== "") ? cardData.miniImg : cardData.img;
            
            // –†–∞–∑–º–µ—Ä—ã –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
            let fieldCardWidth = window.innerWidth <= 480 ? 40 : 45;
            if (window.innerWidth <= 360) fieldCardWidth = 35;
            let fieldCardHeight = fieldCardWidth * 1.4;
            
            // 1. –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—É—é –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ (opacity: 0)
            const fieldCard = document.createElement('div');
            fieldCard.className = 'card-on-field';
            fieldCard.setAttribute('data-card-id', cardData.id);
            fieldCard.setAttribute('data-full-img', cardData.img);
            fieldCard.style.opacity = '0'; // –°–∫—Ä—ã—Ç–∞ –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
            
            if (cardData.isHero || cardData.cardtype === 'hero') {
                fieldCard.classList.add('hero');
            }
            
            const fieldCardImage = document.createElement('img');
            fieldCardImage.src = imageSrc;
            fieldCardImage.alt = cardData.name;
            fieldCard.appendChild(fieldCardImage);
            
            // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏–Ω—Å–ø–µ–∫—Ü–∏—é
            addInspectionEvents(fieldCard, cardData.img);
            addFieldPowerBadge(fieldCard, cardData);
            
            // –í—Å—Ç–∞–≤–ª—è–µ–º –≤ —Ä—è–¥ (—Å–∫—Ä—ã—Ç—É—é)
            insertCardSmartly(targetRow, fieldCard);
            
            // –û–±–Ω–æ–≤–ª—è–µ–º layout, —á—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
            updateRowLayout(targetRow);
            
            // –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –ø–æ–∑–∏—Ü–∏—é —Å–∫—Ä—ã—Ç–æ–π –∫–∞—Ä—Ç—ã
            const fieldCardRect = fieldCard.getBoundingClientRect();
            const targetCenterX = fieldCardRect.left + fieldCardRect.width / 2;
            const targetCenterY = fieldCardRect.top + fieldCardRect.height / 2;
            
            // 2. –°–æ–∑–¥–∞–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É (–∏–∑ –æ—Ç–±–æ—è)
            const flyingCard = document.createElement('div');
            flyingCard.className = 'card-flying';
            
            // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è (—Ü–µ–Ω—Ç—Ä –æ—Ç–±–æ—è)
            const startX = graveyardRect.left + graveyardRect.width / 2;
            const startY = graveyardRect.top + graveyardRect.height / 2;
            
            // –†–∞–∑–º–µ—Ä—ã –≤ –æ—Ç–±–æ–µ (–º–∞–ª–µ–Ω—å–∫–∏–µ)
            const startWidth = 60;
            const startHeight = 84;
            
            Object.assign(flyingCard.style, {
                position: 'fixed',
                width: startWidth + 'px',
                height: startHeight + 'px',
                left: startX + 'px',
                top: startY + 'px',
                borderRadius: '8px',
                overflow: 'hidden',
                boxShadow: '0 4px 12px rgba(0,0,0,0.6)',
                zIndex: '99999',
                transform: 'translate(-50%, -50%)',
                transition: 'none',
                pointerEvents: 'none'
            });
            
            const flyingImg = document.createElement('img');
            flyingImg.src = imageSrc;
            flyingImg.style.width = '100%';
            flyingImg.style.height = '100%';
            flyingImg.style.objectFit = 'cover';
            flyingCard.appendChild(flyingImg);
            document.body.appendChild(flyingCard);
            
            // 3. –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–æ–ª–µ—Ç–∞
            requestAnimationFrame(() => {
                flyingCard.style.transition = 'all 0.8s ease-in-out';
                flyingCard.style.left = targetCenterX + 'px';
                flyingCard.style.top = targetCenterY + 'px';
                flyingCard.style.width = fieldCardWidth + 'px';
                flyingCard.style.height = fieldCardHeight + 'px';
            });
            
            // 4. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–∏ (—á–µ—Ä–µ–∑ 800ms)
            setTimeout(() => {
                // –£–¥–∞–ª—è–µ–º –ª–µ—Ç—è—â—É—é –∫–∞—Ä—Ç—É
                flyingCard.remove();
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ
                fieldCard.style.transition = 'opacity 0.3s ease';
                fieldCard.style.opacity = '1';
                
                // –û–±–Ω–æ–≤–ª—è–µ–º layout —Ä—è–¥–∞
                updateRowLayout(targetRow);
                
                if (onComplete) onComplete();
            }, 800);
        }
        
        // –ü—É—Å—Ç–∞—è –∑–∞–≥–ª—É—à–∫–∞ –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ —ç—Ç–∞–ø–∞
        async function prepareNextRound() {
            console.log(`--- –ü–û–î–ì–û–¢–û–í–ö–ê –ö –†–ê–£–ù–î–£ ${currentRound} ---`);
            
            // –ü–ê–°–°–ò–í–ù–û–ï –£–ú–ï–ù–ò–ï: –ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞ - –≤–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä—Ç—ã –∏–∑ –æ—Ç–±–æ—è –ø–µ—Ä–µ–¥ 3-–º —Ä–∞—É–Ω–¥–æ–º
            await triggerStarsPassive();
            
            // --- FIX: VISUAL SYNC FOR COACHES ---
            // Ensure that if the coach is used in data, it looks used visually
            if (currentPlayerCoach && currentPlayerCoach.isUsed) {
                const pCard = playerDefenseRightSlot?.querySelector('.coach-card');
                if (pCard) {
                    pCard.classList.add('used');
                    pCard.classList.remove('coach-urgent');
                }
            }
            if (currentEnemyCoach && currentEnemyCoach.isUsed) {
                const eCard = enemyDefenseRightSlot?.querySelector('.coach-card');
                if (eCard) eCard.classList.add('used');
            }
            // ------------------------------------
            
            // –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞
            isProcessingRoundEnd = false;
            
            // 1. –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤ –ø–∞—Å–∞
            playerPassed = false;
            enemyPassed = false;
            
            // 2. –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, –∫—Ç–æ —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º –≤ —ç—Ç–æ–º —Ä–∞—É–Ω–¥–µ
            let roundStarter = 'player';
            
            if (currentRound === 2) {
                // –í–æ 2-–º —Ä–∞—É–Ω–¥–µ —Ö–æ–¥–∏—Ç —Ç–æ—Ç, –∫—Ç–æ –ù–ï –Ω–∞—á–∏–Ω–∞–ª –º–∞—Ç—á (—Å–º–µ–Ω–∞)
                roundStarter = (matchStarter === 'player') ? 'enemy' : 'player';
            } else {
                // –í 3-–º —Ä–∞—É–Ω–¥–µ —Ö–æ–¥–∏—Ç —Ç–æ—Ç –∂–µ, –∫—Ç–æ –Ω–∞—á–∏–Ω–∞–ª –º–∞—Ç—á (–∫–∞–∫ –≤ 1-–º)
                roundStarter = matchStarter;
            }
            
            isPlayerTurn = (roundStarter === 'player');
            
            showGameNotification(`–†–∞—É–Ω–¥ ${currentRound}. –•–æ–¥–∏—Ç ${isPlayerTurn ? '–ò–≥—Ä–æ–∫' : '–°–æ–ø–µ—Ä–Ω–∏–∫'}!`, 'info');
            updatePassButtonState();
            updateAccordionState(); // –û–±–Ω–æ–≤–∏—Ç—å –≤–∏–∑—É–∞–ª –∞–∫—Ç–∏–≤–Ω–æ–π –∑–æ–Ω—ã
            
            // --- FIX: CHECK FOR EMPTY START ---
            // If it's Player's turn to start, but Player has NO cards and NO Coach,
            // we must Auto-Pass immediately to prevent the game from freezing.
            if (isPlayerTurn) {
                const hasCards = myCards.length > 0;
                const hasActiveCoach = currentPlayerCoach && currentPlayerCoach.isUsed === false;
                
                if (!hasCards && !hasActiveCoach) {
                    console.log("Start of Round: Player has no resources (Coach used). Auto-passing.");
                    playerPassed = true;
                    isPlayerTurn = false;
                    updatePassButtonState();
                    
                    // Remove any stuck urgent animations just in case
                    const playerDefenseRightSlot = document.getElementById('playerDefenseRightSlot');
                    const coachCard = playerDefenseRightSlot?.querySelector('.coach-card');
                    if (coachCard) coachCard.classList.remove('coach-urgent');

                    showGameNotification("–£ –≤–∞—Å –Ω–µ—Ç –∫–∞—Ä—Ç. –ê–≤—Ç–æ-–ø–∞—Å.", 'info');
                    
                    // Pass control to enemy or end round
                    checkRoundEnd(); 
                    return; 
                }
            }
            // ----------------------------------
            
            // Check Enemy Start Conditions
            if (!isPlayerTurn) {
                // 1. Check Resources
                const enemyHasCards = enemyCards.filter(c => !c.used).length > 0;
                const enemyHasActiveCoach = currentEnemyCoach && currentEnemyCoach.isUsed === false;

                if (!enemyHasCards && !enemyHasActiveCoach) {
                    console.log("Start of Round: Enemy has no resources. Auto-passing.");
                    enemyPassed = true;
                    showGameNotification("–£ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–µ—Ç –∫–∞—Ä—Ç. –ê–≤—Ç–æ-–ø–∞—Å.", 'info');
                    
                    // Check if this ends the round immediately (if player is also done)
                    checkRoundEndCondition();
                    
                    // If round continues (meaning Player has cards), pass control to Player
                    if (!playerPassed) {
                        console.log("Passing control to Player.");
                        isPlayerTurn = true;
                        updatePassButtonState();
                        updateAccordionState();
                    }
                } else {
                    // Normal start: Enemy has resources, proceed to turn after delay
                    setTimeout(enemyTurn, 1500);
                }
            }
            
            // –í–ê–ñ–ù–û: –ó–¥–µ—Å—å –ø–æ–∑–∂–µ –¥–æ–±–∞–≤–∏–º –ª–æ–≥–∏–∫—É –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–æ–ª–∞ –∏ –¥–æ–±–æ—Ä–∞ –∫–∞—Ä—Ç, 
            // –ø–æ–∫–∞ –æ—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ª–æ–≥–∏–∫—É —Ö–æ–¥–∞.
        }

        function endRound() {
            // 1. Safety Check (Keep immediate)
            if (isProcessingRoundEnd) {
                console.warn('endRound() —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è. –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –ø–æ–≤—Ç–æ—Ä–Ω—ã–π –≤—ã–∑–æ–≤.');
                return;
            }
            isProcessingRoundEnd = true;
            
            console.log(`–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –†–∞—É–Ω–¥–∞ ${currentRound} (–ü–∞—É–∑–∞ 1 —Å–µ–∫ –ø–µ—Ä–µ–¥ –∏—Ç–æ–≥–æ–º...)`);

            // 2. THE SUSPENSE DELAY (1000ms)
            setTimeout(() => {
                
                // --- PHASE 1: DETERMINATION & NOTIFICATION ---
                let roundWinner = 'draw';
                
                if (totalScore > enemyScore) {
                    playerMatchWins++;
                    roundWinner = 'player';
                    showGameNotification("–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ —Ä–∞—É–Ω–¥!", 'success');
                    
                    // –ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞: +1 –∫–∞—Ä—Ç–∞ –∑–∞ –ø–æ–±–µ–¥—É –≤ —Ä–∞—É–Ω–¥–µ
                    // –í—ã–¥–∞–µ–º –±–æ–Ω—É—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–∞—Ç—á –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è (–Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞—É–Ω–¥ –∏ —É –∏–≥—Ä–æ–∫–∞ –º–µ–Ω—å—à–µ 2 –ø–æ–±–µ–¥)
                    if (playerTeamKey === 'allSpartakCards' && myDeck.length > 0 && currentRound < 3 && playerMatchWins < 2) {
                        const bonusCard = drawCardsFromPlayerDeck(1);
                        if (bonusCard.length > 0) {
                            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã: —É–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –∫–∞—Ä—Ç–∞ –µ—â–µ –Ω–µ –≤ —Ä—É–∫–µ
                            const bonusCardId = bonusCard[0].id;
                            const isDuplicate = myCards.some(card => card.id === bonusCardId);
                            
                            if (isDuplicate) {
                                console.warn(`–ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞: –ö–∞—Ä—Ç–∞ —Å ID ${bonusCardId} —É–∂–µ –µ—Å—Ç—å –≤ —Ä—É–∫–µ. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç.`);
                                // –ü—ã—Ç–∞–µ–º—Å—è –≤–∑—è—Ç—å —Å–ª–µ–¥—É—é—â—É—é –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã, –µ—Å–ª–∏ –æ–Ω–∞ –µ—Å—Ç—å
                                if (myDeck.length > 0) {
                                    const alternativeCard = drawCardsFromPlayerDeck(1);
                                    if (alternativeCard.length > 0 && alternativeCard[0].id !== bonusCardId) {
                                        const altIsDuplicate = myCards.some(card => card.id === alternativeCard[0].id);
                                        if (!altIsDuplicate) {
                                            myCards.push(...alternativeCard);
                                            showGameNotification("–ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞: +1 –∫–∞—Ä—Ç–∞!", 'success');
                                            updatePlayerDeckCounter();
                                            renderPlayerHand();
                                            
                                            if (playerDeck) {
                                                animateCardsFromDeck(alternativeCard, playerDeck, () => {
                                                    updatePlayerDeckCounter();
                                                });
                                            }
                                        } else {
                                            console.warn(`–ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –∫–∞—Ä—Ç–∞ —Ç–æ–∂–µ –¥—É–±–ª–∏–∫–∞—Ç. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –±–æ–Ω—É—Å.`);
                                        }
                                    }
                                }
                            } else {
                                myCards.push(...bonusCard);
                                showGameNotification("–ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞: +1 –∫–∞—Ä—Ç–∞!", 'success');
                                updatePlayerDeckCounter();
                                renderPlayerHand();
                                
                                // –ê–Ω–∏–º–∏—Ä—É–µ–º –∫–∞—Ä—Ç—É –∏–∑ –∫–æ–ª–æ–¥—ã
                                if (playerDeck) {
                                    animateCardsFromDeck(bonusCard, playerDeck, () => {
                                        updatePlayerDeckCounter();
                                    });
                                }
                            }
                        }
                    }
                } else if (enemyScore > totalScore) {
                    enemyMatchWins++;
                    roundWinner = 'enemy';
                    showGameNotification("–°–æ–ø–µ—Ä–Ω–∏–∫ –≤—ã–∏–≥—Ä–∞–ª —Ä–∞—É–Ω–¥!", 'error');
                    
                    // –ë–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞ –¥–ª—è —Å–æ–ø–µ—Ä–Ω–∏–∫–∞: +1 –∫–∞—Ä—Ç–∞ –∑–∞ –ø–æ–±–µ–¥—É –≤ —Ä–∞—É–Ω–¥–µ
                    // –í—ã–¥–∞–µ–º –±–æ–Ω—É—Å —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –º–∞—Ç—á –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è (–Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ä–∞—É–Ω–¥ –∏ —É —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –º–µ–Ω—å—à–µ 2 –ø–æ–±–µ–¥)
                    if (enemyTeamKey === 'allSpartakCards' && currentRound < 3 && enemyMatchWins < 2) {
                        const enemyBonusCard = drawCardsFromEnemyDeck(1);
                        if (enemyBonusCard.length > 0) {
                            enemyCards.push(...enemyBonusCard);
                            showGameNotification("–°–æ–ø–µ—Ä–Ω–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –±–æ–Ω—É—Å –°–ø–∞—Ä—Ç–∞–∫–∞!", 'error');
                            
                            // FIX: Don't render hand yet! Wait for animation.
                            
                            if (enemyDeck) {
                                animateCardsFromEnemyDeck(enemyBonusCard, enemyDeck, () => {
                                    // Update UI ONLY after animation lands
                                    updateEnemyDeckCounter();
                                    renderEnemyHand(); // Logic updates
                                    renderOpponentHand(); // Visual updates (card backs)
                                    console.log('Bot bonus card animation finished.');
                                });
                            } else {
                                // Fallback if no deck element found
                                updateEnemyDeckCounter();
                                renderEnemyHand();
                                renderOpponentHand();
                            }
                        }
                    }
                } else {
                    // –ù–∏—á—å—è –≤ —Ä–∞—É–Ω–¥–µ - –¥–∞–µ–º –ø–æ –æ—á–∫—É –æ–±–æ–∏–º (–ø—Ä–∞–≤–∏–ª–æ –ì–≤–∏–Ω—Ç–∞)
                    playerMatchWins++;
                    enemyMatchWins++;
                    roundWinner = 'draw';
                    showGameNotification("–ù–∏—á—å—è –≤ —Ä–∞—É–Ω–¥–µ!", 'warning');
                }

                updateMatchScore();

                // --- PHASE 2: CLEANUP (Nested Timeout) ---
                // Wait another 2.5s AFTER the notification to clear the board
                setTimeout(async () => {
                    // 1. –ñ–¥–µ–º –ø–æ–ª–Ω–æ–≥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –æ—á–∏—Å—Ç–∫–∏!
                    await clearFieldToGraveyard();
                    
                    // 2. –°–±—Ä–æ—Å —Ñ–ª–∞–≥–æ–≤
                    playerPassed = false;
                    enemyPassed = false;
                    enemyCoachActive = false;
                    enemyCoachBonusScore = 0;
                    
                    // REMOVED: Don't remove .used class from coaches - it should persist across rounds
                    // The coach data (isUsed) controls whether it's active, not the visual class
                    
                    // Reset UI states
                    updatePassButtonState();
                    isPlayerTurn = true;
                    
                    // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ü–∞ –º–∞—Ç—á–∞ –∏–ª–∏ —Å—Ç–∞—Ä—Ç —Å–ª–µ–¥—É—é—â–µ–≥–æ
                    const isMatchOver = (playerMatchWins >= 2 || enemyMatchWins >= 2 || currentRound >= 3);

                    if (isMatchOver) {
                        setTimeout(() => {
                            checkMatchResultFinal();
                        }, 1000);
                    } else {
                        currentRound++;
                        showGameNotification(`–†–∞—É–Ω–¥ ${currentRound - 1} –∑–∞–≤–µ—Ä—à–µ–Ω! –ù–∞—á–∏–Ω–∞–µ–º —Ä–∞—É–Ω–¥ ${currentRound}...`, 'info');
                        
                        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–ª–µ–¥—É—é—â–∏–π —Ä–∞—É–Ω–¥ –ë–ï–ó –ª–∏—à–Ω–∏—Ö —Ç–∞–π–º–µ—Ä–æ–≤, —Ç–∞–∫ –∫–∞–∫ –º—ã —É–∂–µ –ø–æ–¥–æ–∂–¥–∞–ª–∏ –æ—á–∏—Å—Ç–∫—É
                        prepareNextRound();
                    }
                }, 2500);

            }, 1000); // <--- End of Suspense Delay
        }

        function checkMatchResultFinal() {
            cleanUpVisualArtifacts(); // <--- ADD THIS
            
            let title = '';
            let titleClass = '';
            
            // –õ–æ–≥–∏–∫–∞ –ø–æ–±–µ–¥—ã –≤ –º–∞—Ç—á–µ
            if (playerMatchWins > enemyMatchWins) {
                title = '–ü–û–ë–ï–î–ê –í –ú–ê–¢–ß–ï!';
                titleClass = 'victory';
            } else if (enemyMatchWins > playerMatchWins) {
                title = '–ü–û–†–ê–ñ–ï–ù–ò–ï...';
                titleClass = 'defeat';
            } else {
                title = '–ù–ò–ß–¨–Ø';
                titleClass = 'draw';
            }
            
            resultTitle.textContent = title;
            resultTitle.className = 'game-result-title ' + titleClass;
            resultScore.textContent = `–ò—Ç–æ–≥–æ–≤—ã–π —Å—á–µ—Ç: ${playerMatchWins}:${enemyMatchWins}`;
            
            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ
            gameOverlay.classList.add('show');
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ª–æ—Ç–∞ —Ç–∞–∫—Ç–∏–∫–∏ –ø–æ rowId
        function getTacticsSlot(rowId) {
            switch(rowId) {
                case 'attack':
                    return attackTacticsSlot;
                case 'midfield':
                    return midfieldTacticsSlot;
                case 'defense':
                    return defenseTacticsSlot;
                default:
                    return null;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —à–ø–∏–æ–Ω–∞ –Ω–∞ –ø–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —à–ø–∏–æ–Ω–∞ –Ω–∞ –ø–æ–ª–µ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
        function placeSpyCard(cardElement, cardData, rowId) {
            try {
                // 1. Determine Target Row
                let targetRowId = rowId;
                if (!targetRowId || targetRowId === 'any') {
                    targetRowId = cardData.position === 'any' ? 'attack' : cardData.position;
                }
                
                const enemyTargetRow = getEnemyTargetRow(targetRowId);
                if (!enemyTargetRow) {
                    isPlayerTurn = true;
                    return;
                }
                
                // 2. Prepare Flying Spy Animation (Hand -> Enemy Field)
                const imageSrc = (cardData.miniImg && cardData.miniImg.trim() !== "") ? cardData.miniImg : cardData.img;
                const startPos = getElementPosition(cardElement);
                const targetRect = enemyTargetRow.getBoundingClientRect();
                
                // Field Card Size Calculation
                let fieldCardWidth = window.innerWidth <= 480 ? 40 : 45;
                if (window.innerWidth <= 360) fieldCardWidth = 35;
                let fieldCardHeight = fieldCardWidth * 1.4;
                
                // Calculate Center of Target Row
                const targetCenterY = targetRect.top + targetRect.height / 2;
                let targetCenterX = targetRect.left + targetRect.width / 2;
                const existingCount = enemyTargetRow.querySelectorAll('.card-on-field').length;
                if ((existingCount + 1) % 2 === 0) {
                    targetCenterX += (existingCount * fieldCardWidth) / 2;
                }

                // Create Flying Spy Element
                const flyingCard = document.createElement('div');
                flyingCard.className = 'card-flying';
                Object.assign(flyingCard.style, {
                    width: `${startPos.width}px`,
                    height: `${startPos.height}px`,
                    left: `${startPos.x - startPos.width / 2}px`,
                    top: `${startPos.y - startPos.height / 2}px`,
                    borderRadius: '8px',
                    overflow: 'hidden',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.5)',
                    zIndex: '10000'
                });
                
                const flyingImg = document.createElement('img');
                flyingImg.src = imageSrc;
                flyingImg.style.width = '100%'; flyingImg.style.height = '100%'; flyingImg.style.objectFit = 'cover';
                flyingCard.appendChild(flyingImg);
                document.body.appendChild(flyingCard);
                
                // Hide Original immediately
                cardElement.style.opacity = '0';
                
                // Execute Flight
                setTimeout(() => {
                    flyingCard.style.left = `${targetCenterX - fieldCardWidth / 2}px`;
                    flyingCard.style.top = `${targetCenterY - fieldCardHeight / 2}px`;
                    flyingCard.style.width = `${fieldCardWidth}px`;
                    flyingCard.style.height = `${fieldCardHeight}px`;
                }, 10);
                
                // 3. LANDING & EFFECT
                setTimeout(() => {
                    // Lock game flow
                    isSpyDrawing = true; 
                    
                    // A. Remove Spy from Player Hand (Data & DOM)
                    const spyIndex = myCards.findIndex(card => card.id === cardData.id);
                    if (spyIndex !== -1) myCards.splice(spyIndex, 1);
                    cardElement.remove();
                    updateHandLayout();
                    flyingCard.remove(); // Remove ghost

                    // B. Add to Enemy Field (Data & DOM)
                    enemyCardsOnField.push({ cardData, rowId: targetRowId });
                    
                    const fieldCard = document.createElement('div');
                    fieldCard.className = 'card-on-field';
                    if (cardData.isHero || cardData.cardtype === 'hero') fieldCard.classList.add('hero');
                    
                    const fieldImg = document.createElement('img');
                    fieldImg.src = imageSrc;
                    fieldCard.appendChild(fieldImg);
                    
                    fieldCard.setAttribute('data-card-id', cardData.id);
                    fieldCard.setAttribute('data-full-img', cardData.img);
                    
                    // Add Interaction Handlers
                    fieldCard.addEventListener('dragstart', e => e.preventDefault());
                    fieldImg.addEventListener('dragstart', e => e.preventDefault());
                    addInspectionEvents(fieldCard, cardData.img);
                    attachDummyClickListener(fieldCard, cardData); // Allow Dummy to pick it up later!
                    addFieldPowerBadge(fieldCard, cardData);
                    
                    insertCardSmartly(enemyTargetRow, fieldCard);
                    updateRowLayout(enemyTargetRow);
                    
                    // C. Update Scores (Spy gives points to enemy)
                    updateEnemyScore();
                    
                    // --- 4. DRAW ANIMATION SEQUENCE ---
                    showGameNotification("–®–ø–∏–æ–Ω! –î–æ–±–æ—Ä 2 –∫–∞—Ä—Ç...", "success");

                    // Small delay before cards fly (pacing)
                    setTimeout(() => {
                        const newCards = drawCardsFromPlayerDeck(2);
                        
                        if (newCards.length > 0) {
                            // Add to data
                            myCards.push(...newCards);
                            
                            // 1. Render Hand FIRST (so we have target elements)
                            renderPlayerHand();
                            
                            // 2. Animate Flight from Deck to Hand
                            if (playerDeck) {
                                animateCardsFromDeck(newCards, playerDeck, () => {
                                    // Animation Done
                                    updatePlayerDeckCounter();
                                    isSpyDrawing = false;
                                    
                                    // Resume Flow
                                    finishSpyTurn();
                                });
                            } else {
                                // Fallback (No Deck Element)
                                updatePlayerDeckCounter();
                                isSpyDrawing = false;
                                finishSpyTurn();
                            }
                        } else {
                            showGameNotification("–ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞!", "warning");
                            isSpyDrawing = false;
                            finishSpyTurn();
                        }
                    }, 600); // 600ms pause after spy lands

                }, 650); // Flight time of spy

            } catch (error) {
                console.error('Spy Error:', error);
                isPlayerTurn = true;
                isSpyDrawing = false;
            }
        }

        // Helper to finalize turn after Spy Draw
        function finishSpyTurn() {
            updatePassButtonState();
            checkRoundEndCondition();
            
            // Spy turn doesn't pass turn to enemy immediately, 
            // BUT we need to check if bot passed or game ended.
            if (!((playerPassed || myCards.length === 0) && (enemyPassed || enemyCards.length === 0))) {
                if (!checkAutoPass()) {
                    if (enemyPassed) {
                        isPlayerTurn = true;
                        updatePassButtonState();
                    } else {
                        // Standard Spy rule: You draw 2 cards and it's STILL YOUR TURN? 
                        // In Gwent, Spy gives card advantage but *usually* passes turn?
                        // Wait, standard Gwent Spy: Place on enemy field (points for them), draw 2 cards. TURN PASSES?
                        // Actually, most versions: Spy is played -> Turn passes to opponent.
                        // UNLESS your version keeps turn?
                        // Based on previous code: `setTimeout(() => enemyTurn(), 1500)` was used.
                        // I will restore turn passing to enemy.
                        
                        setTimeout(() => {
                            isPlayerTurn = false;
                            enemyTurn();
                        }, 1000);
                    }
                }
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —à–ø–∏–æ–Ω–∞ –±–æ—Ç–∞ –Ω–∞ –ø–æ–ª–µ –∏–≥—Ä–æ–∫–∞
        async function placeEnemySpyCard(cardBackElement, cardData) {
            try {
                // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ü–µ–ª–µ–≤–æ–π —Ä—è–¥ –∏–≥—Ä–æ–∫–∞
                let targetRowId = cardData.position === 'any' ? 'attack' : cardData.position;
                const playerTargetRow = getTargetRow(targetRowId);
                
                if (!playerTargetRow) {
                    isPlayerTurn = true;
                    return;
                }
                
                // –°–æ–∑–¥–∞–µ–º –∫–∞—Ä—Ç—É –¥–ª—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è –∏–≥—Ä–æ–∫–∞ (—Å–Ω–∞—á–∞–ª–∞ —Å–∫—Ä—ã—Ç—É—é)
                const fieldCard = document.createElement('div');
                fieldCard.className = 'card-on-field';
                fieldCard.style.opacity = '0'; // –°–∫—Ä—ã–≤–∞–µ–º –¥–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏
                
                if (cardData.isHero || cardData.cardtype === 'hero') {
                    fieldCard.classList.add('hero');
                }
                
                const fieldCardImage = document.createElement('img');
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º miniImg –¥–ª—è –∫–∞—Ä—Ç –Ω–∞ –ø–æ–ª–µ, –µ—Å–ª–∏ –æ–Ω –µ—Å—Ç—å –∏ –Ω–µ –ø—É—Å—Ç–æ–π, –∏–Ω–∞—á–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π img
                const imageSrc = (cardData.miniImg && cardData.miniImg !== "") ? cardData.miniImg : cardData.img;
                fieldCardImage.src = imageSrc;
                fieldCardImage.alt = `–ö–∞—Ä—Ç–∞ –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ ${cardData.id}`;
                
                fieldCard.appendChild(fieldCardImage);
                
                // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
                fieldCard.addEventListener('dragstart', (e) => e.preventDefault());
                fieldCardImage.addEventListener('dragstart', (e) => e.preventDefault());
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –¥–ª—è –∏–Ω—Å–ø–µ–∫—Ü–∏–∏
                fieldCard.setAttribute('data-full-img', cardData.img);
                
                playerCardsOnField.push({ cardData, rowId: targetRowId });
                fieldCard.setAttribute('data-card-id', cardData.id);
                
                // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏–Ω—Å–ø–µ–∫—Ü–∏—é –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
                addInspectionEvents(fieldCard, cardData.img);
                addFieldPowerBadge(fieldCard, cardData);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –¥–ª—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ Dummy (—à–ø–∏–æ–Ω—ã —Ç–æ–∂–µ –º–æ–∂–Ω–æ –∑–∞–±—Ä–∞—Ç—å –º–∞–Ω–µ–∫–µ–Ω–æ–º)
                attachDummyClickListener(fieldCard, cardData);
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–∞—Ä—Ç—É –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —ç–ª–µ–º–µ–Ω—Ç (—Å–∫—Ä—ã—Ç—É—é)
                insertCardSmartly(playerTargetRow, fieldCard);
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–∂–∏–º –Ω–∞–ª–æ–∂–µ–Ω–∏—è –∫–∞—Ä—Ç –≤ —Ä—è–¥—É
                updateRowLayout(playerTargetRow);
                
                // –ó–∞–ø—É—Å–∫–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –∏–∑ —Ä—É–∫–∏ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞ –Ω–∞ –ø–æ–ª–µ –∏–≥—Ä–æ–∫–∞
                await animateCardTransition(cardData, fieldCard);
                
                // –ü–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ
                fieldCard.style.opacity = '1';
                
                // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç—É –æ–±—Ä–∞—Ç–Ω–æ–π —Å—Ç–æ—Ä–æ–Ω–æ–π –∏–∑ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
                cardBackElement.remove();
                cardData.used = true;
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥, —á—Ç–æ–±—ã –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—Ç–∏—Ç—å –∞–≤—Ç–æ-–¥–æ–±–æ—Ä –≤–æ –≤—Ä–µ–º—è –¥–µ–π—Å—Ç–≤–∏—è —à–ø–∏–æ–Ω–∞
                isSpyDrawing = true;
                
                // DEBUG: –õ–æ–≥–∏—Ä—É–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–µ—Ä–µ–¥ –¥–µ–π—Å—Ç–≤–∏—è–º–∏ —Å–æ —à–ø–∏–æ–Ω–æ–º
                console.log('DEBUG: –†—É–∫–∞ –±–æ—Ç–∞, —à–ø–∏–æ–Ω —Ä–∞–∑—ã–≥—Ä–∞–Ω. –¢–µ–∫—É—â–∞—è –∫–æ–ª–æ–¥–∞:', enemyDeck ? enemyDeck.length : 0);
                console.log('DEBUG: –ö–∞—Ä—Ç –≤ —Ä—É–∫–µ –±–æ—Ç–∞ –¥–æ —É–¥–∞–ª–µ–Ω–∏—è —à–ø–∏–æ–Ω–∞:', enemyCards.length);
                
                // 1. –£–î–ê–õ–ï–ù–ò–ï –ò–ó –†–£–ö–ò: –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç—É —à–ø–∏–æ–Ω–∞ –∏–∑ –º–∞—Å—Å–∏–≤–∞ enemyCards
                // –í–ê–ñ–ù–û: –ò—Å–ø–æ–ª—å–∑—É–µ–º splice –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è, —á—Ç–æ–±—ã –Ω–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—ã–π –º–∞—Å—Å–∏–≤
                const spyIndex = enemyCards.findIndex(card => card.id === cardData.id);
                if (spyIndex !== -1) {
                    enemyCards.splice(spyIndex, 1);
                }
                console.log('1. –®–ø–∏–æ–Ω –ø–æ–∫–∏–Ω—É–ª —Ä—É–∫—É –±–æ—Ç–∞. –ö–∞—Ä—Ç –æ—Å—Ç–∞–ª–æ—Å—å:', enemyCards.length);
                
                // 2. –î–û–ë–û–†: –°—Ä–∞–∑—É –ø–æ—Å–ª–µ —É–¥–∞–ª–µ–Ω–∏—è –∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –≤—ã–∑—ã–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–æ–±–æ—Ä–∞
                // –í–ê–ñ–ù–û: –ù–ï –≤—ã–∑—ã–≤–∞–µ–º renderEnemyHand() –∏–ª–∏ updateEnemyDeckCounter() –º–µ–∂–¥—É —É–¥–∞–ª–µ–Ω–∏–µ–º –∏ –¥–æ–±–æ—Ä–æ–º!
                // –í–ê–ñ–ù–û: –î–æ–±–æ—Ä —Å—Ç—Ä–æ–≥–æ +2 –∫–∞—Ä—Ç—ã –∫ —Ç–µ–∫—É—â–µ–º—É –∫–æ–ª–∏—á–µ—Å—Ç–≤—É, –¥–∞–∂–µ –µ—Å–ª–∏ –≤ —Ä—É–∫–µ –±—ã–ª–æ 0
                console.log('2. –ù–∞—á–∏–Ω–∞—é –¥–æ–±–æ—Ä 2-—Ö –∫–∞—Ä—Ç –∏–∑ –∫–æ–ª–æ–¥—ã enemyDeck...');
                console.log('DEBUG: –ö–∞—Ä—Ç –≤ –∫–æ–ª–æ–¥–µ –ø–µ—Ä–µ–¥ –¥–æ–±–æ—Ä–æ–º:', enemyDeck ? enemyDeck.length : 0);
                console.log('DEBUG: –ö–∞—Ä—Ç –≤ —Ä—É–∫–µ –ø–µ—Ä–µ–¥ –¥–æ–±–æ—Ä–æ–º:', enemyCards.length);
                const newCards = drawCardsFromEnemyDeck(2);
                if (newCards.length > 0) {
                    enemyCards.push(...newCards);
                    console.log('3. –î–æ–±–æ—Ä –∑–∞–≤–µ—Ä—à–µ–Ω. –ö–∞—Ä—Ç –≤ —Ä—É–∫–µ –±–æ—Ç–∞ —Å—Ç–∞–ª–∞:', enemyCards.length);
                    console.log('DEBUG: –ü–æ—Å–ª–µ –¥–æ–±–æ—Ä–∞ - –∫–∞—Ä—Ç –≤ —Ä—É–∫–µ:', enemyCards.length);
                } else {
                    console.log('3. –î–æ–±–æ—Ä –∑–∞–≤–µ—Ä—à–µ–Ω. –ö–∞—Ä—Ç –≤ —Ä—É–∫–µ –±–æ—Ç–∞ —Å—Ç–∞–ª–∞:', enemyCards.length, '(–∫–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞)');
                    console.log('DEBUG: –ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞, –¥–æ–±–æ—Ä –Ω–µ –ø—Ä–æ–∏–∑–æ—à–µ–ª');
                }
                
                // 3. –°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –¢–æ–ª—å–∫–æ –ü–û–°–õ–ï –¥–æ–±–æ—Ä–∞ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
                updateEnemyDeckCounter();
                renderEnemyHand();
                renderOpponentHand();
                
                // –ê–Ω–∏–º–∏—Ä—É–µ–º –∫–∞—Ä—Ç—ã –∏–∑ –∫–æ–ª–æ–¥—ã –±–æ—Ç–∞ (–µ—Å–ª–∏ –æ–Ω–∏ –µ—Å—Ç—å)
                if (newCards.length > 0) {
                    animateCardsFromEnemyDeck(newCards, enemyDeck, () => {
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç—á–∏–∫ –∫–æ–ª–æ–¥—ã –µ—â–µ —Ä–∞–∑ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                        updateEnemyDeckCounter();
                        console.log('–ê–Ω–∏–º–∞—Ü–∏—è –¥–æ–±–æ—Ä–∞ –∫–∞—Ä—Ç –±–æ—Ç–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');
                    });
                }
                
                // –°–Ω–∏–º–∞–µ–º —Ñ–ª–∞–≥ –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –¥–æ–±–æ—Ä–∞
                isSpyDrawing = false;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º —Å—á–µ—Ç –∏–≥—Ä–æ–∫–∞ (—à–ø–∏–æ–Ω –¥–∞–µ—Ç –æ—á–∫–∏ –∏–≥—Ä–æ–∫—É)
                try {
                    updatePlayerScore();
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—á–µ—Ç–∞ –∏–≥—Ä–æ–∫–∞:', error);
                }
                
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Ä–∞—É–Ω–¥–∞ –ø–æ—Å–ª–µ —Ö–æ–¥–∞ —à–ø–∏–æ–Ω–∞ –±–æ—Ç–∞
                checkRoundEndCondition();
                
                // Check round end again strictly before proceeding
                const roundEnded = (myCards.length === 0 && enemyCards.filter(c => !c.used).length === 0) || 
                                   (playerPassed && enemyPassed);

                if (roundEnded) {
                    setTimeout(() => endRound(), 500);
                    return;
                }

                // TURN SWITCHING LOGIC
                handleTurnSwitch();
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ —à–ø–∏–æ–Ω–∞ –±–æ—Ç–∞:', error);
                isPlayerTurn = true;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø–æ–ª—è –∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç –≤ –æ—Ç–±–æ–π
        function clearFieldToGraveyard() {
            return new Promise((resolve) => {
                try {
                    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–∞—Ä—Ç—ã —Å –ø–æ–ª—è –∏–≥—Ä–æ–∫–∞
                    const allPlayerFieldCards = [...playerCardsOnField, ...playerTacticsCards.map(tc => ({ cardData: tc.cardData, rowId: tc.rowId }))];
                    
                    // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–∞—Ä—Ç—ã —Å –ø–æ–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞
                    const allEnemyFieldCards = [...enemyCardsOnField, ...enemyTacticsCards.map(tc => ({ cardData: tc.cardData, rowId: tc.rowId }))];
                    
                    // –ê–Ω–∏–º–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∫–∞—Ä—Ç –∏–≥—Ä–æ–∫–∞ –≤ –æ—Ç–±–æ–π
                    allPlayerFieldCards.forEach((cardEntry, index) => {
                        const row = getTargetRow(cardEntry.rowId);
                        if (!row) return;
                        
                        const fieldCardElement = row.querySelector(`[data-card-id="${cardEntry.cardData.id}"]`);
                        if (!fieldCardElement) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏
                            const tacticsSlot = getTacticsSlot(cardEntry.rowId);
                            if (tacticsSlot) {
                                const tacticsCard = tacticsSlot.querySelector(`[data-card-id="${cardEntry.cardData.id}"]`);
                                if (tacticsCard) {
                                    animateCardToGraveyard(tacticsCard, playerGraveyard, () => {
                                        playerGraveyardCards.push(cardEntry.cardData);
                                    });
                                }
                            }
                            return;
                        }
                        
                        setTimeout(() => {
                            animateCardToGraveyard(fieldCardElement, playerGraveyard, () => {
                                playerGraveyardCards.push(cardEntry.cardData);
                            });
                        }, index * 50);
                    });
                    
                    // –ê–Ω–∏–º–∏—Ä—É–µ–º –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏–µ –∫–∞—Ä—Ç –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞ –≤ –æ—Ç–±–æ–π
                    allEnemyFieldCards.forEach((cardEntry, index) => {
                        const row = getEnemyTargetRow(cardEntry.rowId);
                        if (!row) return;
                        
                        const fieldCardElement = row.querySelector(`[data-card-id="${cardEntry.cardData.id}"]`);
                        if (!fieldCardElement) {
                            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏
                            const tacticsSlot = getEnemyTacticsSlot(cardEntry.rowId);
                            if (tacticsSlot) {
                                const tacticsCard = tacticsSlot.querySelector(`[data-card-id="${cardEntry.cardData.id}"]`);
                                if (tacticsCard) {
                                    animateCardToGraveyard(tacticsCard, enemyGraveyard, () => {
                                        enemyGraveyardCards.push(cardEntry.cardData);
                                    });
                                }
                            }
                            return;
                        }
                        
                        setTimeout(() => {
                            animateCardToGraveyard(fieldCardElement, enemyGraveyard, () => {
                                enemyGraveyardCards.push(cardEntry.cardData);
                            });
                        }, (allPlayerFieldCards.length + index) * 50);
                    });
                    
                    // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤—ã –∏ –ø–æ–ª–µ –ø–æ—Å–ª–µ –∞–Ω–∏–º–∞—Ü–∏–∏
                    setTimeout(() => {
                        // –û—á–∏—â–∞–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø–æ–ª–µ (SAFE METHOD)
                        const allRows = [attackRow, midfieldRow, defenseRow, enemyAttackRow, enemyMidfieldRow, enemyDefenseRow];
                        const allTacticsSlots = [attackTacticsSlot, midfieldTacticsSlot, defenseTacticsSlot, enemyAttackTacticsSlot, enemyMidfieldTacticsSlot, enemyDefenseTacticsSlot];
                        
                        // Remove only cards from rows, keep icons
                        allRows.forEach(row => {
                            if (row) {
                                const cards = row.querySelectorAll('.card-on-field');
                                cards.forEach(c => c.remove());
                                row.classList.remove('overlap-mode'); // Reset overlap mode
                            }
                        });

                        // Remove cards from tactics, restore labels
                        allTacticsSlots.forEach(slot => {
                            if (slot) {
                                const cards = slot.querySelectorAll('.card-on-field');
                                cards.forEach(c => c.remove());
                                
                                // Restore/Show the label text if it exists
                                const label = slot.querySelector('.tactics-slot-label');
                                if (label) {
                                    label.style.display = 'block'; // Or whatever default style was
                                }
                                slot.classList.remove('has-coach'); // Reset coach class just in case
                                slot.classList.remove('highlight-tactic');
                            }
                        });
                        
                        // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤—ã
                        playerCardsOnField = [];
                        enemyCardsOnField = [];
                        playerTacticsCards = [];
                        enemyTacticsCards = [];
                        
                        // Update visuals immediately
                        updateGraveyardVisuals();
                        
                        // –û–±–Ω—É–ª—è–µ–º —Å—á–µ—Ç
                        totalScore = 0;
                        enemyScore = 0;
                        updatePlayerScore();
                        updateEnemyScore();
                        
                        // –í –°–ê–ú–û–ú –ö–û–ù–¶–ï –¢–ê–ô–ú–ï–†–ê: —Å–∏–≥–Ω–∞–ª, —á—Ç–æ –æ—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞
                        resolve();
                    }, (allPlayerFieldCards.length + allEnemyFieldCards.length) * 50 + 1000);
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –ø–æ–ª—è:', error);
                    resolve(); // –†–µ–∑–æ–ª–≤–∏–º –¥–∞–∂–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ, —á—Ç–æ–±—ã –Ω–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å –∏–≥—Ä—É
                }
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –≤ –æ—Ç–±–æ–π
        function animateCardToGraveyard(cardElement, graveyardElement, callback) {
            if (!cardElement || !graveyardElement) {
                if (callback) callback();
                return;
            }
            
            const cardRect = cardElement.getBoundingClientRect();
            const graveyardRect = graveyardElement.getBoundingClientRect();
            
            const flyingCard = cardElement.cloneNode(true);
            flyingCard.style.position = 'fixed';
            flyingCard.style.left = cardRect.left + 'px';
            flyingCard.style.top = cardRect.top + 'px';
            flyingCard.style.width = cardRect.width + 'px';
            flyingCard.style.height = cardRect.height + 'px';
            flyingCard.style.zIndex = '10000';
            flyingCard.style.transition = 'all 0.5s ease-in-out';
            flyingCard.style.opacity = '1';
            
            document.body.appendChild(flyingCard);
            cardElement.style.opacity = '0';
            
            setTimeout(() => {
                flyingCard.style.left = (graveyardRect.left + graveyardRect.width / 2 - cardRect.width / 2) + 'px';
                flyingCard.style.top = (graveyardRect.top + graveyardRect.height / 2 - cardRect.height / 2) + 'px';
                flyingCard.style.width = '30px';
                flyingCard.style.height = '42px';
                flyingCard.style.opacity = '0';
                
                setTimeout(() => {
                    flyingCard.remove();
                    if (callback) callback();
                }, 500);
            }, 10);
        }
        
        // Helper: Animates a card flying to graveyard with Safety Timeout
        function flyCardToGraveyard(cardElement, graveyardElement, onComplete) {
            if (!cardElement || !graveyardElement) {
                if (onComplete) onComplete();
                return;
            }

            const rect = cardElement.getBoundingClientRect();
            
            // Placeholder to prevent layout jump
            const placeholder = document.createElement('div');
            placeholder.style.width = `${rect.width}px`;
            placeholder.style.height = `${rect.height}px`;
            placeholder.style.margin = getComputedStyle(cardElement).margin;
            if (cardElement.parentNode) cardElement.parentNode.insertBefore(placeholder, cardElement);

            // Fixed positioning for flight
            cardElement.style.position = 'fixed';
            cardElement.style.top = `${rect.top}px`;
            cardElement.style.left = `${rect.left}px`;
            cardElement.style.width = `${rect.width}px`;
            cardElement.style.height = `${rect.height}px`;
            cardElement.style.zIndex = '9999';
            cardElement.style.pointerEvents = 'none';
            cardElement.style.transition = 'all 0.6s ease-in-out';

            // Destination
            const graveRect = graveyardElement.getBoundingClientRect();
            const destTop = graveRect.top + (graveRect.height / 2) - (rect.height / 2);
            const destLeft = graveRect.left + (graveRect.width / 2) - (rect.width / 2);

            // Trigger Animation
            void cardElement.offsetWidth; // Force reflow
            setTimeout(() => {
                cardElement.style.top = `${destTop}px`;
                cardElement.style.left = `${destLeft}px`;
                cardElement.style.transform = 'scale(0.2) rotate(360deg)';
                cardElement.style.opacity = '0';
            }, 10);

            // Cleanup
            let finished = false;
            const finishAnimation = () => {
                if (finished) return;
                finished = true;
                if (cardElement && cardElement.parentNode) cardElement.remove();
                if (placeholder && placeholder.parentNode) placeholder.remove();
                if (onComplete) onComplete();
            };

            cardElement.addEventListener('transitionend', finishAnimation);
            setTimeout(finishAnimation, 700); // Safety fallback
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –±–µ–π–¥–∂–∞ —Å–∏–ª—ã –Ω–∞ –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ
        function addFieldPowerBadge(fieldCard, cardData) {
            // 1. –ò—Å–∫–ª—é—á–µ–Ω–∏—è: Dummy –∏ Support –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø–æ–ª—É—á–∞—é—Ç –±–µ–π–¥–∂ —Å–∏–ª—ã
            if (cardData.ability === 'dummy' || cardData.ability === 'support') {
                return;
            }

            // 2. –†–∞–∑—Ä–µ—à–∞–µ–º –±–µ–π–¥–∂, –µ—Å–ª–∏ —ç—Ç–æ –ë–∞–∑–æ–≤–∞—è –∫–∞—Ä—Ç–∞ –ò–õ–ò –ì–µ—Ä–æ–π
            const isBase = cardData.cardtype === 'base';
            const isHero = cardData.isHero || cardData.cardtype === 'hero';

            if (isBase || isHero) {
                const powerBadge = document.createElement('div');
                powerBadge.className = 'field-power-badge';
                
                // –õ–æ–≥–∏–∫–∞ –∫–ª–∞—Å—Å–æ–≤
                if (isHero) {
                    powerBadge.classList.add('hero-badge');
                }
                
                if (cardData.ability && cardData.ability !== '' && cardData.ability !== 'none') {
                    powerBadge.classList.add('ability-badge');
                }

                const initialPower = cardData.power || 0;
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –∏ –í–ê–ñ–ù–´–ô –∞—Ç—Ä–∏–±—É—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
                powerBadge.textContent = initialPower;
                powerBadge.setAttribute('data-power', initialPower);
                
                // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–π –∫–µ—Ä–Ω–∏–Ω–≥ –¥–ª—è –±–æ–ª—å—à–∏—Ö —á–∏—Å–µ–ª (>= 20)
                if (initialPower >= 20) {
                    powerBadge.classList.add('tight-text');
                }
                
                fieldCard.appendChild(powerBadge);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —É–º–Ω–æ–π –≤—Å—Ç–∞–≤–∫–∏ –∫–∞—Ä—Ç –≤ —Ä—è–¥
        function insertCardSmartly(container, cardElement) {
            // –ï—Å–ª–∏ —ç—Ç–æ —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏, –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º (—Ç–∞–º –æ–±—ã—á–Ω–æ 1 –∫–∞—Ä—Ç–∞)
            if (container.classList.contains('tactics-slot')) {
                container.appendChild(cardElement);
                return;
            }

            const existingCards = container.querySelectorAll('.card-on-field');
            const count = existingCards.length;
            const nextIndex = count + 1; // –ü–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –Ω–æ–≤–æ–π –∫–∞—Ä—Ç—ã (1, 2, 3...)

            // –õ–æ–≥–∏–∫–∞:
            // 1-—è –∫–∞—Ä—Ç–∞ -> –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º
            // –ß–µ—Ç–Ω—ã–µ (2, 4, 6) -> –î–æ–±–∞–≤–ª—è–µ–º –≤ –∫–æ–Ω–µ—Ü (–Ω–∞–ø—Ä–∞–≤–æ)
            // –ù–µ—á–µ—Ç–Ω—ã–µ (3, 5, 7) -> –í—Å—Ç–∞–≤–ª—è–µ–º –≤ —Å–µ—Ä–µ–¥–∏–Ω—É
            
            if (nextIndex === 1 || nextIndex % 2 === 0) {
                container.appendChild(cardElement);
            } else {
                // –í—Å—Ç–∞–≤–ª—è–µ–º –≤ —Å–µ—Ä–µ–¥–∏–Ω—É
                // –î–ª—è 3-–π –∫–∞—Ä—Ç—ã (count=2) -> insertBefore index 1 (–º–µ–∂–¥—É 0 –∏ 1)
                // –î–ª—è 5-–π –∫–∞—Ä—Ç—ã (count=4) -> insertBefore index 2 (–º–µ–∂–¥—É 0,1 –∏ 2,3)
                const middleIndex = Math.ceil(count / 2);
                
                if (existingCards[middleIndex]) {
                    container.insertBefore(cardElement, existingCards[middleIndex]);
                } else {
                    container.appendChild(cardElement);
                }
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–∂–∏–º–∞ –Ω–∞–ª–æ–∂–µ–Ω–∏—è –∫–∞—Ä—Ç –≤ —Ä—è–¥—É
        function updateRowLayout(rowElement) {
            if (!rowElement) return;
            const cards = Array.from(rowElement.querySelectorAll('.card-on-field'));
            const count = cards.length;
            
            if (count === 0) return;

            // 1. –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ Z-Index (–Ω–æ–≤–∞—è –∫–∞—Ä—Ç–∞ –≤—Å–µ–≥–¥–∞ –≤—ã—à–µ –ø—Ä–µ–¥—ã–¥—É—â–µ–π)
            cards.forEach((card, index) => {
                card.style.zIndex = index + 10; // –ë–∞–∑–æ–≤—ã–π —Å–ª–æ–π
                card.style.marginLeft = '0px'; // –°–±—Ä–æ—Å
            });

            // –°–±—Ä–æ—Å —Ä–µ–∂–∏–º–∞
            rowElement.classList.remove('overlap-mode');

            // 2. –õ–æ–≥–∏–∫–∞ –Ω–∞–ª–æ–∂–µ–Ω–∏—è
            if (count > 5) {
                rowElement.classList.add('overlap-mode');
                
                // –ü–æ–ª—É—á–∞–µ–º —Ä–µ–∞–ª—å–Ω—É—é —à–∏—Ä–∏–Ω—É –∫–∞—Ä—Ç—ã
                const cardWidth = cards[0].getBoundingClientRect().width;
                
                // –ï—Å–ª–∏ –∫–∞—Ä—Ç–∞ –µ—â–µ –Ω–µ –æ—Ç—Ä–µ–Ω–¥–µ—Ä–µ–Ω–∞ (—à–∏—Ä–∏–Ω–∞ = 0), –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
                if (cardWidth === 0) {
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–º–µ—Ä–Ω—É—é —à–∏—Ä–∏–Ω—É –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ (45px –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞, 40px –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö)
                    const estimatedWidth = window.innerWidth <= 480 ? 40 : 45;
                    const gap = 4;
                    const targetTotalWidth = (5 * estimatedWidth) + (4 * gap);
                    const margin = ((targetTotalWidth - estimatedWidth) / (count - 1)) - estimatedWidth;
                    
                    cards.forEach((card, index) => {
                        if (index > 0) {
                            card.style.marginLeft = `${margin}px`;
                        }
                    });
                    return;
                }
                
                // –ü–æ–ª—É—á–∞–µ–º gap –∏–∑ —Å—Ç–∏–ª–µ–π (–ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º 4px, –∫–∞–∫ –≤ CSS)
                const gap = 4;
                
                // –¶–ï–õ–ï–í–ê–Ø –®–ò–†–ò–ù–ê: –°–∫–æ–ª—å–∫–æ –º–µ—Å—Ç–∞ –∑–∞–Ω–∏–º–∞—é—Ç 5 –∫–∞—Ä—Ç + 4 –ø—Ä–æ–º–µ–∂—É—Ç–∫–∞?
                // W_target = (5 * W_card) + (4 * gap)
                const targetTotalWidth = (5 * cardWidth) + (4 * gap);
                
                // –¢–ï–ü–ï–†–¨ –°–ß–ò–¢–ê–ï–ú –û–¢–°–¢–£–ü –î–õ–Ø N –ö–ê–†–¢:
                // –ù–∞–º –Ω—É–∂–Ω–æ —É–º–µ—Å—Ç–∏—Ç—å N –∫–∞—Ä—Ç –≤ targetTotalWidth.
                // –§–æ—Ä–º—É–ª–∞: –û–¥–Ω–∞ –ø–æ–ª–Ω–∞—è –∫–∞—Ä—Ç–∞ + (N-1) —á–∞—Å—Ç–∏—á–Ω—ã—Ö –∫–∞—Ä—Ç = Target
                // W_card + (N-1) * (W_card + Margin) = Target
                // (N-1) * (W_card + Margin) = Target - W_card
                // W_card + Margin = (Target - W_card) / (N-1)
                // Margin = ((Target - W_card) / (N-1)) - W_card
                
                const margin = ((targetTotalWidth - cardWidth) / (count - 1)) - cardWidth;
                
                // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ—Ç—Å—Ç—É–ø –∫–æ –≤—Å–µ–º –∫–∞—Ä—Ç–∞–º, –∫—Ä–æ–º–µ –ø–µ—Ä–≤–æ–π
                cards.forEach((card, index) => {
                    if (index > 0) {
                        card.style.marginLeft = `${margin}px`;
                    }
                });
            }
        }
        
        // Helper: Calculate effective power of a single unit on the field
        function calculateUnitPower(cardEntry, isPlayerSide) {
            const card = cardEntry.cardData;
            const rowId = cardEntry.rowId;
            let power = card.power || 0;

            // Heroes allow no buffs
            if (card.isHero || card.cardtype === 'hero') return power;

            // Context
            const fieldArray = isPlayerSide ? playerCardsOnField : enemyCardsOnField;
            const tacticsArray = isPlayerSide ? playerTacticsCards : enemyTacticsCards;
            const cardsInRow = fieldArray.filter(c => c.rowId === rowId);

            // Leader Bonus (+1 to base units except self)
            const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');
            if (hasLeader && card.ability !== 'leader' && card.cardtype === 'base') {
                power += 1;
            }

            // Multipliers
            let multiplier = 1;

            // Bond
            if (card.ability === 'bond') {
                const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                if (bondCount >= 2) multiplier *= 2;
            }

            // Buffs (Captain / Support)
            let buffActive = false;
            const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
            const hasSupport = tacticsArray.some(c => c.rowId === rowId && c.cardData.ability === 'support');

            if ((hasCaptain && card.ability !== 'captain') || hasSupport) buffActive = true;
            if (buffActive) multiplier *= 2;

            return power * multiplier;
        }
        
        // Ability: Provocateur (Destroys strongest unit in the mirror row)
        async function executeProvocateur(attackerCard, rowId, isPlayerAttacker) {
            console.log(`Provocateur triggered by ${isPlayerAttacker ? 'Player' : 'AI'} in row ${rowId}`);

            try {
                // Determine Targets based on who is attacking
                // If Player attacks -> Target Enemy Cards -> Fly to Enemy Graveyard
                // If AI attacks -> Target Player Cards -> Fly to Player Graveyard
                const targetList = isPlayerAttacker ? enemyCardsOnField : playerCardsOnField;
                const graveyardTarget = isPlayerAttacker ? enemyGraveyard : playerGraveyard;
                const graveyardArray = isPlayerAttacker ? enemyGraveyardCards : playerGraveyardCards;
                const isTargetPlayerSide = !isPlayerAttacker; // For calculating power

                // 1. Find Valid Targets in Mirror Row (No Heroes)
                const validTargets = targetList.filter(entry => {
                    const c = entry.cardData;
                    return entry.rowId === rowId && !(c.isHero || c.cardtype === 'hero');
                });

                if (validTargets.length === 0) {
                    showGameNotification("–ü—Ä–æ–≤–æ–∫–∞—Ç–æ—Ä: –ù–µ—Ç —Ü–µ–ª–µ–π –¥–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∏—è", "info");
                    return;
                }

                // 2. Calculate Effective Power & Find Victims
                const targetsWithPower = validTargets.map(t => ({
                    entry: t,
                    effectivePower: calculateUnitPower(t, isTargetPlayerSide)
                }));

                const maxPower = Math.max(...targetsWithPower.map(t => t.effectivePower));
                const victims = targetsWithPower
                    .filter(t => t.effectivePower === maxPower)
                    .map(t => t.entry);

                if (victims.length === 0) return;

                showGameNotification("–ü—Ä–æ–≤–æ–∫–∞—Ç–æ—Ä —É–Ω–∏—á—Ç–æ–∂–∞–µ—Ç —Å–∏–ª—å–Ω–µ–π—à–∏–µ –æ—Ç—Ä—è–¥—ã!", "error");

                // 3. Process Victims (Remove & Animate)
                const animationPromises = [];

                for (const victim of victims) {
                    const victimId = victim.cardData.id;

                    // Remove from Logic Arrays
                    if (isPlayerAttacker) {
                        const idx = enemyCardsOnField.findIndex(c => c.cardData.id === victimId);
                        if (idx !== -1) enemyCardsOnField.splice(idx, 1);
                    } else {
                        const idx = playerCardsOnField.findIndex(c => c.cardData.id === victimId);
                        if (idx !== -1) playerCardsOnField.splice(idx, 1);
                    }
                    graveyardArray.push(victim.cardData);

                    // Find DOM Element
                    let cardElement;
                    if (isPlayerAttacker) {
                        const rowEl = getEnemyTargetRow(rowId);
                        if (rowEl) cardElement = rowEl.querySelector(`[data-card-id="${victimId}"]`);
                    } else {
                        const rowEl = getTargetRow(rowId);
                        if (rowEl) cardElement = rowEl.querySelector(`[data-card-id="${victimId}"]`);
                    }

                    // Start Animation
                    if (cardElement && graveyardTarget) {
                        animationPromises.push(new Promise(resolve => {
                            flyCardToGraveyard(cardElement, graveyardTarget, resolve);
                        }));
                    }
                }

                // 4. Wait for animations
                if (animationPromises.length > 0) {
                    await Promise.race([
                        Promise.all(animationPromises),
                        new Promise(r => setTimeout(r, 1000))
                    ]);
                }

                // 5. Update Layouts
                if (isPlayerAttacker) {
                    const r = getEnemyTargetRow(rowId);
                    if (r) updateRowLayout(r);
                } else {
                    const r = getTargetRow(rowId);
                    if (r) updateRowLayout(r);
                }

            } catch (error) {
                console.error("Provocateur Error:", error);
            } finally {
                // 6. Always update scores
                updateGraveyardVisuals();
                updatePlayerScore();
                updateEnemyScore();
            }
        }
        
        // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∏–∫–∞ –ú–∞–Ω–µ–∫–µ–Ω–∞
        // –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∫–ª–∏–∫–∞ –ú–∞–Ω–µ–∫–µ–Ω–∞
        function attachDummyClickListener(cardElement, cardData) {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏, —á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å
            const newElement = cardElement.cloneNode(true);
            if (cardElement.parentNode) {
                cardElement.parentNode.replaceChild(newElement, cardElement);
            }
            cardElement = newElement;

            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ dragstart (–æ–Ω–∏ —Å–ª–µ—Ç–∞—é—Ç –ø—Ä–∏ –∫–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–∏)
            cardElement.addEventListener('dragstart', (e) => e.preventDefault());
            const img = cardElement.querySelector('img');
            if (img) img.addEventListener('dragstart', (e) => e.preventDefault());
            
            // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏–Ω—Å–ø–µ–∫—Ü–∏—é
            if (cardData.img) {
                addInspectionEvents(cardElement, cardData.img);
            }

            cardElement.addEventListener('click', function(e) {
                // CRITICAL: Stop event from bubbling to the Row
                if (isDummyTargeting && selectedDummyCard) {
                    e.preventDefault();
                    e.stopPropagation();
                    e.stopImmediatePropagation();
                    
                    console.log("Dummy Target Clicked:", cardData.name);

                    // –ù–∞—Ö–æ–¥–∏–º –∞–∫—Ç—É–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –∫–∞—Ä—Ç—ã –≤ –º–∞—Å—Å–∏–≤–µ (—Ç–∞–∫ –∫–∞–∫ cardData –º–æ–∂–µ—Ç —É—Å—Ç–∞—Ä–µ—Ç—å)
                    const targetCardId = parseInt(cardElement.getAttribute('data-card-id'));
                    const targetEntry = playerCardsOnField.find(entry => entry.cardData.id === targetCardId);
                    
                    if (targetEntry) {
                        if (targetEntry.cardData.isHero || targetEntry.cardData.cardtype === 'hero') {
                            showGameNotification('–ì–µ—Ä–æ—è –Ω–µ–ª—å–∑—è –∑–∞–±—Ä–∞—Ç—å!', 'error');
                        } else {
                            // –í—ã–∑—ã–≤–∞–µ–º –æ–±–º–µ–Ω
                            executeDummySwap(cardElement, targetEntry.cardData, targetEntry.rowId);
                        }
                    } else {
                        console.error("Target card data not found in logic array");
                    }
                    return false;
                }
            });
            
            return cardElement; // Return new element reference
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —Ä—è–¥—É
        function placeCardInRow(cardElement, cardData, targetRow, rowId) {
            try {
                // 1. –ñ–ï–°–¢–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê –ü–û–ó–ò–¶–ò–ò
                if (cardData.position !== 'any' && cardData.ability !== 'support' && cardData.ability !== 'spy') {
                    const requiredPos = String(cardData.position).toLowerCase().trim();
                    const currentPos = String(rowId).toLowerCase().trim();
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –≤–∫–ª—é—á–∞—è —Å–∏–Ω–æ–Ω–∏–º—ã
                    const isMatch = currentPos.includes(requiredPos) || requiredPos.includes(currentPos) ||
                                   (requiredPos === 'midfielder' && currentPos === 'midfield') ||
                                   (requiredPos === 'defender' && currentPos === 'defense') ||
                                   (requiredPos === 'forward' && currentPos === 'attack');

                    if (!isMatch) {
                         showGameNotification(`–≠—Ç–∞ –∫–∞—Ä—Ç–∞ –¥–æ–ª–∂–Ω–∞ –∏–≥—Ä–∞—Ç—å –≤ –ø–æ–∑–∏—Ü–∏–∏: ${cardData.position.toUpperCase()}`, 'error');
                         isPlayerTurn = true;
                         return;
                    }
                }

                if (cardData.ability === 'spy') {
                    placeSpyCard(cardElement, cardData, rowId);
                    return;
                }
                
                const isSupportCard = cardData.ability === 'support';
                let actualTargetElement = targetRow;
                let isTacticsPlacement = false;
                
                if (isSupportCard) {
                    const tacticsSlot = getTacticsSlot(rowId);
                    if (!tacticsSlot) {
                        isPlayerTurn = true;
                        return;
                    }
                    if (tacticsSlot.querySelectorAll('.card-on-field').length > 0) {
                        showGameNotification("–°–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏ —É–∂–µ –∑–∞–Ω—è—Ç!", 'error');
                        isPlayerTurn = true;
                        return;
                    }
                    actualTargetElement = tacticsSlot;
                    isTacticsPlacement = true;
                }
                
                // –¢–æ–ª—å–∫–æ –æ–¥–∏–Ω –∫–∞–ø–∏—Ç–∞–Ω –≤ —Ä—è–¥—É
                if (!isSupportCard && cardData.ability === 'captain') {
                    const existingCardsInRow = playerCardsOnField.filter(card => card.rowId === rowId);
                    if (existingCardsInRow.some(card => card.cardData.ability === 'captain')) {
                        showGameNotification("–í —ç—Ç–æ–º —Ä—è–¥—É —É–∂–µ –µ—Å—Ç—å –ö–∞–ø–∏—Ç–∞–Ω!", 'error');
                        isPlayerTurn = true;
                        return;
                    }
                }
                
                // –õ–æ–≥–∏–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –≤–∏–∑—É–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã
                let imageSrc = (cardData.miniImg && cardData.miniImg.trim() !== "") ? cardData.miniImg : cardData.img;
                
                const startPos = getElementPosition(cardElement);
                const targetRect = actualTargetElement.getBoundingClientRect();
                
                let fieldCardWidth = window.innerWidth <= 480 ? 40 : 45;
                if (window.innerWidth <= 360) fieldCardWidth = 35;
                let fieldCardHeight = fieldCardWidth * 1.4;
                
                const targetCenterY = targetRect.top + targetRect.height / 2;
                let targetCenterX = targetRect.left + targetRect.width / 2;

                if (!isTacticsPlacement) {
                    const existingCount = targetRow.querySelectorAll('.card-on-field').length;
                    if ((existingCount + 1) % 2 === 0) {
                        targetCenterX += (existingCount * fieldCardWidth) / 2; 
                    }
                }

                const flyingCard = document.createElement('div');
                flyingCard.className = 'card-flying';
                Object.assign(flyingCard.style, {
                    width: `${startPos.width}px`,
                    height: `${startPos.height}px`,
                    left: `${startPos.x - startPos.width / 2}px`,
                    top: `${startPos.y - startPos.height / 2}px`,
                    borderRadius: '8px',
                    overflow: 'hidden',
                    boxShadow: '0 4px 8px rgba(0,0,0,0.5)'
                });
                
                const flyingImg = document.createElement('img');
                flyingImg.src = imageSrc;
                Object.assign(flyingImg.style, { width: '100%', height: '100%', objectFit: 'cover', display: 'block' });
                
                flyingCard.appendChild(flyingImg);
                document.body.appendChild(flyingCard);
                
                cardElement.style.opacity = '0';
                
                setTimeout(() => {
                    flyingCard.style.left = `${targetCenterX - fieldCardWidth / 2}px`;
                    flyingCard.style.top = `${targetCenterY - fieldCardHeight / 2}px`;
                    flyingCard.style.width = `${fieldCardWidth}px`;
                    flyingCard.style.height = `${fieldCardHeight}px`;
                }, 10);
                
                setTimeout(async () => {
                    const fieldCard = document.createElement('div');
                    fieldCard.className = 'card-on-field';
                    if (cardData.isHero || cardData.cardtype === 'hero') fieldCard.classList.add('hero');
                    
                    const img = document.createElement('img');
                    img.src = imageSrc;
                    fieldCard.appendChild(img);
                    
                    // –ó–∞–ø—Ä–µ—â–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
                    fieldCard.addEventListener('dragstart', (e) => e.preventDefault());
                    img.addEventListener('dragstart', (e) => e.preventDefault());
                    
                    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ–ª–Ω—É—é –∫–∞—Ä—Ç–∏–Ω–∫—É –¥–ª—è –∏–Ω—Å–ø–µ–∫—Ü–∏–∏
                    fieldCard.setAttribute('data-full-img', cardData.img);
                    
                    if (isTacticsPlacement) {
                        const existing = actualTargetElement.querySelector('.card-on-field');
                        if (existing) {
                            playerTacticsCards = playerTacticsCards.filter(c => c.cardData.id !== parseInt(existing.getAttribute('data-card-id')));
                            existing.remove();
                        }
                        playerTacticsCards.push({ cardData, rowId });
                    } else {
                        playerCardsOnField.push({ cardData, rowId });
                    }
                    
                    fieldCard.setAttribute('data-card-id', cardData.id);
                    
                    // –ü–æ–¥–∫–ª—é—á–∞–µ–º –∏–Ω—Å–ø–µ–∫—Ü–∏—é –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
                    addInspectionEvents(fieldCard, cardData.img);
                    addFieldPowerBadge(fieldCard, cardData);
                    
                    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –¥–ª—è —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ Dummy
                    attachDummyClickListener(fieldCard, cardData);
                    
                    insertCardSmartly(actualTargetElement, fieldCard);
                    
                    if (!isTacticsPlacement) updateRowLayout(actualTargetElement);
                    updatePlayerScore();
                    
                    flyingCard.remove();
                    cardElement.remove();
                    updateHandLayout(); // Update hand layout when card is removed
                    
                    const cardIndex = myCards.findIndex(card => card.id === cardData.id);
                    if (cardIndex !== -1) myCards.splice(cardIndex, 1);
                    cardData.used = true;
                    
                    updatePassButtonState();
                    
                    // Check if this is a Provocateur card
                    if (cardData.ability === 'provocateur') {
                        // Disable UI temporarily to show animation
                        isPlayerTurn = false; 
                        await executeProvocateur(cardData, rowId, true); // true = Player is attacker
                        // REMOVED: isPlayerTurn = true; <--- Turn switching handled at bottom of function
                    }
                    
                    // Check if this is a RedCard card
                    if (cardData.ability === 'redcard') {
                        // Disable UI temporarily to show animation
                        isPlayerTurn = false;
                        await executeRedCard(cardData, true); // true = Player is attacker
                    }
                    
                    // Check if this is a Medic card and we're in resurrection mode
                    if (cardData.ability === 'medic' && isMedicResurrecting) {
                        setTimeout(() => {
                            // Filter valid targets (No Heroes, No Medics, No Specials)
                            const revivableCards = playerGraveyardCards.filter(card => isRevivable(card));
                            
                            if (revivableCards.length === 0) {
                                // CASE 1: Nothing to resurrect
                                showGameNotification('–í –æ—Ç–±–æ–µ –Ω–µ—Ç –∫–∞—Ä—Ç –¥–ª—è –≤–æ—Å–∫—Ä–µ—à–µ–Ω–∏—è', 'info');
                                isMedicResurrecting = false;
                                
                                // Resume Game Flow immediately
                                checkRoundEndCondition();
                                
                                // Standard turn switching logic (Copied from bottom of function)
                                const playerIsDone = playerPassed || (myCards.length === 0 && !(currentPlayerCoach && !currentPlayerCoach.isUsed));
                                const enemyIsDone = enemyPassed || (enemyCards.filter(c => !c.used).length === 0 && !(currentEnemyCoach && !currentEnemyCoach.isUsed));

                                if (!(playerIsDone && enemyIsDone)) {
                                     if (!checkAutoPass() && !enemyPassed) {
                                         setTimeout(() => { try { enemyTurn(); } catch (e) { console.error(e); isPlayerTurn = true; } }, 1000);
                                     } else if (enemyPassed) {
                                         isPlayerTurn = true;
                                         updatePassButtonState();
                                     }
                                } else {
                                     setTimeout(() => { endRound(); }, 500);
                                }

                            } else {
                                // CASE 2: Valid targets exist -> Open Overlay
                                openGraveyardView('player', 'medic');
                            }
                        }, 100); 

                        // CRITICAL FIX: STOP execution here! Wait for player selection.
                        return;
                    }
                    
                    // --- STANDARD FLOW (Turn Switching) ---
                    
                    // 1. Check for Active Coach Priority (Player keeps turn if deck empty but coach active)
                    const isCoachAvailable = currentPlayerCoach && currentPlayerCoach.isUsed === false;
                    
                    if (myCards.length === 0 && isCoachAvailable && !playerPassed && enemyPassed) {
                        console.log("Player finished cards but has Active Coach -> Waiting for Player Action.");
                        isPlayerTurn = true;
                        updatePassButtonState(); 
                        return;
                    }
                    
                    // 2. Global State Update
                    checkRoundEndCondition();
                    
                    // 3. Determine Status
                    const playerIsDone = playerPassed || (myCards.length === 0 && !isCoachAvailable);
                    // Filter enemy cards strictly
                    const enemyHasCards = enemyCards.filter(c => !c.used).length > 0;
                    const enemyCoachActive = currentEnemyCoach && currentEnemyCoach.isUsed === false;
                    const enemyIsDone = enemyPassed || (!enemyHasCards && !enemyCoachActive);
                    
                    // 4. Switching Logic
                    if (playerIsDone && enemyIsDone) {
                        // A. Both finished -> End Round
                        console.log("Both players done. Ending round...");
                        setTimeout(() => { endRound(); }, 500);
                        return;
                    }
                    
                    if (enemyPassed) {
                        // B. Enemy Passed -> Player continues (Solitaire mode)
                        console.log("Enemy passed. Player continues.");
                        isPlayerTurn = true;
                        updatePassButtonState();
                    } else {
                        // C. Enemy Active -> Handover to Bot
                        // REMOVED checkAutoPass() here because it caused deadlocks.
                        console.log("Handing over turn to Bot...");
                        setTimeout(() => {
                             try { 
                                 enemyTurn(); 
                             } catch (e) { 
                                 console.error("Failed to start enemyTurn:", e); 
                                 // Emergency recovery if bot crashes on launch
                                 isPlayerTurn = true;
                                 updatePassButtonState();
                             }
                        }, 1000);
                    }
                }, 610);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ placeCardInRow:', error);
                // –†–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥ –∏–≥—Ä–æ–∫–∞ –≤ —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏
                isPlayerTurn = true;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –≤—Å–µ–π –ø–æ–¥—Å–≤–µ—Ç–∫–∏ (—Ä—è–¥–æ–≤ –∏ —Å–ª–æ—Ç–æ–≤ —Ç–∞–∫—Ç–∏–∫–∏)
        function clearAllHighlights() {
            // –û—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Ä—è–¥–æ–≤
            attackRow.style.border = '';
            attackRow.style.boxShadow = '';
            midfieldRow.style.border = '';
            midfieldRow.style.boxShadow = '';
            defenseRow.style.border = '';
            defenseRow.style.boxShadow = '';
            
            // –û—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É —Å–ª–æ—Ç–æ–≤ —Ç–∞–∫—Ç–∏–∫–∏
            attackTacticsSlot.classList.remove('highlight-tactic');
            midfieldTacticsSlot.classList.remove('highlight-tactic');
            defenseTacticsSlot.classList.remove('highlight-tactic');
            
            // BRUTE FORCE: –û—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–ª–µ–π –¥–ª—è Dummy –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ inline —Å—Ç–∏–ª–∏ –∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
            document.querySelectorAll('.card-on-field.valid-target').forEach(card => {
                card.classList.remove('valid-target');
                // Reset inline styles
                card.style.pointerEvents = '';
                card.style.zIndex = '';
                card.style.cursor = '';
                // IMPORTANT: Remove the onclick handler
                card.onclick = null;
            });
            
            // BRUTE FORCE: Also clean up any cards that might have been modified but don't have the class
            // Iterate through all cards on the field to ensure cleanup
            document.querySelectorAll('.card-on-field').forEach(card => {
                // Only reset if zIndex was set to 9999 (our marker)
                if (card.style.zIndex === '9999') {
                    card.style.pointerEvents = '';
                    card.style.zIndex = '';
                    card.style.cursor = '';
                    card.onclick = null;
                }
            });
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–º–µ–Ω—ã —Ä–µ–∂–∏–º–∞ –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏ Dummy
        function cancelDummyTargeting() {
            isDummyTargeting = false;
            selectedDummyCard = null;
            clearAllHighlights();
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–±–º–µ–Ω–∞ Dummy –¥–ª—è –±–æ—Ç–∞
        async function executeEnemyDummySwap(dummyCardData, targetCardData, targetRowId) {
            try {
                // –ù–∞—Ö–æ–¥–∏–º DOM-—ç–ª–µ–º–µ–Ω—Ç —Ü–µ–ª–µ–≤–æ–π –∫–∞—Ä—Ç—ã –Ω–∞ –ø–æ–ª–µ
                const targetRow = getEnemyTargetRow(targetRowId);
                if (!targetRow) {
                    console.error('executeEnemyDummySwap: –ù–µ –Ω–∞–π–¥–µ–Ω —Ü–µ–ª–µ–≤–æ–π —Ä—è–¥');
                    return;
                }
                
                const targetFieldCard = targetRow.querySelector(`[data-card-id="${targetCardData.id}"]`);
                if (!targetFieldCard) {
                    console.error('executeEnemyDummySwap: –ù–µ –Ω–∞–π–¥–µ–Ω–∞ —Ü–µ–ª–µ–≤–∞—è –∫–∞—Ä—Ç–∞ –Ω–∞ –ø–æ–ª–µ');
                    return;
                }
                
                // 1. Coordinates
                const startRect = targetFieldCard.getBoundingClientRect(); // Position on field
                const opponentHandElement = document.getElementById('opponent-hand');
                if (!opponentHandElement) {
                    console.error('executeEnemyDummySwap: –ù–µ –Ω–∞–π–¥–µ–Ω –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ä—É–∫–∏ –±–æ—Ç–∞');
                    return;
                }
                const handRect = opponentHandElement.getBoundingClientRect(); // Position in hand
                
                // 2. Hide original on field immediately
                targetFieldCard.style.opacity = '0';
                
                // 3. Create Flying Spy (Field -> Hand)
                const ghostSpy = targetFieldCard.cloneNode(true);
                ghostSpy.classList.add('ghost-card');
                ghostSpy.style.position = 'fixed';
                ghostSpy.style.width = startRect.width + 'px';
                ghostSpy.style.height = startRect.height + 'px';
                ghostSpy.style.zIndex = '10000';
                ghostSpy.style.pointerEvents = 'none';
                ghostSpy.style.transition = 'none';
                ghostSpy.style.transformOrigin = 'center center';
                
                // Start position: center of field card
                const startX = startRect.left + startRect.width / 2;
                const startY = startRect.top + startRect.height / 2;
                ghostSpy.style.left = startX + 'px';
                ghostSpy.style.top = startY + 'px';
                ghostSpy.style.transform = 'translate(-50%, -50%)';
                document.body.appendChild(ghostSpy);
                
                // 4. Create Flying Dummy (Hand -> Field)
                const flyingDummy = document.createElement('div');
                flyingDummy.className = 'card-flying';
                flyingDummy.style.position = 'fixed';
                flyingDummy.style.zIndex = '10001'; // On top of ghost spy
                flyingDummy.style.pointerEvents = 'none';
                flyingDummy.style.transition = 'none';
                flyingDummy.style.transformOrigin = 'center center';
                flyingDummy.style.borderRadius = '8px';
                flyingDummy.style.overflow = 'hidden';
                flyingDummy.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.6)';
                
                // Start position: center of hand (small size)
                const handCenterX = handRect.left + handRect.width / 2;
                const handCenterY = handRect.top + handRect.height / 2;
                const handCardWidth = 90; // Approximate card width in hand
                const handCardHeight = 126; // Approximate card height in hand
                
                flyingDummy.style.left = handCenterX + 'px';
                flyingDummy.style.top = handCenterY + 'px';
                flyingDummy.style.width = handCardWidth + 'px';
                flyingDummy.style.height = handCardHeight + 'px';
                flyingDummy.style.transform = 'translate(-50%, -50%)';
                
                const dummyImg = document.createElement('img');
                const dummyImageSrc = (dummyCardData.miniImg && dummyCardData.miniImg.trim() !== "") ? dummyCardData.miniImg : dummyCardData.img;
                dummyImg.src = dummyImageSrc;
                dummyImg.style.width = '100%';
                dummyImg.style.height = '100%';
                dummyImg.style.objectFit = 'cover';
                flyingDummy.appendChild(dummyImg);
                document.body.appendChild(flyingDummy);
                
                // 5. Trigger Animations
                requestAnimationFrame(() => {
                    // Spy goes UP (to hand)
                    const targetX = handCenterX;
                    const targetY = handCenterY;
                    ghostSpy.style.transition = 'all 900ms cubic-bezier(0.4, 0, 0.2, 1)';
                    ghostSpy.style.left = targetX + 'px';
                    ghostSpy.style.top = targetY + 'px';
                    
                    // FIX: Removed rotateY(180deg) to prevent mirroring. 
                    // Added opacity fade since it enters a hidden hand.
                    ghostSpy.style.transform = 'translate(-50%, -50%) scale(0.8)'; 
                    ghostSpy.style.opacity = '0'; // Fade out as it enters hand
                    
                    // Dummy comes DOWN (from hand to field) - slight delay for natural swap feel
                    setTimeout(() => {
                        flyingDummy.style.transition = 'all 900ms cubic-bezier(0.4, 0, 0.2, 1)';
                        flyingDummy.style.left = (startRect.left + startRect.width / 2) + 'px';
                        flyingDummy.style.top = (startRect.top + startRect.height / 2) + 'px';
                        flyingDummy.style.width = startRect.width + 'px';
                        flyingDummy.style.height = startRect.height + 'px';
                        flyingDummy.style.transform = 'translate(-50%, -50%)';
                    }, 100);
                });
                
                // 6. Wait for both animations to complete
                await new Promise(resolve => setTimeout(resolve, 950));
                
                // Clean up flying elements
                ghostSpy.remove();
                flyingDummy.remove();
                
                // 2. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö (–°–¢–†–û–ì–ò–ô –ê–õ–ì–û–†–ò–¢–ú –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è)
                
                // 2.1. –ù–∞—Ö–æ–¥–∏–º –ò–ù–î–ï–ö–° —Ü–µ–ª–µ–≤–æ–π –∫–∞—Ä—Ç—ã –≤ –º–∞—Å—Å–∏–≤–µ enemyCardsOnField –ø–æ ID
                const targetFieldIndex = enemyCardsOnField.findIndex(entry => entry.cardData.id === targetCardData.id);
                
                if (targetFieldIndex === -1) {
                    console.error('executeEnemyDummySwap: –¶–µ–ª–µ–≤–∞—è –∫–∞—Ä—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ enemyCardsOnField');
                    return;
                }
                
                // 2.2. –ö–æ–ø–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ —Ü–µ–ª–µ–≤–æ–π –∫–∞—Ä—Ç—ã (–≥–ª—É–±–æ–∫–∞—è –∫–æ–ø–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏)
                const returnedCardData = JSON.parse(JSON.stringify(targetCardData));
                
                // 2.3. –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π –∫–∞—Ä—Ç—ã
                returnedCardData.used = false;
                returnedCardData.isNew = false;
                if (returnedCardData.tempPower !== undefined) {
                    delete returnedCardData.tempPower;
                }
                
                // 2.4. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –±—ã–ª–∞ –ª–∏ —ç—Ç–æ –∫–∞—Ä—Ç–∞ —Ç–∞–∫—Ç–∏–∫–∏ (—É–¥–∞–ª—è–µ–º –∏–∑ —Ç–∞–∫—Ç–∏–∫–∏ –ü–ï–†–ï–î –∑–∞–º–µ–Ω–æ–π)
                const wasTacticsCard = enemyTacticsCards.some(tc => tc.cardData.id === targetCardData.id);
                if (wasTacticsCard) {
                    const tacticsIndex = enemyTacticsCards.findIndex(tc => tc.cardData.id === targetCardData.id);
                    if (tacticsIndex !== -1) {
                        enemyTacticsCards.splice(tacticsIndex, 1);
                    }
                }
                
                // 2.5. –ó–ê–ú–ï–ù–Ø–ï–ú –æ–±—ä–µ–∫—Ç –≤ enemyCardsOnField –ø–æ –∏–Ω–¥–µ–∫—Å—É –Ω–∞ –ú–∞–Ω–µ–∫–µ–Ω–∞ (–ù–ï push!)
                // –ù–∞—Ö–æ–¥–∏–º –º–∞–Ω–µ–∫–µ–Ω–∞ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ—Ä–∞–∫—Ü–∏–∏ –±–æ—Ç–∞
                let dummyCardFromDB = null;
                if (typeof allGameData !== 'undefined') {
                    if (enemyTeamKey === 'allSpartakCards' && allGameData.allSpartakCards) {
                        dummyCardFromDB = allGameData.allSpartakCards.find(card => card.ability === 'dummy');
                    } else if (enemyTeamKey === 'allRPLCards' && allGameData.allRPLCards) {
                        dummyCardFromDB = allGameData.allRPLCards.find(card => card.ability === 'dummy');
                    } else if (enemyTeamKey === 'allFootballStarsCards' && allGameData.allFootballStarsCards) {
                        dummyCardFromDB = allGameData.allFootballStarsCards.find(card => card.ability === 'dummy');
                    }
                }
                
                // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ –±–∞–∑–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ dummyCardData (fallback)
                const finalDummyCard = dummyCardFromDB || dummyCardData;
                
                // –ó–ê–ú–ï–ù–ê –ø–æ –∏–Ω–¥–µ–∫—Å—É (–Ω–µ push!)
                enemyCardsOnField[targetFieldIndex] = { 
                    cardData: JSON.parse(JSON.stringify(finalDummyCard)), // –ì–ª—É–±–æ–∫–∞—è –∫–æ–ø–∏—è
                    rowId: targetRowId 
                };
                
                // 2.6. –£–¥–∞–ª—è–µ–º Dummy –∏–∑ —Ä—É–∫–∏
                const dummyIndex = enemyCards.findIndex(card => card.id === dummyCardData.id);
                if (dummyIndex !== -1) {
                    enemyCards.splice(dummyIndex, 1);
                }
                
                // 2.7. –î–æ–±–∞–≤–ª—è–µ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—É—é –∫–∞—Ä—Ç—É –≤ —Ä—É–∫—É (Smart Upsert)
                // FIX: Find ANY instance of this card ID (even if used) to prevent duplicates
                const existingIndex = enemyCards.findIndex(card => card.id === returnedCardData.id);
                
                if (existingIndex !== -1) {
                    // Revive the existing card entry
                    console.log(`AI (Dummy): Card ${returnedCardData.name} found in memory. Resetting state.`);
                    enemyCards[existingIndex] = returnedCardData;
                    enemyCards[existingIndex].used = false; // Important: Mark as active
                } else {
                    // New entry
                    enemyCards.push(returnedCardData);
                    console.log(`AI (Dummy): Returned ${returnedCardData.name} to hand.`);
                }
                
                // 3. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ DOM
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º finalDummyCard, –∫–æ—Ç–æ—Ä—ã–π —É–∂–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω –≤—ã—à–µ (—Å—Ç—Ä–æ–∫–∞ 6519)
                const finalDummyImageSrc = (finalDummyCard.miniImg && finalDummyCard.miniImg.trim() !== "") 
                    ? finalDummyCard.miniImg 
                    : finalDummyCard.img;
                
                const newFieldCard = document.createElement('div');
                newFieldCard.className = 'card-on-field';
                if (finalDummyCard.isHero || finalDummyCard.cardtype === 'hero') {
                    newFieldCard.classList.add('hero');
                }
                
                const newImg = document.createElement('img');
                newImg.src = finalDummyImageSrc;
                newFieldCard.appendChild(newImg);
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º ID –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö (–∏–ª–∏ –∏–∑ dummyCardData –∫–∞–∫ fallback)
                newFieldCard.setAttribute('data-card-id', finalDummyCard.id);
                newFieldCard.setAttribute('data-full-img', finalDummyCard.img);
                
                newFieldCard.addEventListener('dragstart', (e) => e.preventDefault());
                newImg.addEventListener('dragstart', (e) => e.preventDefault());
                
                addInspectionEvents(newFieldCard, finalDummyCard.img);
                addFieldPowerBadge(newFieldCard, finalDummyCard);
                
                // –ó–∞–º–µ–Ω—è–µ–º —Å—Ç–∞—Ä—É—é –∫–∞—Ä—Ç—É –Ω–∞ –Ω–æ–≤—É—é
                targetFieldCard.replaceWith(newFieldCard);
                
                // –£–¥–∞–ª—è–µ–º –∫–∞—Ä—Ç—É –∏–∑ —Ä—É–∫–∏ –±–æ—Ç–∞ (DOM)
                const dummyCardBackElement = enemyCardsContainer.querySelector(`[data-enemy-card-id="${dummyCardData.id}"]`);
                if (dummyCardBackElement) {
                    dummyCardBackElement.remove();
                }
                
                // 4. –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û–ï –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–π —á–∞—Å—Ç–∏ —Ä—è–¥–∞ (–∫—Ä–∏—Ç–∏—á–Ω–æ!)
                // –í—ã–∑—ã–≤–∞–µ–º updateRowLayout –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ DOM —Å –¥–∞–Ω–Ω—ã–º–∏ –º–∞—Å—Å–∏–≤–∞
                if (targetRow) {
                    updateRowLayout(targetRow);
                }
                
                // 5. –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI
                updateEnemyScore();
                renderEnemyHand();
                renderOpponentHand();
                
                // 6. –ü—Ä–æ–≤–µ—Ä–∫–∞ —É—Å–ª–æ–≤–∏–π —Ä–∞—É–Ω–¥–∞
                checkRoundEndCondition();
                
                // 7. Turn Switch
                handleTurnSwitch();
                
                console.log('AI (Dummy): –û–±–º–µ–Ω –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ executeEnemyDummySwap:', error);
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–±–º–µ–Ω–∞ Dummy
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–±–º–µ–Ω–∞ Dummy (–ú–∞–Ω–µ–∫–µ–Ω)
        function executeDummySwap(targetFieldCard, targetCardData, targetRowId) {
            try {
                if (!selectedDummyCard || !isDummyTargeting) return;
                
                const { cardElement: dummyInHand, cardData: dummyData } = selectedDummyCard;
                
                // 1. DATA VALIDATION
                const targetIndex = playerCardsOnField.findIndex(entry => entry.cardData.id === targetCardData.id);
                if (targetIndex === -1) {
                    console.error("Target not found in logic array");
                    return;
                }

                console.log("Executing Swap: Dummy ->", targetCardData.name);

                // 2. CAPTURE COORDINATES (CRITICAL: Before hiding anything)
                const rectHand = dummyInHand.getBoundingClientRect();
                const rectField = targetFieldCard.getBoundingClientRect();

                // 3. CREATE FLYING ELEMENTS
                // A. Flying Dummy (Hand -> Field)
                const flyDummy = document.createElement('div');
                flyDummy.className = 'card-flying';
                const dummySrc = (dummyData.miniImg && dummyData.miniImg !== "") ? dummyData.miniImg : dummyData.img;
                
                Object.assign(flyDummy.style, {
                    position: 'fixed',
                    width: `${rectHand.width}px`,
                    height: `${rectHand.height}px`,
                    left: `${rectHand.left}px`,
                    top: `${rectHand.top}px`,
                    zIndex: '10000',
                    transition: 'all 0.6s cubic-bezier(0.25, 0.8, 0.25, 1)'
                });
                
                const imgDummy = document.createElement('img');
                imgDummy.src = dummySrc;
                imgDummy.style.width = '100%'; imgDummy.style.height = '100%'; imgDummy.style.objectFit = 'cover';
                flyDummy.appendChild(imgDummy);

                // B. Flying Target (Field -> Hand)
                const flyTarget = document.createElement('div');
                flyTarget.className = 'card-flying';
                // Use full image for return trip as it goes to hand
                const targetSrc = targetCardData.img; 
                
                Object.assign(flyTarget.style, {
                    position: 'fixed',
                    width: `${rectField.width}px`,
                    height: `${rectField.height}px`,
                    left: `${rectField.left}px`,
                    top: `${rectField.top}px`,
                    zIndex: '10001', // On top of dummy
                    transition: 'all 0.6s cubic-bezier(0.25, 0.8, 0.25, 1)'
                });

                const imgTarget = document.createElement('img');
                imgTarget.src = targetSrc;
                imgTarget.style.width = '100%'; imgTarget.style.height = '100%'; imgTarget.style.objectFit = 'cover';
                flyTarget.appendChild(imgTarget);

                // Append to body
                document.body.appendChild(flyDummy);
                document.body.appendChild(flyTarget);

                // 4. HIDE ORIGINALS
                dummyInHand.style.opacity = '0';
                targetFieldCard.style.opacity = '0';

                // 5. ANIMATE
                // Force Reflow
                void flyDummy.offsetWidth; 

                requestAnimationFrame(() => {
                    // Dummy goes to Field
                    flyDummy.style.width = `${rectField.width}px`;
                    flyDummy.style.height = `${rectField.height}px`;
                    flyDummy.style.left = `${rectField.left}px`;
                    flyDummy.style.top = `${rectField.top}px`;

                    // Target goes to Hand
                    flyTarget.style.width = `${rectHand.width}px`;
                    flyTarget.style.height = `${rectHand.height}px`;
                    flyTarget.style.left = `${rectHand.left}px`;
                    flyTarget.style.top = `${rectHand.top}px`;
                });

                // 6. LOGIC UPDATES (During animation)
                // A. Remove Dummy from Hand
                const dummyHandIndex = myCards.findIndex(c => c.id === dummyData.id);
                if (dummyHandIndex !== -1) myCards.splice(dummyHandIndex, 1);

                // B. Prepare Returning Card
                const returnedCard = JSON.parse(JSON.stringify(targetCardData));
                returnedCard.used = false;
                returnedCard.isNew = false;
                delete returnedCard.tempPower;

                // C. Add Returned Card to Hand
                if (!myCards.some(c => c.id === returnedCard.id)) {
                    myCards.push(returnedCard);
                }

                // D. Clean Tactics
                const wasTactic = playerTacticsCards.some(tc => tc.cardData.id === targetCardData.id);
                if (wasTactic) {
                    playerTacticsCards = playerTacticsCards.filter(tc => tc.cardData.id !== targetCardData.id);
                }

                // E. SWAP IN ARRAY
                // Find correct Dummy DB Data
                let dummyDB = dummyData;
                if (typeof allGameData !== 'undefined' && playerTeamKey && allGameData[playerTeamKey]) {
                     const found = allGameData[playerTeamKey].find(c => c.ability === 'dummy');
                     if (found) dummyDB = found;
                }
                
                // Replace in logic
                playerCardsOnField[targetIndex] = {
                    cardData: JSON.parse(JSON.stringify(dummyDB)),
                    rowId: targetRowId
                };

                // 7. FINALIZE (After Animation)
                setTimeout(() => {
                    // Clean flyers
                    if(flyDummy) flyDummy.remove();
                    if(flyTarget) flyTarget.remove();
                    if(dummyInHand) dummyInHand.remove();

                    // DOM REPLACEMENT (Target -> New Dummy)
                    const newFieldCard = document.createElement('div');
                    newFieldCard.className = 'card-on-field';
                    
                    const newImg = document.createElement('img');
                    newImg.src = dummyDB.miniImg || dummyDB.img;
                    newFieldCard.appendChild(newImg);
                    
                    newFieldCard.setAttribute('data-card-id', dummyDB.id);
                    newFieldCard.setAttribute('data-full-img', dummyDB.img);
                    newFieldCard.addEventListener('dragstart', (e) => e.preventDefault());
                    addInspectionEvents(newFieldCard, dummyDB.img);
                    addFieldPowerBadge(newFieldCard, dummyDB);
                    
                    if (targetFieldCard && targetFieldCard.parentNode) {
                        targetFieldCard.replaceWith(newFieldCard);
                    }

                    // Update UI
                    renderPlayerHand();
                    updatePlayerScore();
                    updatePassButtonState();
                    cancelDummyTargeting();
                    
                    const rowEl = getTargetRow(targetRowId);
                    if (rowEl) updateRowLayout(rowEl);

                    // Turn Switch
                    checkRoundEndCondition();
                    isPlayerTurn = false;
                    movesCount++;
                    
                    setTimeout(() => {
                        if (!playerPassed && !checkAutoPass()) {
                             if (enemyPassed) {
                                 isPlayerTurn = true;
                                 updatePassButtonState();
                             } else {
                                 enemyTurn();
                             }
                        }
                    }, 1000);

                }, 600); // Sync with CSS transition time

            } catch (error) {
                console.error('Swap Error:', error);
                // Emergency Cleanup
                const artifacts = document.querySelectorAll('.card-flying');
                artifacts.forEach(a => a.remove());
                cancelDummyTargeting();
                renderPlayerHand();
                isPlayerTurn = true;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Å–ª–æ—Ç–æ–≤ —Ç–∞–∫—Ç–∏–∫–∏ (–¥–ª—è –∫–∞—Ä—Ç support)
        function highlightTacticsSlots() {
            clearAllHighlights(); // –°–Ω–∞—á–∞–ª–∞ –æ—á–∏—â–∞–µ–º –≤—Å–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            attackTacticsSlot.classList.add('highlight-tactic');
            midfieldTacticsSlot.classList.add('highlight-tactic');
            defenseTacticsSlot.classList.add('highlight-tactic');
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Ä—è–¥–æ–≤ (–¥–ª—è –∫–∞—Ä—Ç —Å position === 'any', –Ω–æ –Ω–µ support)
        function highlightRows() {
            clearAllHighlights(); // –°–Ω–∞—á–∞–ª–∞ –æ—á–∏—â–∞–µ–º –≤—Å–µ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
            attackRow.style.border = '2px solid yellow';
            attackRow.style.boxShadow = '0 0 10px yellow';
            midfieldRow.style.border = '2px solid yellow';
            midfieldRow.style.boxShadow = '0 0 10px yellow';
            defenseRow.style.border = '2px solid yellow';
            defenseRow.style.boxShadow = '0 0 10px yellow';
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Å–Ω—è—Ç–∏—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏ —Ä—è–¥–æ–≤ (—É—Å—Ç–∞—Ä–µ–≤—à–∞—è, –∏—Å–ø–æ–ª—å–∑—É–µ–º clearAllHighlights)
        function unhighlightRows() {
            clearAllHighlights();
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —Å—Ç–∞—Ä—Ç–æ–≤–æ–≥–æ –º–µ–Ω—é
        const startScreen = document.getElementById('start-screen');
        const gameScreen = document.getElementById('game-screen');
        const factionScreen = document.getElementById('faction-screen');
        const squadScreen = document.getElementById('squad-screen');
        const btnStart = document.getElementById('btn-start');
        const btnCollection = document.getElementById('btn-collection');
        const btnPacks = document.getElementById('btn-packs');
        const btnPoints = document.getElementById('btn-points');
        const btnBackToMenu = document.getElementById('btn-back-to-menu');
        const collectionCardsScreen = document.getElementById('collection-cards-screen');
        const btnBackFromCards = document.getElementById('btn-back-from-cards');
        const btnBackFromSquad = document.getElementById('btn-back-from-squad');
        const collectionCardsTitle = document.getElementById('collection-cards-title');
        const collectionCardsGrid = document.getElementById('collection-cards-grid');
        const collectionFactionScreen = document.getElementById('collection-faction-screen');
        const btnBackFromCollectionSelect = document.getElementById('btn-back-from-collection-select');
        const collectionTeamGrid = document.getElementById('collection-team-grid');
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —ç–∫—Ä–∞–Ω–∞ —Å–æ—Å—Ç–∞–≤–∞
        let squadTimerInterval = null;
        let selectedCardsForSwap = [];
        let replacementsLeft = 3; // –õ–∏–º–∏—Ç –∑–∞–º–µ–Ω (–º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–æ 3 —Ä–∞–∑)
        let usedReplacements = 0; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö –∑–∞–º–µ–Ω (–¥–ª—è —Å—á–µ—Ç—á–∏–∫–∞ X/3)
        let newlyArrivedCardIds = []; // ID –∫–∞—Ä—Ç, –∫–æ—Ç–æ—Ä—ã–µ —Ç–æ–ª—å–∫–æ —á—Ç–æ –±—ã–ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø—Ä–∏ –∑–∞–º–µ–Ω–µ
        let isCollectionMode = false; // true = —Å–º–æ—Ç—Ä–∏–º –∫–æ–ª–ª–µ–∫—Ü–∏—é, false = –Ω–∞—á–∏–Ω–∞–µ–º –∏–≥—Ä—É
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –ø–µ—Ä–µ—Ö–æ–¥–∞ –º–µ–∂–¥—É —ç–∫—Ä–∞–Ω–∞–º–∏
        function showScreen(screenToShow, screenToHide) {
            screenToHide.style.opacity = '0';
            setTimeout(function() {
                screenToHide.style.display = 'none';
                // –î–ª—è gameScreen –∏—Å–ø–æ–ª—å–∑—É–µ–º flex, –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–æ–∂–µ flex
                screenToShow.style.display = 'flex';
                screenToShow.style.opacity = '0';
                setTimeout(function() {
                    screenToShow.style.opacity = '1';
                }, 10);
            }, 300);
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞—á–∞—Ç—å –∏–≥—Ä—É" - —Ç–µ–ø–µ—Ä—å –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã
        btnStart.addEventListener('click', function() {
            isCollectionMode = false; // –†–µ–∂–∏–º –∏–≥—Ä—ã
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±–æ—Ä –∫–æ–º–∞–Ω–¥
            resetFactionSelection();
            showScreen(factionScreen, startScreen);
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥" - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é –∏ —á–∏—Å—Ç–∏—Ç –ø–∞–º—è—Ç—å
        btnBackToMenu.addEventListener('click', function() {
            showScreen(startScreen, factionScreen);
            
            // CLEANUP: Wipe containers to prevent duplicates/leaks
            document.getElementById('cardsContainer').innerHTML = '';
            document.getElementById('enemyCardsContainer').innerHTML = '';
            document.getElementById('opponent-hand').innerHTML = '';
            document.getElementById('squad-grid').innerHTML = '';
            
            // Reset Arrays
            myCards = [];
            enemyCards = [];
            console.log("Game state cleaned up.");
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥" –∏–∑ —ç–∫—Ä–∞–Ω–∞ —Å–æ—Å—Ç–∞–≤–∞ - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ –≤—ã–±–æ—Ä—É –∫–æ–º–∞–Ω–¥—ã
        if (btnBackFromSquad) {
            btnBackFromSquad.addEventListener('click', function() {
                // –ö–†–ò–¢–ò–ß–ù–û: –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–∞–π–º–µ—Ä, –∏–Ω–∞—á–µ –º–∞—Ç—á –Ω–∞—á–Ω–µ—Ç—Å—è —Å–∞–º –ø–æ —Å–µ–±–µ
                if (squadTimerInterval) {
                    clearInterval(squadTimerInterval);
                    squadTimerInterval = null;
                }
                
                // –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –∫ –≤—ã–±–æ—Ä—É –∫–æ–º–∞–Ω–¥—ã
                showScreen(factionScreen, squadScreen);
                
                // –û—á–∏—â–∞–µ–º –º–∞—Å—Å–∏–≤—ã –∫–∞—Ä—Ç, —á—Ç–æ–±—ã –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –≤—Ö–æ–¥–µ –Ω–µ –±—ã–ª–æ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤
                myCards = [];
                selectedCardsForSwap = [];
                usedReplacements = 0;
                
                console.log("Returned to faction selection, timer stopped.");
            });
        }
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–æ–º–∞–Ω–¥
        let selectedPlayerTeam = null;
        let selectedEnemyTeam = null;
        
        // –§—É–Ω–∫—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –∫–Ω–æ–ø–∫–∏ "–î–ê–õ–ï–ï"
        function updateNextButton() {
            const btnNext = document.getElementById('btn-faction-next');
            if (selectedPlayerTeam && selectedEnemyTeam) {
                btnNext.disabled = false;
            } else {
                btnNext.disabled = true;
            }
        }
        
        // –§—É–Ω–∫—Ü–∏—è —Å–±—Ä–æ—Å–∞ –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥
        function resetFactionSelection() {
            selectedPlayerTeam = null;
            selectedEnemyTeam = null;
            // –£–±–∏—Ä–∞–µ–º –∫–ª–∞—Å—Å selected —Å–æ –≤—Å–µ—Ö –∫–≤–∞–¥—Ä–∞—Ç–æ–≤
            document.querySelectorAll('.faction-square').forEach(function(sq) {
                sq.classList.remove('selected');
            });
            updateNextButton();
        }
        
        // –§—É–Ω–∫—Ü–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã (–≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ)
        function initFactionSelector() {
            const playerGrid = document.getElementById('player-faction-grid');
            const enemyGrid = document.getElementById('enemy-faction-grid');
            const btnNext = document.getElementById('btn-faction-next');
            
            // –°–±—Ä–æ—Å –≤—ã–±–æ—Ä–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
            resetFactionSelection();
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –≤–µ—Ä—Ö–Ω–µ–π —Å–µ–∫—Ü–∏–∏ (—Å–≤–æ—è –∫–æ–º–∞–Ω–¥–∞)
            const playerSquares = playerGrid.querySelectorAll('.faction-square:not(.locked)');
            playerSquares.forEach(function(square) {
                square.addEventListener('click', function() {
                    // –£–±–∏—Ä–∞–µ–º selected —É –≤—Å–µ—Ö –≤ —ç—Ç–æ–π —Å–µ–∫—Ü–∏–∏
                    playerSquares.forEach(function(sq) {
                        sq.classList.remove('selected');
                    });
                    // –î–æ–±–∞–≤–ª—è–µ–º selected –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É
                    this.classList.add('selected');
                    selectedPlayerTeam = this.getAttribute('data-team');
                    updateNextButton();
                });
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –Ω–∏–∂–Ω–µ–π —Å–µ–∫—Ü–∏–∏ (—Å–æ–ø–µ—Ä–Ω–∏–∫)
            const enemySquares = enemyGrid.querySelectorAll('.faction-square:not(.locked)');
            enemySquares.forEach(function(square) {
                square.addEventListener('click', function() {
                    // –£–±–∏—Ä–∞–µ–º selected —É –≤—Å–µ—Ö –≤ —ç—Ç–æ–π —Å–µ–∫—Ü–∏–∏
                    enemySquares.forEach(function(sq) {
                        sq.classList.remove('selected');
                    });
                    // –î–æ–±–∞–≤–ª—è–µ–º selected –∫ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É
                    this.classList.add('selected');
                    selectedEnemyTeam = this.getAttribute('data-team');
                    updateNextButton();
                });
            });
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–î–ê–õ–ï–ï" (–¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –æ–¥–∏–Ω —Ä–∞–∑)
            btnNext.addEventListener('click', function() {
                if (btnNext.disabled) return;
                
                // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–æ–º–∞–Ω–¥
                if (selectedPlayerTeam === 'spartak') {
                    playerTeamKey = 'allSpartakCards';
                } else if (selectedPlayerTeam === 'footballstars') {
                    playerTeamKey = 'allFootballStarsCards';
                } else if (selectedPlayerTeam === 'rpl') {
                    playerTeamKey = 'allRPLCards';
                }
                
                if (selectedEnemyTeam === 'spartak') {
                    enemyTeamKey = 'allSpartakCards';
                } else if (selectedEnemyTeam === 'footballstars') {
                    enemyTeamKey = 'allFootballStarsCards';
                } else if (selectedEnemyTeam === 'rpl') {
                    enemyTeamKey = 'allRPLCards';
                }
                
                // –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —ç–∫—Ä–∞–Ω—É —Å–æ—Å—Ç–∞–≤–∞
                showSquadScreen();
            });
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        initFactionSelector();
        
        // Initialize Collection Team Squares
        function initCollectionSelector() {
            const squares = collectionTeamGrid.querySelectorAll('.faction-square:not(.locked)');
            
            squares.forEach(sq => {
                sq.addEventListener('click', function() {
                    const teamKey = this.getAttribute('data-view-team');
                    
                    // Map short keys to full names expected by showCollectionCards
                    let teamName = '';
                    if (teamKey === 'spartak') teamName = '–°–ø–∞—Ä—Ç–∞–∫';
                    if (teamKey === 'footballstars') teamName = '–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞';
                    if (teamKey === 'rpl') teamName = '–†–ü–õ';
                    
                    showCollectionCards(teamName);
                });
            });
        }
        
        // Call init
        initCollectionSelector();
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∫–Ω–æ–ø–æ–∫ (–ø–æ–∫–∞ –∑–∞–≥–ª—É—à–∫–∏)
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ú–æ—è –∫–æ–ª–ª–µ–∫—Ü–∏—è" - –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–æ–≤—ã–π —ç–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏
        btnCollection.addEventListener('click', function() {
            isCollectionMode = true;
            // Show the NEW Collection Selection Screen instead of the Game Faction Screen
            showScreen(collectionFactionScreen, startScreen);
        });
        
        // Back Button from Collection Selection -> Main Menu
        if (btnBackFromCollectionSelect) {
            btnBackFromCollectionSelect.addEventListener('click', function() {
                showScreen(startScreen, collectionFactionScreen);
            });
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–∫–∏ "–ù–∞–∑–∞–¥" –∏–∑ –∫–∞—Ä—Ç –∫–æ–ª–ª–µ–∫—Ü–∏–∏ - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫ –≤—ã–±–æ—Ä—É –∫–æ–º–∞–Ω–¥—ã
        btnBackFromCards.addEventListener('click', function() {
            if (isCollectionMode) {
                showScreen(collectionFactionScreen, collectionCardsScreen);
            } else {
                // Should technically not happen if we separate flows, but safe fallback
                showScreen(factionScreen, collectionCardsScreen);
            }
        });
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ –∫–∞—Ä—Ç –∫–æ–ª–ª–µ–∫—Ü–∏–∏
        function showCollectionCards(teamName) {
            // 1. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
            const collectionTitle = document.getElementById('collection-cards-title');
            if (collectionTitle) {
                collectionTitle.textContent = `–ö–û–õ–õ–ï–ö–¶–ò–Ø: ${teamName.toUpperCase()}`;
            }
            
            // 2. –û–±–Ω–æ–≤–ª—è–µ–º –ª–æ–≥–æ—Ç–∏–ø –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            let teamKey = null;
            if (teamName === '–°–ø–∞—Ä—Ç–∞–∫' || teamName === 'spartak') {
                teamKey = 'allSpartakCards';
            } else if (teamName === '–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞' || teamName === 'footballstars' || teamName === 'stars') {
                teamKey = 'allFootballStarsCards';
            } else if (teamName === '–†–ü–õ' || teamName === 'rpl') {
                teamKey = 'allRPLCards';
            }
            
            if (teamKey && teamLogos[teamKey]) {
                // –ò—â–µ–º –ª–æ–≥–æ—Ç–∏–ø –≤ –∫–æ–ª–ª–µ–∫—Ü–∏–∏ (–º–æ–∂–µ—Ç –±—ã—Ç—å –≤ —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö)
                const collectionLogo = document.querySelector('#collection-cards-screen .team-logo, #faction-screen .team-logo, .collection-logo');
                if (collectionLogo) {
                    // –î–ª—è –∫–æ–ª–ª–µ–∫—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–≤–µ—Ç–ª—É—é –≤–µ—Ä—Å–∏—é (—á–µ—Ä–Ω—ã–π –ª–æ–≥–æ—Ç–∏–ø)
                    collectionLogo.src = teamLogos[teamKey].light;
                }
            }
            
            // 3. –û—á–∏—â–∞–µ–º —Å–µ—Ç–∫—É
            const grid = document.getElementById('collection-cards-grid');
            if (grid) grid.innerHTML = '';
            
            // 4. –í—ã–±–∏—Ä–∞–µ–º –º–∞—Å—Å–∏–≤ –∫–∞—Ä—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–º–∞–Ω–¥—ã
            let sourceCards = [];
            
            // –í—ã–±–∏—Ä–∞–µ–º –º–∞—Å—Å–∏–≤ –∫–∞—Ä—Ç –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–º–∞–Ω–¥—ã
            if (teamName === '–°–ø–∞—Ä—Ç–∞–∫' || teamName === 'spartak') {
                // –ë–µ—Ä–µ–º –∫–æ–ø–∏—é –≤—Å–µ—Ö –∫–∞—Ä—Ç –°–ø–∞—Ä—Ç–∞–∫–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                if (typeof allGameData !== 'undefined' && allGameData.allSpartakCards) {
                    sourceCards = [...allGameData.allSpartakCards];
                }
            } else if (teamName === '–ó–≤–µ–∑–¥—ã —Ñ—É—Ç–±–æ–ª–∞' || teamName === 'footballstars' || teamName === 'stars') {
                // –ë–µ—Ä–µ–º –∫–æ–ø–∏—é –≤—Å–µ—Ö –∫–∞—Ä—Ç –ó–≤–µ–∑–¥ —Ñ—É—Ç–±–æ–ª–∞ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                if (typeof allGameData !== 'undefined' && allGameData.allFootballStarsCards) {
                    sourceCards = [...allGameData.allFootballStarsCards];
                }
            } else if (teamName === '–†–ü–õ' || teamName === 'rpl') {
                // –ë–µ—Ä–µ–º –∫–æ–ø–∏—é –≤—Å–µ—Ö –∫–∞—Ä—Ç –†–ü–õ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
                if (typeof allGameData !== 'undefined' && allGameData.allRPLCards) {
                    sourceCards = [...allGameData.allRPLCards];
                }
            } else {
                // –ó–∞–≥–ª—É—à–∫–∞ –¥–ª—è –¥—Ä—É–≥–∏—Ö –∫–æ–º–∞–Ω–¥
                console.log('–ö–∞—Ä—Ç—ã –¥–ª—è –∫–æ–º–∞–Ω–¥—ã ' + teamName + ' –ø–æ–∫–∞ –Ω–µ –¥–æ–±–∞–≤–ª–µ–Ω—ã –≤ –±–∞–∑—É.');
                return; 
            }

            // 4. –°–û–†–¢–ò–†–û–í–ö–ê (–°–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ)
            sourceCards.sort((a, b) => {
                // –ê. –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Å–∏–ª–µ (Power) - —É–±—ã–≤–∞–Ω–∏–µ
                const powerA = a.power || 0;
                const powerB = b.power || 0;
                
                if (powerB !== powerA) {
                    return powerB - powerA; // –ö—Ç–æ —Å–∏–ª—å–Ω–µ–µ, —Ç–æ—Ç –≤—ã—à–µ
                }
                
                // –ë. –ï—Å–ª–∏ —Å–∏–ª–∞ —Ä–∞–≤–Ω–∞ -> –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ì–µ—Ä–æ—è–º
                const isHeroA = (a.isHero || a.cardtype === 'hero');
                const isHeroB = (b.isHero || b.cardtype === 'hero');
                
                if (isHeroA && !isHeroB) return -1; // A –≥–µ—Ä–æ–π, B –Ω–µ—Ç -> A –≤—ã—à–µ
                if (!isHeroA && isHeroB) return 1;  // B –≥–µ—Ä–æ–π, A –Ω–µ—Ç -> B –≤—ã—à–µ
                
                // –í. –ï—Å–ª–∏ –æ–±–∞ –≥–µ—Ä–æ–∏ (–∏–ª–∏ –æ–±–∞ –Ω–µ –≥–µ—Ä–æ–∏) -> –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –°–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º (Ability)
                // –°—á–∏—Ç–∞–µ–º, —á—Ç–æ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å –µ—Å—Ç—å, –µ—Å–ª–∏ ability –∑–∞–¥–∞–Ω –∏ –Ω–µ —Ä–∞–≤–µ–Ω 'none'
                const hasAbilityA = (a.ability && a.ability !== 'none');
                const hasAbilityB = (b.ability && b.ability !== 'none');
                
                if (hasAbilityA && !hasAbilityB) return -1;
                if (!hasAbilityA && hasAbilityB) return 1;
                
                // –ì. –ï—Å–ª–∏ –≤—Å—ë —Ä–∞–≤–Ω–æ -> –ø–æ –∏–º–µ–Ω–∏ (–∞–ª—Ñ–∞–≤–∏—Ç)
                const nameA = a.name || '';
                const nameB = b.name || '';
                return nameA.localeCompare(nameB);
            });

            // 5. –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∫–∞—Ä—Ç (Render)
            sourceCards.forEach(cardData => {
                const cardElement = document.createElement('div');
                cardElement.className = 'collection-card';
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å hero
                if (cardData.isHero || cardData.cardtype === 'hero') {
                    cardElement.classList.add('hero');
                }
                
                // –ö–∞—Ä—Ç–∏–Ω–∫–∞
                const cardImage = document.createElement('img');
                cardImage.src = cardData.img;
                cardImage.alt = cardData.name || `–ö–∞—Ä—Ç–∞ ${cardData.id}`;
                cardElement.appendChild(cardImage);
                
                /* REMOVED: Power Badges not needed in Collection View
                // –ö—Ä—É–∂–æ–∫ —Å —Å–∏–ª–æ–π
                if (cardData.power !== undefined) {
                    const powerElement = document.createElement('div');
                    powerElement.className = 'card-power';
                    powerElement.textContent = cardData.power;
                    cardElement.appendChild(powerElement);
                }
                */
                
                // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–µ—Ç–∫—É
                if (grid) grid.appendChild(cardElement);
                
                // Add inspection events to collection cards
                addInspectionEvents(cardElement, cardData.img);
            });
            
            // 6. –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —ç–∫—Ä–∞–Ω
            showScreen(document.getElementById('collection-cards-screen'), collectionFactionScreen);
        }
        
        btnPacks.addEventListener('click', function() {
            showGameNotification('–†–∞–∑–¥–µ–ª –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ', 'info');
        });
        
        btnPoints.addEventListener('click', function() {
            showGameNotification('–†–∞–∑–¥–µ–ª –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ', 'info');
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ –∫–∞—Ä—Ç—É (—Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –∑–∞–≤–∏—Å–∞–Ω–∏–π)
        function handleCardClick(cardElement, cardData) {
            try {
                // 0. –ê–≤–∞—Ä–∏–π–Ω—ã–π —Å–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ –∏–Ω—Å–ø–µ–∫—Ü–∏–∏, –µ—Å–ª–∏ –æ–Ω –∑–∞–≤–∏—Å
                if (ignoreNextClick) {
                    console.warn("–°–±—Ä–æ—Å –∑–∞–≤–∏—Å—à–µ–≥–æ —Ñ–ª–∞–≥–∞ ignoreNextClick");
                    ignoreNextClick = false;
                    // –ü—Ä–µ—Ä—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —ç—Ç–æ—Ç –∫–ª–∏–∫, —Å–ª–µ–¥—É—é—â–∏–π —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
                    return;
                }

                // 1. –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                if (!isPlayerTurn || playerPassed) {
                    console.log('–ö–ª–∏–∫ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –°—Ç–∞—Ç—É—Å:', {
                        isPlayerTurn,
                        playerPassed,
                        enemyPassed,
                        enemyCardsCount: enemyCards.length
                    });

                    // --- –ê–í–ê–†–ò–ô–ù–´–ô –†–ê–ó–ë–õ–û–ö–ò–†–û–í–©–ò–ö (SMART) ---
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –ª–µ—Ç–∏—Ç –ª–∏ —Å–µ–π—á–∞—Å –∫–∞—Ä—Ç–∞ (–∞–Ω–∏–º–∞—Ü–∏—è). –ï—Å–ª–∏ –ª–µ—Ç–∏—Ç ‚Äî —ç—Ç–æ –Ω–µ –±–∞–≥, –ø—Ä–æ—Å—Ç–æ –∂–¥–µ–º.
                    const isAnimating = document.querySelector('.card-flying') !== null;

                    const hasActiveEnemyCoach = enemyDefenseRightSlot && enemyDefenseRightSlot.querySelector('.coach-card:not(.used)');
                    const enemyIsDone = enemyPassed || (enemyCards.length === 0 && !hasActiveEnemyCoach);
                    
                    if (!isPlayerTurn && !playerPassed && enemyIsDone) {
                        if (isAnimating) {
                            // –ï—Å–ª–∏ –∏–¥–µ—Ç –∞–Ω–∏–º–∞—Ü–∏—è, –ø—Ä–æ—Å—Ç–æ –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫ –±–µ–∑ –ø–∞–Ω–∏–∫–∏
                            console.log("–ö–ª–∏–∫ –≤–æ –≤—Ä–µ–º—è –∞–Ω–∏–º–∞—Ü–∏–∏ (–∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º)");
                            return; 
                        } else {
                            // –ê –≤–æ—Ç –µ—Å–ª–∏ –∞–Ω–∏–º–∞—Ü–∏–∏ –Ω–µ—Ç, –∞ —Ö–æ–¥ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω ‚Äî —Ç–æ–≥–¥–∞ —á–∏–Ω–∏–º
                            console.warn("–û–ë–ù–ê–†–£–ñ–ï–ù SOFT LOCK! –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ö–æ–¥ –∏–≥—Ä–æ–∫—É.");
                            isPlayerTurn = true;
                            updatePassButtonState();
                            // showGameNotification("–•–æ–¥ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω!", 'info'); // –°–∫—Ä—ã–≤–∞–µ–º, —á—Ç–æ–±—ã –Ω–µ –ø—É–≥–∞—Ç—å
                        }
                    } else {
                        return; // –ù–æ—Ä–º–∞–ª—å–Ω—ã–π —Ö–æ–¥ —Å–æ–ø–µ—Ä–Ω–∏–∫–∞, –≤—ã—Ö–æ–¥–∏–º
                    }
                }
                
                console.log('–ò–≥—Ä–æ–∫ –ø–æ—Ö–æ–¥–∏–ª –∫–∞—Ä—Ç–æ–π:', cardData.name);
                
                // 2. –°–±—Ä–æ—Å —Ñ–ª–∞–≥–∞ —É–ø—É—â–µ–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ö–∞—Ä—Å–µ–¥–æ
                // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç —Ö–æ–¥, –æ–Ω —Ç–µ—Ä—è–µ—Ç –ø—Ä–∞–≤–æ –Ω–∞ –∫–æ–Ω—Ç—Ä—É–¥–∞—Ä
                if (typeof lastKloppVictims !== 'undefined' && lastKloppVictims.length > 0) {
                    lastKloppVictims = [];
                    if (typeof kloppOpportunityMissed !== 'undefined') {
                        kloppOpportunityMissed = true;
                    }
                }
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ç—Ä–µ–Ω–µ—Ä–∞
                playerJustUsedCoach = false;
                
                // –û—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
                clearAllHighlights();
                
                // 2.5. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ Dummy (Decoy)
                if (cardData.ability === 'dummy') {
                    // –ï—Å–ª–∏ —É–∂–µ –≤ —Ä–µ–∂–∏–º–µ –≤—ã–±–æ—Ä–∞ –∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ —Ç—É –∂–µ –∫–∞—Ä—Ç—É - –æ—Ç–º–µ–Ω—è–µ–º
                    if (isDummyTargeting && selectedDummyCard && selectedDummyCard.cardData.id === cardData.id) {
                        cancelDummyTargeting();
                        return;
                    }
                    // –û—Ç–º–µ–Ω—è–µ–º —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞, –µ—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ –¥—Ä—É–≥—É—é –∫–∞—Ä—Ç—É
                    if (isDummyTargeting) {
                        cancelDummyTargeting();
                    }
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–ª–µ–π –Ω–∞ –ø–æ–ª–µ –∏–≥—Ä–æ–∫–∞ (–Ω–µ-–≥–µ—Ä–æ–∏)
                    const validTargets = playerCardsOnField.filter(entry => {
                        const cardData = entry.cardData;
                        return !(cardData.isHero === true || cardData.cardtype === 'hero');
                    });
                    
                    if (validTargets.length > 0) {
                        // –í—Ö–æ–¥–∏–º –≤ —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏
                        isDummyTargeting = true;
                        selectedDummyCard = { cardElement, cardData };
                        
                        // BRUTE FORCE: –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –≤—Å–µ –≤–∞–ª–∏–¥–Ω—ã–µ —Ü–µ–ª–∏ –∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –¥–µ–ª–∞–µ–º –∏—Ö –∫–ª–∏–∫–∞–±–µ–ª—å–Ω—ã–º–∏
                        validTargets.forEach(entry => {
                            const cardId = entry.cardData.id;
                            // –ò—â–µ–º —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–∏ –∑–æ–Ω—ã –∏–≥—Ä–æ–∫–∞, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤ –≤ –∑–µ—Ä–∫–∞–ª—å–Ω—ã—Ö –º–∞—Ç—á–∞—Ö
                            const fieldCard = document.querySelector(`.player-zone .card-on-field[data-card-id="${cardId}"]`);
                            if (fieldCard) {
                                // Add visual highlight
                                fieldCard.classList.add('valid-target');
                                
                                // BRUTE FORCE: Force inline styles to ensure clickability
                                fieldCard.style.pointerEvents = 'all';
                                fieldCard.style.zIndex = '9999';
                                fieldCard.style.cursor = 'pointer';
                                
                                // BRUTE FORCE: Force assign click handler directly
                                fieldCard.onclick = function(e) {
                                    e.stopImmediatePropagation(); // –ö—Ä–∏—Ç–∏—á–Ω–æ: –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –¥–≤–æ–π–Ω–æ–π –≤—ã–∑–æ–≤
                                    e.stopPropagation();
                                    e.preventDefault();
                                    // Call the swap logic directly
                                    executeDummySwap(this, entry.cardData, entry.rowId);
                                };
                            }
                        });
                        
                        console.log('Dummy: –í–∫–ª—é—á–µ–Ω —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ —Ü–µ–ª–∏. –í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ –¥–ª—è –æ–±–º–µ–Ω–∞.');
                        showGameNotification('–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ä—Ç—É –Ω–∞ –ø–æ–ª–µ –¥–ª—è –æ–±–º–µ–Ω–∞', 'info');
                        return;
                    } else {
                        // FIX: If no targets to swap, allow playing Dummy as a unit immediately.
                        console.log('Dummy: –ù–µ—Ç –≤–∞–ª–∏–¥–Ω—ã—Ö —Ü–µ–ª–µ–π. –í–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º —Ä–∞–∑–º–µ—â–µ–Ω–∏—è —é–Ω–∏—Ç–∞.');
                        showGameNotification('–ù–µ—Ç —Ü–µ–ª–µ–π –¥–ª—è –æ–±–º–µ–Ω–∞. –í—ã–±–µ—Ä–∏—Ç–µ —Ä—è–¥.', 'info');
                        
                        // Enter Row Selection Mode
                        selectedCardForRow = { cardElement, cardData };
                        highlightRows(); // Highlight Attack/Mid/Def
                        return; // Stop execution here and wait for row click
                    }
                }
                
                // 2.6. –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ Medic
                if (cardData.ability === 'medic') {
                    // First, place the Medic card on the board
                    // Determine target row
                    let medicRowId = cardData.position;
                    if (!medicRowId || medicRowId === 'any') {
                        medicRowId = 'attack'; // Default to attack row
                    }
                    
                    let medicTargetRow = getTargetRow(medicRowId);
                    if (!medicTargetRow) {
                        medicRowId = 'attack';
                        medicTargetRow = attackRow;
                    }
                    
                    // Block player turn and place medic
                    isPlayerTurn = false;
                    movesCount++;
                    
                    // Set medic resurrection flag to prevent turn switching
                    isMedicResurrecting = true;
                    
                    // Place medic card (the graveyard check will happen in placeCardInRow)
                    placeCardInRow(cardElement, cardData, medicTargetRow, medicRowId);
                    
                    return;
                }
                
                // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –≤—ã–±–æ—Ä —Ä—è–¥–∞ (Support / Any)
                const canChooseRow = cardData.position === 'any' || cardData.ability === 'support';
                
                if (canChooseRow) {
                    selectedCardForRow = { cardElement, cardData };
                    if (cardData.ability === 'support') {
                        highlightTacticsSlots();
                    } else {
                        highlightRows();
                    }
                    return; 
                }
                
                // 4. –ë–ª–æ–∫–∏—Ä—É–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ –¥–µ–ª–∞–µ–º —Ö–æ–¥
                isPlayerTurn = false;
                movesCount++;
                
                const targetRow = getTargetRow(cardData.position);
                const rowId = cardData.position === 'special' ? 'special' : cardData.position;
                
                placeCardInRow(cardElement, cardData, targetRow, rowId);

            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –≤ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ –∫–ª–∏–∫–∞:', error);
                // –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤—Å–µ–≥–¥–∞ —Ä–∞–∑–±–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥
                isPlayerTurn = true;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤ –Ω–∞ —Ä—è–¥—ã (–¥–ª—è –∫–∞—Ä—Ç —Å –≤—ã–±–æ—Ä–æ–º —Ä—è–¥–∞)
        function handleRowClick(rowElement, rowId) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –ª–∏ –∏–≥—Ä–æ–∫ —Ö–æ–¥–∏—Ç—å
            if (!isPlayerTurn || playerPassed) {
                console.log('–•–æ–¥ –∏–≥—Ä–æ–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            // –û—Ç–º–µ–Ω—è–µ–º —Ä–µ–∂–∏–º –≤—ã–±–æ—Ä–∞ Dummy, –µ—Å–ª–∏ –∫–ª–∏–∫–Ω—É–ª–∏ –Ω–∞ —Ä—è–¥
            if (isDummyTargeting) {
                // –ï—Å–ª–∏ —ç—Ç–æ Dummy –∫–∞—Ä—Ç–∞, —Ä–∞–∑–º–µ—â–∞–µ–º –µ—ë –∫–∞–∫ –æ–±—ã—á–Ω—É—é –∫–∞—Ä—Ç—É
                if (selectedDummyCard && selectedDummyCard.cardData.ability === 'dummy') {
                    const { cardElement, cardData } = selectedDummyCard;
                    cancelDummyTargeting();
                    
                    // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥ –∏ —Ä–∞–∑–º–µ—â–∞–µ–º –∫–∞—Ä—Ç—É
                    isPlayerTurn = false;
                    movesCount++;
                    placeCardInRow(cardElement, cardData, rowElement, rowId);
                    return;
                } else {
                    cancelDummyTargeting();
                    return;
                }
            }
            
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç —Ö–æ–¥ –∫–∞—Ä—Ç–æ–π, –æ–Ω —É–ø—É—Å–∫–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∏—Ç—å –ö–∞—Ä—Å–µ–¥–æ
            if (lastKloppVictims.length > 0) {
                lastKloppVictims = []; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –∂–µ—Ä—Ç–≤
                kloppOpportunityMissed = true; // –°—Ç–∞–≤–∏–º —Ñ–ª–∞–≥ —É–ø—É—â–µ–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                console.log("–ò–≥—Ä–æ–∫ —É–ø—É—Å—Ç–∏–ª –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ö–∞—Ä—Å–µ–¥–æ!");
            }
            lastCelestiniBuffs = [];
            
            if (!selectedCardForRow) {
                return; // –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã
            }
            
            // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥—ã –∏–≥—Ä–æ–∫–∞
            isPlayerTurn = false;
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
            movesCount++;
            
            // –°–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
            clearAllHighlights();
            
            // –†–∞–∑–º–µ—â–∞–µ–º –∫–∞—Ä—Ç—É –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–º —Ä—è–¥—É
            const { cardElement, cardData } = selectedCardForRow;
            selectedCardForRow = null; // –û—á–∏—â–∞–µ–º –≤—ã–±–æ—Ä
            
            placeCardInRow(cardElement, cardData, rowElement, rowId);
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –Ω–∞ —Å–ª–æ—Ç —Ç–∞–∫—Ç–∏–∫–∏ (–¥–ª—è –∫–∞—Ä—Ç support)
        function handleTacticsSlotClick(tacticsSlot, rowId) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –ª–∏ –∏–≥—Ä–æ–∫ —Ö–æ–¥–∏—Ç—å
            if (!isPlayerTurn || playerPassed) {
                console.log('–•–æ–¥ –∏–≥—Ä–æ–∫–∞ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω');
                return;
            }
            
            // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –¥–µ–ª–∞–µ—Ç —Ö–æ–¥ –∫–∞—Ä—Ç–æ–π, –æ–Ω —É–ø—É—Å–∫–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–≤–µ—Ç–∏—Ç—å –ö–∞—Ä—Å–µ–¥–æ
            if (lastKloppVictims.length > 0) {
                lastKloppVictims = []; // –û—á–∏—â–∞–µ–º —Å–ø–∏—Å–æ–∫ –∂–µ—Ä—Ç–≤
                kloppOpportunityMissed = true; // –°—Ç–∞–≤–∏–º —Ñ–ª–∞–≥ —É–ø—É—â–µ–Ω–Ω–æ–π –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏
                console.log("–ò–≥—Ä–æ–∫ —É–ø—É—Å—Ç–∏–ª –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ö–∞—Ä—Å–µ–¥–æ!");
            }
            lastCelestiniBuffs = [];
            
            if (!selectedCardForRow) {
                return; // –ù–µ—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–∞—Ä—Ç—ã
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—ã–±—Ä–∞–Ω–∞ –∫–∞—Ä—Ç–∞ support
            const { cardElement, cardData } = selectedCardForRow;
            if (cardData.ability !== 'support') {
                return; // –ù–µ –∫–∞—Ä—Ç–∞ support
            }
            
            // –ë–ª–æ–∫–∏—Ä—É–µ–º —Ö–æ–¥—ã –∏–≥—Ä–æ–∫–∞
            isPlayerTurn = false;
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ —Ö–æ–¥–æ–≤
            movesCount++;
            
            // –°–Ω–∏–º–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É
            clearAllHighlights();
            
            // –ü–æ–ª—É—á–∞–µ–º —Ü–µ–ª–µ–≤–æ–π —Ä—è–¥ –¥–ª—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –∫–∞—Ä—Ç—ã
            const targetRow = getTargetRow(rowId);
            selectedCardForRow = null; // –û—á–∏—â–∞–µ–º –≤—ã–±–æ—Ä
            
            // –†–∞–∑–º–µ—â–∞–µ–º –∫–∞—Ä—Ç—É –≤ —Å–ª–æ—Ç–µ —Ç–∞–∫—Ç–∏–∫–∏
            placeCardInRow(cardElement, cardData, targetRow, rowId);
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤ –Ω–∞ —Ä—è–¥—ã
        attackRow.addEventListener('click', function(e) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–∏–∫ –Ω–µ –ø–æ –∫–∞—Ä—Ç–µ –Ω–∞ –ø–æ–ª–µ
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleRowClick(attackRow, 'attack');
        });
        
        midfieldRow.addEventListener('click', function(e) {
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleRowClick(midfieldRow, 'midfield');
        });
        
        defenseRow.addEventListener('click', function(e) {
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleRowClick(defenseRow, 'defense');
        });
        
        // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–ª–∏–∫–æ–≤ –Ω–∞ —Å–ª–æ—Ç—ã —Ç–∞–∫—Ç–∏–∫–∏ (–¥–ª—è –∫–∞—Ä—Ç support)
        attackTacticsSlot.addEventListener('click', function(e) {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–∏–∫ –Ω–µ –ø–æ –∫–∞—Ä—Ç–µ –≤ —Å–ª–æ—Ç–µ
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleTacticsSlotClick(attackTacticsSlot, 'attack');
        });
        
        midfieldTacticsSlot.addEventListener('click', function(e) {
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleTacticsSlotClick(midfieldTacticsSlot, 'midfield');
        });
        
        defenseTacticsSlot.addEventListener('click', function(e) {
            if (e.target.closest('.card-on-field')) {
                return;
            }
            handleTacticsSlotClick(defenseTacticsSlot, 'defense');
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –≤ –ø—É—Å—Ç–æ–µ –º–µ—Å—Ç–æ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        cardsContainer.addEventListener('click', function(e) {
            // –ï—Å–ª–∏ –∫–ª–∏–∫ –Ω–µ –ø–æ –∫–∞—Ä—Ç–µ (–Ω–µ –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É —Å –∫–ª–∞—Å—Å–æ–º 'card' –∏–ª–∏ –µ–≥–æ –¥–æ—á–µ—Ä–Ω–∏–º —ç–ª–µ–º–µ–Ω—Ç–∞–º), –æ—á–∏—â–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –∏ –≤—ã–±–æ—Ä
            if (!e.target.closest('.card')) {
                clearAllHighlights();
                selectedCardForRow = null;
            }
        });
        
        // ============================================
        // GRAVEYARD VIEW OVERLAY
        // ============================================
        
        // Helper: Simulate score if a card is resurrected
        function simulatePlayerScore(cardToAdd) {
            // 1. If it's a Spy, it goes to Enemy field, so Player Score doesn't change.
            if (cardToAdd.ability === 'spy') return totalScore;

            // 2. Clone current field state to not affect real game
            // We need a lightweight simulation of calculatePlayerScore logic
            let tempScore = 0;
            const rows = ['attack', 'midfield', 'defense'];
            
            // Determine where the new card goes
            let targetRowId = cardToAdd.position;
            if (!targetRowId || targetRowId === 'any') targetRowId = 'attack';

            // Create a temporary list including the new card
            const tempField = [...playerCardsOnField, { cardData: cardToAdd, rowId: targetRowId }];

            rows.forEach(rowId => {
                const cardsInRow = tempField.filter(c => c.rowId === rowId);
                
                // Check buffs in this simulated row
                const hasCaptain = cardsInRow.some(c => c.cardData.ability === 'captain');
                // Check existing tactics (global variable is fine to read)
                const hasSupport = playerTacticsCards.some(c => c.rowId === rowId && c.cardData.ability === 'support');
                const hasLeader = cardsInRow.some(c => c.cardData.ability === 'leader');

                cardsInRow.forEach(entry => {
                    const card = entry.cardData;
                    let currentPower = card.power || 0;
                    
                    // Hero Logic
                    if (card.isHero || card.cardtype === 'hero') {
                        tempScore += currentPower;
                        return;
                    }

                    // Leader Logic
                    if (hasLeader && card.ability !== 'leader') currentPower += 1;

                    let multiplier = 1;

                    // Bond Logic (Count in temp array)
                    if (card.ability === 'bond') {
                        const bondCount = cardsInRow.filter(c => c.cardData.ability === 'bond').length;
                        if (bondCount >= 2) multiplier *= 2;
                    }

                    // Buff Logic
                    let buffActive = false;
                    if (hasCaptain && card.ability !== 'captain') buffActive = true;
                    if (hasSupport) buffActive = true;
                    if (buffActive) multiplier *= 2;

                    tempScore += (currentPower * multiplier);
                });
            });

            return tempScore;
        }
        
        function openGraveyardView(owner, mode = 'view') {
            const overlay = document.getElementById('graveyard-view-overlay');
            const grid = document.getElementById('graveyard-grid');
            const statusText = document.getElementById('graveyard-status-text');
            
            if (!overlay || !grid) return;
            
            // Determine which graveyard to show
            const isPlayer = owner === 'player';
            const graveyardCards = isPlayer ? playerGraveyardCards : enemyGraveyardCards;
            const teamKey = isPlayer ? playerTeamKey : enemyTeamKey;
            
            // Check if graveyard is empty
            if (!graveyardCards || graveyardCards.length === 0) {
                return; // Don't open if empty
            }
            
            // Handle select/medic mode
            const backButton = document.getElementById('btn-graveyard-back');
            const medicActionButton = document.getElementById('btn-medic-action');
            
            if (mode === 'select' || mode === 'medic') {
                // Add select mode class to grid
                grid.classList.add('graveyard-select-mode');
                
                // Show status text
                if (statusText) {
                    statusText.textContent = '–í–´–ë–ï–†–ò–¢–ï –ö–ê–†–¢–£ –ò–ó –û–¢–ë–û–Ø';
                    statusText.style.display = 'block';
                } else {
                    // Create status text if it doesn't exist
                    const newStatusText = document.createElement('div');
                    newStatusText.id = 'graveyard-status-text';
                    newStatusText.textContent = '–í–´–ë–ï–†–ò–¢–ï –ö–ê–†–¢–£ –ò–ó –û–¢–ë–û–Ø';
                    const modalContent = overlay.querySelector('.graveyard-modal-content');
                    if (modalContent) {
                        modalContent.insertBefore(newStatusText, grid);
                    }
                }
                
                // Handle medic mode specifically
                if (mode === 'medic') {
                    // Hide back button, show medic action button
                    if (backButton) {
                        backButton.style.display = 'none';
                    }
                    if (medicActionButton) {
                        medicActionButton.style.display = 'block';
                        // Reset state
                        medicActionButton.textContent = '–í—ã–±–æ—Ä –Ω–µ —Å–¥–µ–ª–∞–Ω';
                        medicActionButton.classList.remove('medic-state-active');
                        medicActionButton.classList.add('medic-state-disabled');
                    }
                    // Reset selection data
                    medicSelectionData = null;
                    
                    // Show score predictor UI
                    const scorePreview = document.getElementById('medic-score-preview');
                    if (scorePreview) {
                        scorePreview.style.display = 'flex';
                        
                        // FIX: Initialize BOTH scores to current totalScore
                        const currentScoreEl = document.getElementById('preview-current-score');
                        const futureEl = document.getElementById('preview-future-score');
                        
                        if (currentScoreEl) {
                            currentScoreEl.textContent = totalScore;
                        }
                        if (futureEl) {
                            futureEl.textContent = totalScore; // Default to current
                            futureEl.style.color = '#ffffff';  // Default color (white)
                        }
                    }
                } else {
                    // Select mode (old behavior)
                    if (backButton) {
                        backButton.textContent = 'CANCEL';
                        backButton.style.display = 'block';
                    }
                    if (medicActionButton) {
                        medicActionButton.style.display = 'none';
                    }
                }
            } else {
                // View mode
                // Remove select mode class
                grid.classList.remove('graveyard-select-mode');
                
                // Show back button, hide medic action button
                if (backButton) {
                    backButton.textContent = '–ù–ê–ó–ê–î';
                    backButton.style.display = 'block';
                }
                if (medicActionButton) {
                    medicActionButton.style.display = 'none';
                }
                
                // Hide status text
                if (statusText) {
                    statusText.style.display = 'none';
                }
                
                // Hide score predictor UI
                const scorePreview = document.getElementById('medic-score-preview');
                if (scorePreview) {
                    scorePreview.style.display = 'none';
                }
            }
            
            // Get graveyard cover image from teamAssets
            const assets = teamAssets[teamKey] || {};
            const coverImage = assets.graveyard || 'assets/spartak_graveyard.jpg';
            
            // Create a shallow copy of the graveyard cards array to avoid mutating game state
            const cardsToShow = [...graveyardCards];
            
            // Sort cards for display: Heroes first, then Special cards (with abilities), then Base cards
            // Within each category, sort by Power (Descending - strongest first)
            cardsToShow.sort((a, b) => {
                // Helper function to assign Tiers
                const getTier = (card) => {
                    if (card.isHero || card.cardtype === 'hero') return 3; // Top Priority
                    if (card.ability && card.ability !== 'none') return 2; // Medium Priority
                    return 1; // Low Priority
                };

                const tierA = getTier(a);
                const tierB = getTier(b);

                // 1. Compare Tiers (Group by Category)
                if (tierA !== tierB) {
                    return tierB - tierA; // Higher tier comes first
                }

                // 2. If Tiers are equal, Sort by Power (Descending)
                // This ensures Promes (12) comes before Barco (7)
                return (b.power || 0) - (a.power || 0);
            });
            
            // Clear grid
            grid.innerHTML = '';
            
            // 1. Append Cover Card (first item)
            const coverCard = document.createElement('div');
            coverCard.className = 'graveyard-cover-card';
            const coverImg = document.createElement('img');
            coverImg.src = coverImage;
            coverImg.alt = 'Graveyard Cover';
            // Prevent dragging on cover image
            coverCard.addEventListener('dragstart', (e) => e.preventDefault());
            coverImg.addEventListener('dragstart', (e) => e.preventDefault());
            coverCard.appendChild(coverImg);
            grid.appendChild(coverCard);
            
            // 2. Append Actual Cards (sorted)
            cardsToShow.forEach((cardData, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'collection-card';
                
                // Add hero class if applicable
                if (cardData.isHero || cardData.cardtype === 'hero') {
                    cardElement.classList.add('hero');
                }
                
                // In select/medic mode, check if card is revivable
                if ((mode === 'select' || mode === 'medic') && isPlayer) {
                    const isCardRevivable = isRevivable(cardData);
                    if (!isCardRevivable) {
                        cardElement.classList.add('card-disabled');
                    } else {
                        // Add click handler for revivable cards
                        cardElement.addEventListener('click', function() {
                            if (mode === 'medic') {
                                // 1. Highlight UI
                                const allCards = grid.querySelectorAll('.collection-card');
                                allCards.forEach(card => card.classList.remove('selected-card-highlight'));
                                cardElement.classList.add('selected-card-highlight');
                                
                                // 2. Update Data
                                const originalIndex = playerGraveyardCards.findIndex(card => card.id === cardData.id);
                                if (originalIndex !== -1) {
                                    medicSelectionData = { card: cardData, index: originalIndex };
                                    
                                    // 3. UPDATE CALCULATOR
                                    const predicted = simulatePlayerScore(cardData);
                                    const futureEl = document.getElementById('preview-future-score');
                                    if (futureEl) {
                                        futureEl.textContent = predicted;
                                        // Add color: Green if better, White if same
                                        futureEl.style.color = predicted > totalScore ? '#00ff00' : '#ffffff';
                                    }

                                    // 4. Update Button
                                    const medicActionButton = document.getElementById('btn-medic-action');
                                    if (medicActionButton) {
                                        medicActionButton.textContent = '–ü–û–î–¢–í–ï–†–î–ò–¢–¨'; // Confirm
                                        medicActionButton.classList.remove('medic-state-disabled');
                                        medicActionButton.classList.add('medic-state-active');
                                    }
                                }
                            } else {
                                // Select mode (old behavior - immediate resurrection)
                                const originalIndex = playerGraveyardCards.findIndex(card => card.id === cardData.id);
                                if (originalIndex !== -1) {
                                    resurrectCard(cardData, originalIndex);
                                }
                            }
                        });
                    }
                }
                
                const cardImg = document.createElement('img');
                cardImg.src = cardData.img || cardData.miniImg || '';
                cardImg.alt = cardData.name || `–ö–∞—Ä—Ç–∞ ${cardData.id}`;
                
                // Prevent dragging on card container and image
                cardElement.addEventListener('dragstart', (e) => e.preventDefault());
                cardImg.addEventListener('dragstart', (e) => e.preventDefault());
                
                cardElement.appendChild(cardImg);
                
                // Add card power badge if exists
                if (cardData.power !== undefined) {
                    const powerBadge = document.createElement('div');
                    powerBadge.className = 'card-power';
                    powerBadge.textContent = cardData.power;
                    cardElement.appendChild(powerBadge);
                }
                
                // Add inspection events (zoom on long press) - only in view mode
                if (mode === 'view') {
                    const fullImagePath = cardData.img || cardData.miniImg || '';
                    if (fullImagePath) {
                        addInspectionEvents(cardElement, fullImagePath);
                    }
                }
                
                grid.appendChild(cardElement);
            });
            
            // Grid will automatically handle scrolling via CSS flexbox
            // No need to manually set overflow-y - CSS handles it based on content vs max-height
            
            // Bind the Action Button (for medic mode)
            if (mode === 'medic') {
                const medicActionButton = document.getElementById('btn-medic-action');
                if (medicActionButton) {
                    medicActionButton.onclick = function(e) {
                        e.stopPropagation();
                        if (medicSelectionData) {
                            // Call the animation function
                            resurrectCard(medicSelectionData.card, medicSelectionData.index);
                        }
                    };
                }
            }
            
            // Show overlay
            overlay.classList.add('show');
        }
        
        // Make sure this function is available globally
        window.closeGraveyardView = function() {
            const overlay = document.getElementById('graveyard-view-overlay');
            const grid = document.getElementById('graveyard-grid');
            const statusText = document.getElementById('graveyard-status-text');
            const backButton = document.getElementById('btn-graveyard-back');
            const medicActionButton = document.getElementById('btn-medic-action');
            
            if (overlay) {
                overlay.classList.remove('show');
                
                // Reset select mode
                if (grid) {
                    grid.classList.remove('graveyard-select-mode');
                    // Remove any selected card highlights
                    const highlightedCards = grid.querySelectorAll('.selected-card-highlight');
                    highlightedCards.forEach(card => {
                        card.classList.remove('selected-card-highlight');
                    });
                }
                
                // Reset back button
                if (backButton) {
                    backButton.textContent = '–ù–ê–ó–ê–î';
                    backButton.style.display = 'block';
                }
                
                // Reset medic action button
                if (medicActionButton) {
                    medicActionButton.style.display = 'none';
                    medicActionButton.textContent = '–í—ã–±–æ—Ä –Ω–µ —Å–¥–µ–ª–∞–Ω';
                    medicActionButton.classList.remove('medic-state-active');
                    medicActionButton.classList.add('medic-state-disabled');
                }
                
                // Hide status text
                if (statusText) {
                    statusText.style.display = 'none';
                }
                
                // Reset selection data
                medicSelectionData = null;
                
                // If we were in medic resurrection mode and user closed without selecting, clear the flag
                // and allow turn switching to proceed (acts as "Cancel Resurrection")
                if (isMedicResurrecting) {
                    isMedicResurrecting = false;
                    // Trigger turn switching if needed
                    checkRoundEndCondition();
                }
                
                // Optional: Clear grid to save memory
                // document.getElementById('graveyard-grid').innerHTML = ''; 
            }
        };
        
        // Keep local reference for backward compatibility
        function closeGraveyardView() {
            window.closeGraveyardView();
        }
        
        // Function to resurrect a card from graveyard with flying animation and Ability Triggers
        // Function to resurrect a card from graveyard with flying animation
        function resurrectCard(cardData, indexInGraveyard) {
            try {
                console.log("Resurrecting:", cardData.name);

                // 1. Identify Target & Side
                const isSpy = cardData.ability === 'spy';
                let rowId = cardData.position;
                if (!rowId || rowId === 'any') rowId = 'attack';

                // SPY LOGIC: Spies go to ENEMY field
                let targetRow, targetArray;
                if (isSpy) {
                    targetRow = getEnemyTargetRow(rowId);
                    targetArray = enemyCardsOnField;
                    if (!targetRow) { rowId = 'attack'; targetRow = enemyAttackRow; }
                } else {
                    targetRow = getTargetRow(rowId);
                    targetArray = playerCardsOnField;
                    if (!targetRow) { rowId = 'attack'; targetRow = attackRow; }
                }

                // Remove from graveyard
                if (indexInGraveyard >= 0 && indexInGraveyard < playerGraveyardCards.length) {
                    playerGraveyardCards.splice(indexInGraveyard, 1);
                }
                updateGraveyardVisuals();

                // 2. Visual Setup
                const overlay = document.getElementById('graveyard-view-overlay');
                if (overlay) overlay.classList.add('overlay-fade-out');

                // Create Field Element (Hidden)
                const finalCardElem = document.createElement('div');
                finalCardElem.className = 'card-on-field';
                if (cardData.isHero || cardData.cardtype === 'hero') finalCardElem.classList.add('hero');

                const cardImg = document.createElement('img');
                const imageSrc = (cardData.miniImg && cardData.miniImg !== "") ? cardData.miniImg : cardData.img;
                cardImg.src = imageSrc;
                finalCardElem.appendChild(cardImg);

                finalCardElem.addEventListener('dragstart', (e) => e.preventDefault());
                cardImg.addEventListener('dragstart', (e) => e.preventDefault());
                finalCardElem.setAttribute('data-full-img', cardData.img);
                finalCardElem.setAttribute('data-card-id', cardData.id);
                addInspectionEvents(finalCardElem, cardData.img);
                attachDummyClickListener(finalCardElem, cardData);
                addFieldPowerBadge(finalCardElem, cardData);
                
                // Add to Logic & DOM
                targetArray.push({ cardData, rowId });
                insertCardSmartly(targetRow, finalCardElem);
                finalCardElem.style.opacity = '0';
                updateRowLayout(targetRow);

                // 3. Animation Start (From Graveyard)
                let startX = window.innerWidth / 2;
                let startY = window.innerHeight / 2;
                const graveEl = document.getElementById('playerGraveyard');
                if (graveEl) {
                    const r = graveEl.getBoundingClientRect();
                    startX = r.left + r.width/2;
                    startY = r.top + r.height/2;
                }
                
                const endRect = finalCardElem.getBoundingClientRect();
                
                let flyingW = (window.innerWidth <= 480) ? 63 : 90;
                let flyingH = (window.innerWidth <= 480) ? 88 : 126;
                let scaleTarget = (finalCardElem.offsetWidth / flyingW);

                const clone = finalCardElem.cloneNode(true);
                clone.className = 'card flying-resurrection-card';
                clone.style.opacity = '1';
                clone.style.width = flyingW + 'px';
                clone.style.height = flyingH + 'px';
                clone.style.position = 'fixed';
                clone.style.left = (startX - flyingW/2) + 'px';
                clone.style.top = (startY - flyingH/2) + 'px';
                clone.style.zIndex = '99999';
                clone.style.transition = 'all 0.8s cubic-bezier(0.25, 0.8, 0.25, 1)'; // Smooth landing
                document.body.appendChild(clone);

                // Trigger Flight
                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        const destX = endRect.left + endRect.width/2;
                        const destY = endRect.top + endRect.height/2;
                        
                        clone.style.left = (destX - flyingW/2) + 'px';
                        clone.style.top = (destY - flyingH/2) + 'px';
                        clone.style.transform = `scale(${scaleTarget})`;
                    });
                });

                // 4. ON LANDING (Sequence Logic)
                clone.addEventListener('transitionend', function onEnd(e) {
                    if (e.propertyName !== 'top' && e.propertyName !== 'left') return; // Wait for position
                    clone.removeEventListener('transitionend', onEnd);
                    clone.remove();
                    
                    finalCardElem.style.opacity = '1';
                    
                    if (overlay) {
                        overlay.classList.remove('show');
                        overlay.classList.remove('overlay-fade-out');
                    }

                    updatePlayerScore();
                    updateEnemyScore();

                    // --- SEQUENTIAL SPY TRIGGER ---
                    if (isSpy) {
                        showGameNotification("–®–ø–∏–æ–Ω –Ω–∞ –ø–æ–ª–µ! –î–æ–±–æ—Ä –∫–∞—Ä—Ç...", "success");
                        isSpyDrawing = true; 

                        // STEP 2: PAUSE (Let user see the Spy land)
                        setTimeout(() => {
                            // STEP 3: DRAW
                            const newCards = drawCardsFromPlayerDeck(2);
                            
                            if (newCards.length > 0) {
                                myCards.push(...newCards);
                                // Don't render hand yet, wait for animation
                                
                                // STEP 4: ANIMATE CARDS FROM DECK
                                if (playerDeck) {
                                    animateCardsFromDeck(newCards, playerDeck, () => {
                                        // STEP 5: FINISH (Callback)
                                        updatePlayerDeckCounter();
                                        renderPlayerHand();
                                        updateHandLayout();
                                        isSpyDrawing = false;
                                        resumeGameFlow(); // CONTINUE GAME
                                    });
                                } else {
                                    // Fallback
                                    updatePlayerDeckCounter();
                                    renderPlayerHand();
                                    isSpyDrawing = false;
                                    resumeGameFlow();
                                }
                            } else {
                                // No cards to draw
                                showGameNotification("–ö–æ–ª–æ–¥–∞ –ø—É—Å—Ç–∞!", "warning");
                                isSpyDrawing = false;
                                resumeGameFlow();
                            }
                        }, 800); // 800ms Delay
                        
                        return; // Stop here, async logic handles the rest
                    }

                    // Normal Resurrection
                    resumeGameFlow();
                });

            } catch (error) {
                console.error('Resurrect Error:', error);
                isPlayerTurn = true;
                isMedicResurrecting = false;
                if (document.getElementById('graveyard-view-overlay')) {
                    document.getElementById('graveyard-view-overlay').classList.remove('show');
                }
            }
        }

        // Helper to resume game flow (Turn switching)
        function resumeGameFlow() {
            checkRoundEndCondition();

            const isCoachAvailable = currentPlayerCoach && currentPlayerCoach.isUsed === false;
            const playerIsDone = playerPassed || (myCards.length === 0 && !isCoachAvailable);
            
            const enemyHasCards = enemyCards.filter(c => !c.used).length > 0;
            const enemyCoachActive = currentEnemyCoach && currentEnemyCoach.isUsed === false;
            const enemyIsDone = enemyPassed || (!enemyHasCards && !enemyCoachActive);

            if (playerIsDone && enemyIsDone) {
                setTimeout(() => { endRound(); }, 500);
            } else if (enemyPassed) {
                isPlayerTurn = true;
                updatePassButtonState();
            } else {
                // Force Enemy Turn
                setTimeout(() => { 
                    try { enemyTurn(); } 
                    catch (e) { console.error(e); isPlayerTurn = true; } 
                }, 1000);
            }
        }
        
        // Function to update graveyard cursor based on content
        function updateGraveyardCursors() {
            const playerGraveyardEl = document.getElementById('playerGraveyard');
            const enemyGraveyardEl = document.getElementById('enemyGraveyard');
            
            if (playerGraveyardEl) {
                playerGraveyardEl.style.cursor = (playerGraveyardCards && playerGraveyardCards.length > 0) ? 'pointer' : 'default';
            }
            
            if (enemyGraveyardEl) {
                enemyGraveyardEl.style.cursor = (enemyGraveyardCards && enemyGraveyardCards.length > 0) ? 'pointer' : 'default';
            }
        }
        
        // Add click event listeners to graveyard slots
        const playerGraveyardEl = document.getElementById('playerGraveyard');
        const enemyGraveyardEl = document.getElementById('enemyGraveyard');
        
        if (playerGraveyardEl) {
            playerGraveyardEl.addEventListener('click', function() {
                openGraveyardView('player');
            });
        }
        
        if (enemyGraveyardEl) {
            enemyGraveyardEl.addEventListener('click', function() {
                openGraveyardView('enemy');
            });
        }
        
        // Initialize cursor states
        updateGraveyardCursors();
        
        // Button now uses inline onclick - no event listeners needed
        // Also allow closing by clicking the dark background (outside content)
        const graveyardOverlay = document.getElementById('graveyard-view-overlay');
        if (graveyardOverlay) {
            graveyardOverlay.onclick = function(e) {
                if (e.target === this) {
                    this.classList.remove('show');
                }
            };
        }
        
        
    </script>
    
    <!-- Graveyard View Overlay -->
    <div id="graveyard-view-overlay" class="game-overlay">
        <div class="graveyard-modal-content">
            <div id="graveyard-status-text" style="display: none;"></div>
            <div id="medic-score-preview" style="display: none;">
                <div class="score-box current">
                    <span class="label">–¢–ï–ö–£–©–ò–ô</span>
                    <span class="value" id="preview-current-score">0</span>
                </div>
                <div class="score-arrow">‚ûú</div>
                <div class="score-box future">
                    <span class="label">–ü–û–¢–ï–ù–¶–ò–ê–õ</span>
                    <span class="value" id="preview-future-score">0</span>
                </div>
            </div>
            <div id="graveyard-grid"></div>
        </div>
        
        <button id="btn-graveyard-back" onclick="closeGraveyardView()">–ù–ê–ó–ê–î</button>
        <button id="btn-medic-action" class="menu-button medic-state-disabled" style="display: none;">–í—ã–±–æ—Ä –Ω–µ —Å–¥–µ–ª–∞–Ω</button>
    </div>
    
    <!-- –ú–æ–¥–∞–ª—å–Ω–æ–µ –æ–∫–Ω–æ –≤—ã–±–æ—Ä–∞ –ø–µ—Ä–≤–æ–≥–æ —Ö–æ–¥–∞ –¥–ª—è –†–ü–õ (–ê–¥–º–∏–Ω—Ä–µ—Å—É—Ä—Å) -->
    <div id="rpl-choice-overlay" class="game-overlay" style="display: none;">
        <div class="game-result-modal" style="max-width: 500px;">
            <div class="game-result-title" style="font-size: 32px; color: #ffd700; margin-bottom: 10px;">–ê–î–ú–ò–ù–†–ï–°–£–†–°</div>
            <div class="game-result-score" style="font-size: 18px; margin-bottom: 30px;">–í—ã —Ä–µ—à–∞–µ—Ç–µ, –∫—Ç–æ —Ö–æ–¥–∏—Ç –ø–µ—Ä–≤—ã–º</div>
            
            <div class="faction-grid" style="grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="faction-square" id="btn-choice-player">
                    <img id="choice-player-logo" src="" alt="Player">
                    <div style="position: absolute; bottom: 10px; font-size: 12px; font-weight: bold;">–Ø –ù–ê–ß–ù–£</div>
                </div>
                
                <div class="faction-square" id="btn-choice-enemy">
                    <img id="choice-enemy-logo" src="" alt="Enemy">
                    <div style="position: absolute; bottom: 10px; font-size: 12px; font-weight: bold;">–°–û–ü–ï–†–ù–ò–ö</div>
                </div>
            </div>
        </div>
    </div>
    
</body>
</html>

